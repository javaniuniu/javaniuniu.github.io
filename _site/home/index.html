<!DOCTYPE html><html lang="en">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>Home - JAVA 牛牛</title>

<meta name="description" content="">
<link rel="canonical" href="http://localhost:4000/home/"><link rel="alternate" type="application/rss+xml" title="JAVA 牛牛" href="/feed.xml"><!-- start favicons snippet, use https://realfavicongenerator.net/ --><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png"><link rel="manifest" href="/assets/site.webmanifest"><link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicons snippet --><link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" ><!-- start custom head snippets -->

<!-- end custom head snippets -->
<script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.isFormElement = function(node) {
    var tagName = node.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i;
      loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cbs[i]();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();
(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();
(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();
</script><script>
  (function() {
    var TEXT_VARIABLES = {
      version: '2.2.6',
      sources: {
        font_awesome: 'https://use.fontawesome.com/releases/v5.0.13/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        valine: 'https://unpkg.com/valine/dist/Valine.min.js',
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3,h4,h5,h6'
        }
      },
      paths: {
        search_js: '/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script>
</head>
  <body>
    <div class="root" data-is-touch="false">
      <div class="layout--page js-page-root"><div class="page__main js-page-main page__viewport cell cell--auto">

      <div class="page__main-inner"><div class="page__header d-print-none"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="256px" height="256px" viewBox="0 0 256 256" enable-background="new 0 0 256 256" xml:space="preserve">  <image id="image0" width="256" height="256" x="0" y="0"
    href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABklBMVEX///99Fxd9Fxd9Fxd9
Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9
Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9
Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9
Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9
Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9
Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9
Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxd9Fxf///9O0pOeAAAAhHRS
TlMAAAQjKwgXLxOD7/efFFPXuzPDGHf7S4uvN/Mko3MwXN+rQGu/LH+nII8MsyiX6+NMx1hjtzhg
R8+Te1Bn518nb0PbHzuHENPLPDRo2IRXxT+bZEhUGz1ExCL60NwVoU9bHA/JYmyu6fFyaaLUrH2V
gAH1Ei1RQloHgakFtNUDduLohQ2rommNAAAAAWJLR0QAiAUdSAAAAAlwSFlzAAALEwAACxMBAJqc
GAAAAAd0SU1FB+QFDgsyHesd3D4AABK2SURBVHja7V35V9tIEkbOOATbYMfYAQxMbHB8cNgh8YA5
TAgB48AsC4Fs9gZm7/u+71394WtzuD/JLanVXZLIG9UPeS9G6q761Ed1XT00FFJIIYUUUkghfWlJ
k6XIg0+i0i+T08PhR3IvygIQHYnpejwxGrTgNzSW1HU99dhHAKJp/ZqS40HL3qPMDTPZJ/4BMKHf
0mTQwndp6o6ZmMSAlAMgmrvrU58OWnxNm+kzM+sXAJ/2u9SfBi2+puX7zBT8AmCOATAftPiaFu8z
U/QLgGcMgFLQ4msaY6bsFwAV1mc1aPG1BcZMwi8ARlmfi0HLry0xZpb9AkCr9fusBy2/9pwBkPEN
gBXWaSVoADKMlxe+AbDMOn0ZNAANxstnvgGwyjqV2HpIKcKUsuyCbwCMMwCC1gXXGCdNiddlT4NJ
pb2HksqMk3UfAdhg3WaXgpR/nOmB+qaPAIAqpKeCBGCE8RGXMdBIW4RSgMBWcPLjAJA6mksDAOqH
Hh8ODICCrjYD5AHQmtB1K6idYBuYyEf8BQCHgJ58FYj8UzngQUIPVgJAm0QEWo8DkP9VCzmQ0ILU
AKjEEYHsju/yv44hA5KWGQUAtC3dQCuPfRU/OpI1TEKpFUANAFTCbvYh/yCIjO0aus5KnIPUAVhI
mhDQkxtTrr7Emy49dN/x3kjd1PGErAxKAGjjLX2A4s1CYqLkRNXJdJ5N4Vq+WN53fOea9hMzzfhA
pynJCaAKgLbEQSAASralJVAEQFuqq7OvTC2F45gqANr4QdDi67sqx1FlALSFRMDyd5QctOoAaNpq
TF0KeUqoRSlQAKCNz6jLIUl1qSMgNQCa9rYYiPjxCfnlnxYATTssxNUFcke5KkF4BhkAmjZ6VPQR
g3jqKUmIEiEAXYrOlcrNnJgEtYNiOdHVGauJxGQxKfjSjezNQmmOKkCLFoBbWqhUKmOfWwpQn/zK
8TPz6X30cHti0Xo7+epJ5ZaI47I8AaB7WCtl+YLkT1/YOROXVss1/ou5bW849QaABytcIZobIjrb
ZyO73LcLnsTkeQLAMW9Gt/bFLaeHy7zJUJ/6OACIVDnMFzfdHVij7zhnjKwHAUn0ALSLg5xPfirR
0BmnoYT0ud83AF4lacTv0dwgBEVl1c9jAPYGFvEVWWtdj84H1kPq4FxiAPbMy19NMZAykjFrl3Va
H4waAO+HT55sb2+/zHT/2X5y8mbVzG1CfcRWzPOg9bWpk+PtW1o7GZYwqioDEB0+HimvONoDa8+V
xe/RvJOeXF8pjxwPyynH7gEYnj8VtII1qDSXpaZQfweJefduancAvNmaFLb+ZAmDaKPCZrfY5NYb
rwAYHkmKstGl3Ac6+bu0lRXvOjniYiCIAvBmY1ecgy7lqQOHPrg5MOu7JdFxIARAZKzhSvrudKRP
pXHrgymOCWmNAgC0M67dP2k5X70DAu7GYHe/zAhswo4APKy6N3p/3Qv5Ne0b33TLSK7qqCQ4ANCu
Spj5vuWN/Jo2656XeNVhL7YFIJqRcXl8+zseyW8IChSmWMZWQ7IDYM1+0mXzxXI1s7r6Yu67+HPL
y1TCNcNesHG+urqzn3AyqeYvpAB4v2jTZKF0/qy/yBqChXLPPJTfFJuW78+1yvPZso1+uvjePQDz
VqM/uWw2axbxz+eeyq9pJezMGB3d3qx2LJjOWdqSLAAYb/BHfXpn0LB3iU+MeCy/puHAzD42/3X0
XYO/bDcsBgEfgDWubbpzxFtR26glpMlNVoP9YUhGmvPAwtMij/vamjAAkX3O+7H1Qz5D+HDMjwSi
t3gsuOQ+Utnn6W77vK/DAaDNGf6tHau9/QpH3KoP8kPmdpd2Lfa4yCpnC0txNMNBADhWzd131lsp
HlR9yiGMIoeWAaqRzUErAiekeQCAvYHBE5u3mdjTMB5zV/4AoL3FsWmj5jwdiOBq7TkBcGHWKRxi
EHAAyIVryxBGpNjFKEc3zJt5bswegDGz3WHF/lyPCRu7/pUUuYLPZJ8mcGVW57ImBIwAmOXPzTts
a7geqUbruCFUhy7tHzWHcJkQMABglr/jtKtFoXGZpD1pakPHHYdnR1N2CCAAeyb5q45aDWas+DkA
NG0Hej50eNYcrJDFlRAAGDaufzkBiSAMwNcBYBwCzknzH4xbWw6MpgyAceOeURewakIhCd9riYAC
mnNefaeNyk2dHdn7AESNBymh+FOwT9S9PwQYaRyG9YXz46Npo3h9zPoAGF0PYlZN0Db9LyUCGYMi
GZORgkHAfsLzHQDbEvJDMZ3sle8AnLHe4yLsmhC4i7m6BWDJsAAWxKyasBkHkT4Ma5aQE9aIQG4a
AYgYzg1pQZUO9oB3AQAAoUinQi9EGihlMwIAGOxMSUGnLpSSyQZRVQ6ORIKVXBYMZsMSA2AJFQXh
PODzYGeApsHmLuiJNCR53dQ9uAagiD+/Fe0fhqBEETMCgo1LNIz0ED918Q6AYxwY4mfapusPQEwv
OLuaE6EKrR/fABDNw2/iRp0FBmYtEPmxksuB8EuY8t07wA8ZQamJr2aH7C07ReTR5fJKPpZPTm64
CHSNvN5v7NZb+VT1wm5HAkVM2BZhMGLv9ACI4i8uSjFtGdqxoGHMI9ndEWPzYQms8rn1B5YPgmHI
6UTICNbunj1tyDAA3Fg119lrVtEwo+ZkqvqYc7uRHbMFY8QKN2DdRT0r1Id2tKEIKFRxN2b9BnvP
Yt5McbJKl50OTeOpwZeaFoPgA3tkX5xxNOTXI0O4BbhKwWYHzBb/gTGuj6por2aPcwOxWvyoJ1gF
Cy44Ryf78RAcE2OuwjrZJrDC/ftri7iuht0YGLUIRGvx42PZCcbJLobUhiUmPQS91AQXqWu6Yu/N
8P5esYytsKtB2bB66YA7cJhq29KEKbKNU3PI0E1LHAKwBnE9wkXdkvYsG92xfokLG9i8hcU/NjqM
hkz91PbfizUEhWV5u+CltSjWWkvbJiIny0s6AGVYTIGJbptdhkODPRX2RJoCPZTnErWN7rUyYZXs
XuJNNDAMimxgDzcGncZDvPAakThLKKnIUQPeGtqrFzuGFdHi8BgxsJdLFw0DgnfkBsSc0zJOypxt
KTZkMe2K8w5TAQCYG/wrlNzUm72/tw1Fb/jjFWaVntvqrkaRc4SEo+tkbJlAelDK6zzaGdKsUhz1
zoZdzPGWbd+wm93ZF8+h6WNuk2jpvp3xaKvnVE22/wpM+g2L2KFsqXcYesbPcrweIJM7ViCU7PqO
sj8y7fKU/cjX22BN78c0gekzKQXAwtqEZZD7yuGtQWTVrhJKLr3+cvgLU7PDW9+z6xtqHRf6P4IR
mas5wOEOXB3sx6wtAFsc/er9xUTaOsy+9a73yo1NMFpyCgmNHSz2qgNtzZZK64sHxpVzEACYzWBg
YbzwK9GyWbrCfoTz1KCIGeAiXtx/+frN9cr16M3e2Oxy0SIL+fbx0o3ee+cXaDtCYE2iADhVgecC
AFv9IAAlEfa44vdrLzDfYLskWxTp+wOMgZrIRvs0+5FfBR6mAJMVDLmDb0gCEK9yfIOaRb6uAP1g
gDEo+B7r9wVGVP6xs8Ee6Bs5p9hvu4NvnDryxqHYCPo9TSEyc2WJ8HiOXxA23cXbr3kCyxHflQzh
Jq1bCwCWa+MY3srOzJnp4Mh43BmIEhud77htk/M98dOkesJEtnDh5LueYcvTW9fq8h7uYJxw36JL
TuPlgfWKFyk6XXKXnMKZ0WeGBzqJScOKzAtw7VLU8FC9UDZs4Dz/q5s0tm63R0KBkte0lEm7aHjw
/YgthFYBpVW7l3imZxfzNZ3hH5es8wXa58uCAPM8c6s2z+9a2YTG7QTi2H1HdTHKLb67sujSIWdo
dHMiJaAfcASK2Kwk1sFHG9Yv8ZTHT3VnyqXsS+4IpM1dne2sLzYRh1qzUNr8Ifs/zzP2zDKNxcaN
ZQ1bnXeAPGd/T6UG+2s1qu8c81dcpM6OV5bmujRdiZi/FveTnluIsmJnFq5YKGM57nEfWHje5e/D
6sZE4pomSqvPn4lFecjXDwAB+c7hee45pGkffcXPD83xXdagBki7Z+UBgAl4yn9ikzMLGk7fpcIx
puUtzD1swmQDKKoK6q6VUX7a7OWJCZSfju6bR86Mlb+CbRpJ53bJAQB1N275zCYaW2ITYimF0wnY
DrPWNWjgyCV/6x9NcXWbtXY6s9hDKtdZ3hR3u7RXEwddELLJwpENZmCYlk9WUwAAXGwSFxwREBye
5LMVFQCAbSCYG9dghZG/4EEBADBwrAQCANtkcvKNqNQRYsqh1P0uqgT7sMJtVyoAgBlbpVyWLIFn
Qrq2vBoAYJHz/3oJg7lUIVtFBQBIZQ/i9l0wu10FA0AbdBz/5Ye7rvIKzSgVUwO1XbZkoDxBhoPK
dW9KAFSDXARgCVAJ1lcCYJPx0PAdAPBnBna/ACwCvmsCcBJyESBFDAD6rWhrpzkT1BSaUWlHDQAI
aVDQRaQIDgJKZRvUAIBYVXmThBQtgMkgwCs2osCGvzfujbGO1ZJ2FavKNhgf/qbNQNyEizhpegCO
GB9ptZbcUQTciMJJTl4AABHDvqbOQQhKTS1rWbWwMmjDft7BDTqo0iaoDkBA6bOgBioWL1MF4NNA
5gBE4golTnsIAGZu+TcHYAaoWiKUAQDjuG/30GNUtWrlCmUA0Ed/5RMAa3QzgKC8PsyBDZ8AmKGb
AQQAwBzw6TyA5wDl2i3qAGApGfH8TRUCY1hOuYIvwQ0ToAutq7cmQBDApqgF0QAAOScxP+xCEItP
YIYhAAAr+nh0H5aBwClMUL2I4pIVOBP7oArgQZDADEUBwDmMSW/LKvcITCEUlSsoAEDFzPtlME07
3kjuGcJ0L+qboMyEmidFEVsSAHBd9uA+NANBRiLJnkNz0xTYqD3WBttx4ulGAwD4yERq2ylQhnYJ
pAIA63B4uhNixRcadyTRZWv4Ybz0lNMXMSUCYBSmZlm9OUsCZ2SepoYl1XV7kCWV9c5HdAEDgCgi
gQoA3AlVAjbsCQ6eMaKrbMguXJz0YQiAKUzRIeYBAFj9wKvI2SKATHWXDd2Vm5DuE7/yRP4TL6YZ
HQCbXrBnoI4Xs4zw0tWmF/wBXXiCMCEAOAS80AUwmYhO2aK8dheT7+mLbKIhhDAylxIAHAI/ylPT
j73RtkkvXha7HFadKNdYUgDO1GUTIdIllvbq7aIvAJxSskwLwGcuLseVphjphYbEl6//xAcAfkrK
MTEAEreCuqYV0sssaAEYl6/G5IJI/W+0AFTVpROgXcohQArAgqvrseVJoDxzMABAJp9+UJSnA44i
iIUVKHPUSAEogvzU1+7g/RiU6SmUALRBCxC69sQVYY0dwvQUjw5D4vX+xQmquROG5lMCAE5iLwLm
wOp4ej8BAMOwF94hKFRKmKRHCQA7DRvy+SOXi7udqnOlYiNN/eznn//izPAT22QJ/Y+UALBsZkzj
Wbjxnefcbd6/vGnoV/z27z0AyOBdtaO4m/Ch79+19OuPHgAW0lIQb+k3fXf7b3/3sQOQYeqLeEu/
Z+vdHz52ACCmR9yQ8Uf20tbHDgBkuYtf4RICEAIQAhACEAIQAhACEAIQAhACEAIQAhACEAIQAhAC
EAIQAhACEALwsQIAlZbEW3rMXvrTxw4AKznootran1mw1QOH9u89ACzNwU3MxF/uXvor/Oh0X+E9
AgA/9vStm8tVltPf/n7z0j+gPBeUcC3cTwAsrmMfXc7pesdlnuc///VvXf/Pf/8HP0EoNmFWFiUA
kENu8oJdyST5PTQ1AkGIR/cTAG8LTWOC9j1NmHjKOPQgSApypnKEMXiUAEB9TYurlVUI0lEoU7JI
AyWhvkmLurriS0BXsYikdwDgPeYp2lDRVxCGXKOsV0UKQBuj5VOEY2BhG0OFqfKm6QHA0nrdD1Xd
o5H+ctJwE2X8HqfMjJoSJurV14oz4ZFJel3lWi3vAeBcNVqbufxCtrUHs8XBLKw8UeUEbwDAwmp9
yqYzU64HwsKTdf7NtWduW/IXgPE8l2s9NrkzLC7869KKVQIe6QroAQDaknXaTC61f/He6f1PLtc7
NtmHi9SJGOQAaG9ruh3F0uvzT15xdvKFTy5mEx2HrKM07QLgCQDaksjF3a2DYvm0dEMjiZlisibw
kj5D/f09AUAbLYgI455iW+q8+QKApj2vq4trpt0NUgXIWwC0yIdToTEtLP2IVxXKPAKAFIPmBn1B
Dh8A6GHwdl/wAntLiqfmr7xk0VsAejQ934jLSp9f3iTf9nwHoEvROWvFzpJi5SNfbi7yA4AeLZxt
LArn1idnjjyc9cEAcE1LLyYW7TfIbLM8+8HryrzBAXBN7cPz2eVGJ280cuTThYmd50v0mt79A6BP
kUqX5uYOK5Wr4JjQhkIKKaSQQgoppC8t/R/dov80OkxKRAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAy
MC0wNS0xNFQxMTo1MDoyOSswMDowMIfyupMAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjAtMDUtMTRU
MTE6NTA6MjkrMDA6MDD2rwIvAAAAAElFTkSuQmCC" />
</svg>
<a title="主要是想看下自己还能在多做些什么
" href="/">JAVA 牛牛</a></div><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></div><nav class="navigation">
        <ul><li class="navigation__item navigation__item--active"><a href="/home/">Home</a></li><li class="navigation__item"><a href="/module.html">模块</a></li><li class="navigation__item"><a href="/leetcode/all">leetcode(力扣)</a></li><li class="navigation__item"><a href="/algo/all">algo(算法)</a></li><li class="navigation__item"><a href="/docker/about">Docker</a></li><li class="navigation__item"><a href="/todo">TODO</a></li><li class="navigation__item"><a href="/pm">PM</a></li><li class="navigation__item"><a href="/archive.html">Archive</a></li><li class="navigation__item"><a href="/about.html">About</a></li><li class="navigation__item"><a href="https://github.com/javaniuniu">GitHub</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li></ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class ="main"><div class="grid grid--reverse">

              <div class="col-aside d-print-none js-col-aside"></div>

              <div class="col-main cell cell--auto"><!-- start custom main top snippet -->

<!-- end custom main top snippet -->
<article itemscope itemtype="http://schema.org/WebPage"><header style="display:none;"><h1>Home</h1></header><meta itemprop="headline" content="Home"><meta itemprop="author" content="java牛牛"/><div class="js-article-content"><div class="layout--articles"><div class="article-list items items--divided"><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><a href="/mianshi/spring/0706/03"><h2 itemprop="headline" class="item__header">谈谈Spring中都用到了哪些设计模式？</h2></a></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h1 id="谈谈spring中都用到了哪些设计模式">谈谈Spring中都用到了哪些设计模式？</h1>

<p>JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的常见的设计模式。</p>

<p>Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p>

<h1 id="控制反转ioc和依赖注入di">控制反转（IOC）和依赖注入（DI)</h1>

<p><strong>IoC(Inversion of Control,控制翻转)</strong> 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(即Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。<strong>IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></p>

<p><img src="/assets/images/mianshiti/0706/Jietu20200706-125354@2x.jpg" alt="img" /></p>

<p>ioc-patterns</p>

<p><strong>Spring IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p>

<p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：</p>

<p>，非常不错。</p>

<p><strong>控制翻转怎么理解呢?</strong> 举个例子：”对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中”。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权反转了，这就是控制反转名字的由来。</p>

<p><strong>DI（Dependency Inject，依赖注入)，是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p>

<h2 id="工厂设计模式">工厂设计模式</h2>

<p>Spring使用工厂模式可以通过 <code class="language-plaintext highlighter-rouge">BeanFactory</code> 或 <code class="language-plaintext highlighter-rouge">ApplicationContext</code> 创建 bean 对象。</p>

<p><strong>两者对比：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code class="language-plaintext highlighter-rouge">BeanFactory</code>来说会占用更少的内存，程序启动速度更快。</li>
  <li><code class="language-plaintext highlighter-rouge">ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code class="language-plaintext highlighter-rouge">BeanFactory</code> 仅提供了最基本的依赖注入支持，<code class="language-plaintext highlighter-rouge">ApplicationContext</code> 扩展了 <code class="language-plaintext highlighter-rouge">BeanFactory</code> ,除了有<code class="language-plaintext highlighter-rouge">BeanFactory</code>的功能之外还有额外更多功能，所以一般开发人员使用<code class="language-plaintext highlighter-rouge">ApplicationContext</code>会更多。</li>
</ul>

<p>ApplicationContext的三个实现类：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li>
  <li><code class="language-plaintext highlighter-rouge">FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li>
  <li><code class="language-plaintext highlighter-rouge">XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li>
</ol>

<p>Example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.support.FileSystemXmlApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileSystemXmlApplicationContext</span><span class="o">(</span>
                <span class="s">"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml"</span><span class="o">);</span>

        <span class="nc">HelloApplicationContext</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HelloApplicationContext</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"helloApplicationContext"</span><span class="o">);</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">getMsg</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="单例设计模式">单例设计模式</h2>

<p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p>

<p><strong>使用单例模式的好处：</strong></p>

<ul>
  <li>对于频繁使用的对象，可以<strong>省略创建对象所花费的时间</strong>，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
  <li>由于new操作的次数减少，因而<strong>对系统内存的使用频率也会降低</strong>，这将减轻GC压力，缩短GC停顿时间。</li>
</ul>

<p><strong>Spring中bean的默认作用域就是singleton(单例)的</strong>，除了singleton作用域，Spring中bean还有下面几种作用域：</p>

<ul>
  <li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
  <li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
  <li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
  <li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>

<p><strong>Spring实现单例的方式：</strong></p>

<ul>
  <li>xml:<code class="language-plaintext highlighter-rouge">&lt;bean id="userService" class="top.snailclimb.UserService" scope="singleton"/&gt;</code></li>
  <li>注解：<code class="language-plaintext highlighter-rouge">@Scope(value = "singleton")</code></li>
</ul>

<p>Spring通过<code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>实现单例注册表的特殊方式实现单例模式。Spring实现单例的核心代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">singletonObjects</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;(</span><span class="mi">64</span><span class="o">);</span>

<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getSingleton</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">ObjectFactory</span><span class="o">&lt;?&gt;</span> <span class="n">singletonFactory</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="s">"'beanName' must not be null"</span><span class="o">);</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 检查缓存中是否存在实例  </span>
            <span class="nc">Object</span> <span class="n">singletonObject</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">singletonObject</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//...省略了很多代码</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">singletonObject</span> <span class="o">=</span> <span class="n">singletonFactory</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="c1">//...省略了很多代码</span>
                <span class="c1">// 如果实例对象在不存在，我们注册到单例注册表中。</span>
                <span class="n">addSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">singletonObject</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">singletonObject</span> <span class="o">!=</span> <span class="no">NULL_OBJECT</span> <span class="o">?</span> <span class="n">singletonObject</span> <span class="o">:</span> <span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//将对象添加到单例注册表</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">addSingleton</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">singletonObject</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">singletonObjects</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="o">(</span><span class="n">singletonObject</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">singletonObject</span> <span class="o">:</span> <span class="no">NULL_OBJECT</span><span class="o">));</span>

            <span class="o">}</span>
        <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="代理设计模式">代理设计模式</h2>

<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>

<p>Spring AOP就是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，Spring AOP会使用Cglib，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理，如下图所示：</p>

<p><img src="/assets/images/mianshiti/0706/Jietu20200706-125429@2x.jpg" alt="img" /></p>

<p>当然你也可以使用AspectJ，Spring AOP以及集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。</p>

<p>使用AOP之后我们可以把一些通用的功能抽象出来，在在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>

<h3 id="spring-aop-和-aspectj-aop-有什么区别">Spring AOP 和 AspectJ AOP 有什么区别?</h3>

<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP <strong>基于代理(Proxying)</strong>，而 AspectJ 基于 <strong>字节码操作(Bytecode Manipulation)</strong>。</p>

<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，功能更弱。</p>

<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>

<h1 id="模板方法">模板方法</h1>

<p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>

<p><img src="/assets/images/mianshiti/0706/Jietu20200706-125421@2x.jpg" alt="img" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Template</span> <span class="o">{</span>
    <span class="c1">//这是我们的模板方法</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">TemplateMethod</span><span class="o">(){</span>
        <span class="nc">PrimitiveOperation1</span><span class="o">();</span>  
        <span class="nc">PrimitiveOperation2</span><span class="o">();</span>
        <span class="nc">PrimitiveOperation3</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">void</span>  <span class="nf">PrimitiveOperation1</span><span class="o">(){</span>
        <span class="c1">//当前类实现</span>
    <span class="o">}</span>

    <span class="c1">//被子类实现的方法</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">PrimitiveOperation2</span><span class="o">();</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">PrimitiveOperation3</span><span class="o">();</span>

<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TemplateImpl</span> <span class="kd">extends</span> <span class="nc">Template</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PrimitiveOperation2</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//当前类实现</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PrimitiveOperation3</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//当前类实现</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Spring 中 <code class="language-plaintext highlighter-rouge">jdbcTemplate</code>、<code class="language-plaintext highlighter-rouge">hibernateTemplate</code> 等<strong>以 Template 结尾的对数据库操作的类</strong>，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是<strong>使用Callback 模式与模板方法模式配合</strong>，既达到了代码复用的效果，同时增加了灵活性。</p>

<h1 id="观察者模式">观察者模式</h1>

<p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring <strong>事件驱动模型</strong> 就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>

<p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>

<h3 id="spring-事件驱动模型中的三种角色">Spring 事件驱动模型中的三种角色</h3>

<h4 id="事件角色">事件角色</h4>

<p><code class="language-plaintext highlighter-rouge">ApplicationEvent</code> (<code class="language-plaintext highlighter-rouge">org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code class="language-plaintext highlighter-rouge">java.util.EventObject</code>并实现了 <code class="language-plaintext highlighter-rouge">java.io.Serializable</code>接口。</p>

<p>Spring 中默认存在以下事件，他们都是对 <code class="language-plaintext highlighter-rouge">ApplicationContextEvent</code> 的实现(继承自<code class="language-plaintext highlighter-rouge">ApplicationContextEvent</code>)：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ContextStartedEvent</code>：<code class="language-plaintext highlighter-rouge">ApplicationContext</code> 启动后触发的事件;</li>
  <li><code class="language-plaintext highlighter-rouge">ContextStoppedEvent</code>：<code class="language-plaintext highlighter-rouge">ApplicationContext</code> 停止后触发的事件;</li>
  <li><code class="language-plaintext highlighter-rouge">ContextRefreshedEvent</code>：<code class="language-plaintext highlighter-rouge">ApplicationContext</code> 初始化或刷新完成后触发的事件;</li>
  <li><code class="language-plaintext highlighter-rouge">ContextClosedEvent</code>：<code class="language-plaintext highlighter-rouge">ApplicationContext</code> 关闭后触发的事件。</li>
</ul>

<p><img src="/assets/images/mianshiti/0706/Jietu20200706-125445@2x.jpg" alt="img" /></p>

<h4 id="事件监听者角色">事件监听者角色</h4>

<p><code class="language-plaintext highlighter-rouge">ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code class="language-plaintext highlighter-rouge">onApplicationEvent（）</code>方法来处理<code class="language-plaintext highlighter-rouge">ApplicationEvent</code>。<code class="language-plaintext highlighter-rouge">ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code class="language-plaintext highlighter-rouge">ApplicationEvent</code>就可以了。所以，在 Spring中我们只要实现 <code class="language-plaintext highlighter-rouge">ApplicationListener</code> 接口实现 <code class="language-plaintext highlighter-rouge">onApplicationEvent()</code> 方法即可完成监听事件</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">org.springframework.context</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.EventListener</span><span class="o">;</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ApplicationListener</span><span class="o">&lt;</span><span class="no">E</span> <span class="kd">extends</span> <span class="nc">ApplicationEvent</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">EventListener</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">onApplicationEvent</span><span class="o">(</span><span class="no">E</span> <span class="n">var1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="事件发布者角色">事件发布者角色</h4>

<p><code class="language-plaintext highlighter-rouge">ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ApplicationEventPublisher</span> <span class="o">{</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">publishEvent</span><span class="o">(</span><span class="nc">ApplicationEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">publishEvent</span><span class="o">((</span><span class="nc">Object</span><span class="o">)</span><span class="n">event</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">publishEvent</span><span class="o">(</span><span class="nc">Object</span> <span class="n">var1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ApplicationEventPublisher</code> 接口的<code class="language-plaintext highlighter-rouge">publishEvent（）</code>这个方法在<code class="language-plaintext highlighter-rouge">AbstractApplicationContext</code>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过<code class="language-plaintext highlighter-rouge">ApplicationEventMulticaster</code>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p>

<h3 id="spring-的事件流程总结">Spring 的事件流程总结</h3>

<ol>
  <li>定义一个事件: 实现一个继承自 <code class="language-plaintext highlighter-rouge">ApplicationEvent</code>，并且写相应的构造函数；</li>
  <li>定义一个事件监听者：实现 <code class="language-plaintext highlighter-rouge">ApplicationListener</code> 接口，重写 <code class="language-plaintext highlighter-rouge">onApplicationEvent()</code> 方法；</li>
  <li>使用事件发布者发布消息: 可以通过 <code class="language-plaintext highlighter-rouge">ApplicationEventPublisher</code> 的 <code class="language-plaintext highlighter-rouge">publishEvent()</code> 方法发布消息。</li>
</ol>

<p>Example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoEvent</span> <span class="kd">extends</span> <span class="nc">ApplicationEvent</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">message</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">DemoEvent</span><span class="o">(</span><span class="nc">Object</span> <span class="n">source</span><span class="o">,</span><span class="nc">String</span> <span class="n">message</span><span class="o">){</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMessage</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
          <span class="o">}</span>


<span class="c1">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoListener</span> <span class="kd">implements</span> <span class="nc">ApplicationListener</span><span class="o">&lt;</span><span class="nc">DemoEvent</span><span class="o">&gt;{</span>

    <span class="c1">//使用onApplicationEvent接收消息</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onApplicationEvent</span><span class="o">(</span><span class="nc">DemoEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getMessage</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"接收到的信息是："</span><span class="o">+</span><span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="c1">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoPublisher</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">publish</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">){</span>
        <span class="c1">//发布事件</span>
        <span class="n">applicationContext</span><span class="o">.</span><span class="na">publishEvent</span><span class="o">(</span><span class="k">new</span> <span class="nc">DemoEvent</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">message</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>当调用 <code class="language-plaintext highlighter-rouge">DemoPublisher</code> 的 <code class="language-plaintext highlighter-rouge">publish()</code> 方法的时候，比如 <code class="language-plaintext highlighter-rouge">demoPublisher.publish("你好")</code> ，控制台就会打印出:<code class="language-plaintext highlighter-rouge">接收到的信息是：你好</code> 。</p>

<h1 id="适配器模式">适配器模式</h1>

<p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>

<h3 id="spring-aop中的适配器模式">spring AOP中的适配器模式</h3>

<p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code class="language-plaintext highlighter-rouge">AdvisorAdapter</code> 。Advice 常用的类型有：<code class="language-plaintext highlighter-rouge">BeforeAdvice</code>（目标方法调用前,前置通知）、<code class="language-plaintext highlighter-rouge">AfterAdvice</code>（目标方法调用后,后置通知）、<code class="language-plaintext highlighter-rouge">AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code class="language-plaintext highlighter-rouge">MethodBeforeAdviceInterceptor</code>、<code class="language-plaintext highlighter-rouge">AfterReturningAdviceAdapter</code>、<code class="language-plaintext highlighter-rouge">AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code class="language-plaintext highlighter-rouge">MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code class="language-plaintext highlighter-rouge">MethodBeforeAdviceInterceptor</code> 负责适配 <code class="language-plaintext highlighter-rouge">MethodBeforeAdvice</code>）。</p>

<h3 id="spring-mvc中的适配器模式">spring MVC中的适配器模式</h3>

<p>在Spring MVC中，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 根据请求信息调用 <code class="language-plaintext highlighter-rouge">HandlerMapping</code>，解析请求对应的 <code class="language-plaintext highlighter-rouge">Handler</code>。解析到对应的 <code class="language-plaintext highlighter-rouge">Handler</code>（也就是我们平常说的 <code class="language-plaintext highlighter-rouge">Controller</code> 控制器）后，开始由<code class="language-plaintext highlighter-rouge">HandlerAdapter</code> 适配器处理。<code class="language-plaintext highlighter-rouge">HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code class="language-plaintext highlighter-rouge">Controller</code> 作为需要适配的类。</p>

<p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code class="language-plaintext highlighter-rouge">Controller</code> 种类众多，不同类型的 <code class="language-plaintext highlighter-rouge">Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code class="language-plaintext highlighter-rouge">DispatcherServlet</code> 直接获取对应类型的 <code class="language-plaintext highlighter-rouge">Controller</code>，需要的自行来判断，像下面这段代码一样：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(mappedHandler.getHandler() instanceof MultiActionController){  
   ((MultiActionController)mappedHandler.getHandler()).xxx  
}else if(mappedHandler.getHandler() instanceof XXX){  
    ...  
}else if(...){  
   ...  
}  
</code></pre></div></div>

<p>假如我们再增加一个 <code class="language-plaintext highlighter-rouge">Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p>

<h1 id="装饰者模式">装饰者模式</h1>

<p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code class="language-plaintext highlighter-rouge">InputStream</code>家族，<code class="language-plaintext highlighter-rouge">InputStream</code> 类下有 <code class="language-plaintext highlighter-rouge">FileInputStream</code> (读取文件)、<code class="language-plaintext highlighter-rouge">BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code class="language-plaintext highlighter-rouge">InputStream</code>代码的情况下扩展了它的功能。</p>

<p><img src="/assets/images/mianshiti/0706/Jietu20200706-125402@2x.jpg" alt="img" /></p>

<p>​ 装饰者模式示意图</p>

<p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code class="language-plaintext highlighter-rouge">Wrapper</code>或者 <code class="language-plaintext highlighter-rouge">Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责</p>

<h2 id="总结">总结</h2>

<p>Spring 框架中用到了哪些设计模式：</p>

<ul>
  <li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code class="language-plaintext highlighter-rouge">BeanFactory</code>、<code class="language-plaintext highlighter-rouge">ApplicationContext</code> 创建 bean 对象。</li>
  <li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
  <li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
  <li><strong>模板方法模式</strong> : Spring 中 <code class="language-plaintext highlighter-rouge">jdbcTemplate</code>、<code class="language-plaintext highlighter-rouge">hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
  <li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
  <li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
  <li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code class="language-plaintext highlighter-rouge">Controller</code>。</li>
  <li>……</li>
</ul>
</div><p><a href="/mianshi/spring/0706/03">Read more</a></p></div><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Jul 06, 2020</span>
            </li><li><i class="far fa-eye"></i> <span class="js-pageview" data-page-key="mianshi-2020-07-06-03">0</span> views</li></ul></div><meta itemprop="author" content="java牛牛"/><meta itemprop="datePublished" content="2020-07-06T00:00:00+08:00">
    <meta itemprop="keywords" content="面试题"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><a href="/mianshi/spring/0706/01"><h2 itemprop="headline" class="item__header">详述 Spring MVC 框架中拦截器 Interceptor 的使用方法</h2></a></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h4 id="1-前言">1 前言</h4>

<p>网络上关于Interceptor的文章，但感觉内容都大同小异，而且知识点零零散散，不太方便阅读。</p>

<p>因此，整理一篇关于拦截器的文章，在此分享给大家，以供大家参考阅读。</p>

<h4 id="2-拦截器">2 拦截器</h4>

<h5 id="21-概念">2.1 概念</h5>

<p>Java 里的拦截器是动态拦截action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在 AOP（Aspect-Oriented Programming，面向切面编程）中拦截器用于在某个方法（包括构造器）或字段被访问之前进行拦截，然后在之前或之后加入某些操作。特别地，现阶段 Spring 自身仅支持基于方法的拦截操作！如果基于方法的拦截操作不能满足需求，可以使用 AspectJ 与 Spring 进行集成，以实现更细粒度或更多方面的拦截操作。</p>

<h5 id="22-原理">2.2 原理</h5>

<p>拦截器Interceptor的拦截功能是基于 Java 的动态代理来实现的，具体可以参考博文「用 Java 实现拦截器 Interceptor 的拦截功能 」，也可以通过阅读 Spring 源代码来了解更为权威的实现细节。</p>

<h4 id="3-实现方法">3 实现方法</h4>

<p>在 Spring 框架之中，我们要想实现拦截器的功能，主要通过两种途径，第一种是实现HandlerInterceptor接口，第二种是实现<code class="language-plaintext highlighter-rouge">WebRequestInterceptor</code>接口。接下来，我们分别详细的介绍两者的实现方法。</p>

<h5 id="31-handlerinterceptor-接口">3.1 HandlerInterceptor 接口</h5>

<p>在<code class="language-plaintext highlighter-rouge">HandlerInterceptor</code>接口中，定义了 3 个方法，分别为<code class="language-plaintext highlighter-rouge">preHandle()</code>、<code class="language-plaintext highlighter-rouge">postHandle()</code>和<code class="language-plaintext highlighter-rouge">afterCompletion()</code>，我们就是通过复写这 3 个方法来对用户的请求进行拦截处理的。因此，我们可以通过直接实现HandlerInterceptor接口来实现拦截器的功能。不过在 Spring 框架之中，其还提供了另外一个接口和一个抽象类，实现了对HandlerInterceptor接口的功能扩展，分别为：<code class="language-plaintext highlighter-rouge">AsyncHandlerIntercepto</code>r和<code class="language-plaintext highlighter-rouge">HandlerInterceptorAdapter</code>.</p>

<p>对于<code class="language-plaintext highlighter-rouge">AsyncHandlerInterceptor</code>接口，其在继承HandlerInterceptor接口的同时，又声明了一个新的方法afterConcurrentHandlingStarted()；而HandlerInterceptorAdapter抽象类，则是更进一步，在其继承<code class="language-plaintext highlighter-rouge">AsyncHandlerInterceptor</code>接口的同时，又复写了preHandle方法。因此，AsyncHandlerInterceptor更像是一个过渡的接口。</p>

<p>在实际应用中，我们一般都是通过实现<code class="language-plaintext highlighter-rouge">HandlerInterceptor</code>接口或者继承<code class="language-plaintext highlighter-rouge">HandlerInterceptorAdapter</code>抽象类，复写preHandle()、postHandle()和afterCompletion()这 3 个方法来对用户的请求进行拦截处理的。下面，我们就详细介绍这个 3 个方法。</p>

<p><code class="language-plaintext highlighter-rouge">preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)</code> 方法，该方法在请求处理之前进行调用。Spring MVC 中的Interceptor是链式调用的，在一个应用中或者说是在一个请求中可以同时存在多个<code class="language-plaintext highlighter-rouge">Interceptor</code>。每个Interceptor的调用会依据它的声明顺序依次执行，而且最先执行的都是<code class="language-plaintext highlighter-rouge">Interceptor</code>中的preHandle方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求做一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔（Boolean）类型的，当它返回为false时，表示请求结束，后续的<code class="language-plaintext highlighter-rouge">Interceptor</code>和控制器（Controller）都不会再执行；当返回值为true时，就会继续调用下一个Interceptor的preHandle方法，如果已经是最后一个<code class="language-plaintext highlighter-rouge">Interceptor</code>的时候，就会是调用当前请求的控制器中的方法。
<code class="language-plaintext highlighter-rouge">postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)</code>方法，通过preHandle方法的解释，我们知道这个方法包括后面要说到的afterCompletion方法都只能在当前所属的<code class="language-plaintext highlighter-rouge">Interceptor</code>的preHandle方法的返回值为true的时候，才能被调用。postHandle方法在当前请求进行处理之后，也就是在控制器中的方法调用之后执行，但是它会在<code class="language-plaintext highlighter-rouge">DispatcherServlet</code>进行视图返回渲染之前被调用，所以我们可以在这个方法中对控制器处理之后的ModelAndView对象进行操作。postHandle方法被调用的方向跟<code class="language-plaintext highlighter-rouge">preHandle</code>是相反的，也就是说，先声明的Interceptor的postHandle方法反而会后执行。这和 Struts2 里面的Interceptor的执行过程有点类似，Struts2 里面的Interceptor的执行过程也是链式的，只是在 Struts2 里面需要手动调用ActionInvocation的invoke方法来触发对下一个<code class="language-plaintext highlighter-rouge">Interceptor</code>或者是action的调用，然后每一个Interceptor中在invoke方法调用之前的内容都是按照声明顺序执行的，而invoke方法之后的内容就是反向的。
<code class="language-plaintext highlighter-rouge">afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)</code>方法，也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。因此，该方法将在整个请求结束之后，也就是在<code class="language-plaintext highlighter-rouge">DispatcherServlet</code>渲染了对应的视图之后执行，这个方法的主要作用是用于进行资源清理的工作。
接下来，我们在看看以上接口和抽象类的具体代码：</p>

<p>HandlerInterceptor 接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">org.springframework.web.servlet</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HandlerInterceptor</span> <span class="o">{</span>

	<span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span>
	    <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

	<span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span>
			<span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">ModelAndView</span> <span class="n">modelAndView</span><span class="o">)</span>
			<span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

	<span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span>
			<span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span>
			<span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>

<p>AsyncHandlerInterceptor 接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">org.springframework.web.servlet</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AsyncHandlerInterceptor</span> <span class="kd">extends</span> <span class="nc">HandlerInterceptor</span> <span class="o">{</span>

	<span class="kt">void</span> <span class="nf">afterConcurrentHandlingStarted</span><span class="o">(</span>
			<span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span>
			<span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>

<p>HandlerInterceptorAdapter 抽象类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">org.springframework.web.servlet.handler</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.AsyncHandlerInterceptor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.ModelAndView</span><span class="o">;</span>

<span class="cm">/**

 * Abstract adapter class for the HandlerInterceptor interface,

 * for simplified implementation of pre-only/post-only interceptors.
   *

 * @author Juergen Hoeller

 * @since 05.12.2003
   */</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">HandlerInterceptorAdapter</span> <span class="kd">implements</span> <span class="nc">AsyncHandlerInterceptor</span> <span class="o">{</span>

   <span class="cm">/**

    * This implementation always returns {@code true}.
      */</span>
      <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span>
      <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
      <span class="o">}</span>

   <span class="cm">/**

    * This implementation is empty.
      */</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span>
      	<span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">ModelAndView</span> <span class="n">modelAndView</span><span class="o">)</span>
      	<span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="o">}</span>

   <span class="cm">/**

    * This implementation is empty.
      */</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span>
      	<span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span>
      	<span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="o">}</span>

   <span class="cm">/**

    * This implementation is empty.
      */</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterConcurrentHandlingStarted</span><span class="o">(</span>
      	<span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span>
      	<span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="o">}</span>
      <span class="o">}</span>
</code></pre></div></div>

<p>如上面的代码所示，其实在HandlerInterceptor和AsyncHandlerInterceptor中还有很多的代码注释，只是博主感觉太多了，就将其全部删除了。如果大家对这些注释感兴趣的话，可以自行查看源代码。下面，我们以继承HandlerInterceptorAdapter抽象类为例进行演示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.hit.interceptor</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.ModelAndView</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.handler.HandlerInterceptorAdapter</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="cm">/**

 * @author 维C果糖

 * @create 2017-03-31
   */</span>
   <span class="kd">public</span> <span class="kd">class</span> <span class="nc">WrongCodeInterceptor</span> <span class="kd">extends</span> <span class="nc">HandlerInterceptorAdapter</span> <span class="o">{</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span>
           <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"WrongCodeInterceptor, preHandle......"</span><span class="o">);</span>
       <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span>
           <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">ModelAndView</span> <span class="n">modelAndView</span><span class="o">)</span>
           <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"WrongCodeInterceptor, postHandle......"</span><span class="o">);</span>
   <span class="o">}</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span>
           <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span>
           <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"WrongCodeInterceptor, afterCompletion......"</span><span class="o">);</span>
   <span class="o">}</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterConcurrentHandlingStarted</span><span class="o">(</span>
           <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span>
           <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"WrongCodeInterceptor, afterConcurrentHandlingStarted......"</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="32-webrequestinterceptor-接口">3.2 WebRequestInterceptor 接口</h5>

<p>在<code class="language-plaintext highlighter-rouge">WebRequestInterceptor</code>接口中也定义了 3 个方法，同HandlerInterceptor接口完全相同，我们也是通过复写这 3 个方法来对用户的请求进行拦截处理的。而且这 3 个方法都传递了同一个参数WebRequest，那么这个WebRequest到底是什么呢？其实这个WebRequest是 Spring 中定义的一个接口，它里面的方法定义跟HttpServletRequest类似，在<code class="language-plaintext highlighter-rouge">WebRequestInterceptor</code>中对WebRequest进行的所有操作都将同步到HttpServletRequest中，然后在当前请求中依次传递。</p>

<p>在 Spring 框架之中，还提供了一个和<code class="language-plaintext highlighter-rouge">WebRequestInterceptor</code>接口长的很像的抽象类，那就是：<code class="language-plaintext highlighter-rouge">WebRequestInterceptorAdapter</code>，其实现了<code class="language-plaintext highlighter-rouge">AsyncHandlerInterceptor</code>接口，并在内部调用了WebRequestInterceptor接口。</p>

<p>接下来，我们主要讲一下<code class="language-plaintext highlighter-rouge">WebRequestInterceptor</code>接口的 3 个函数：</p>

<p><code class="language-plaintext highlighter-rouge">preHandle(WebRequest request)</code>方法，该方法在请求处理之前进行调用，也就是说，其会在控制器中的方法调用之前被调用。这个方法跟<code class="language-plaintext highlighter-rouge">HandlerInterceptor</code>中的preHandle不同，主要区别在于该方法的返回值是void类型的，也就是没有返回值，因此我们主要用它来进行资源的准备工作，比如我们在使用 Hibernate 的时候，可以在这个方法中准备一个 Hibernate 的Session对象，然后利用WebRequest的<code class="language-plaintext highlighter-rouge">setAttribute(name, value, scope)</code>把它放到WebRequest的属性中。在这里，进一步说说setAttribute方法的第三个参数scope，该参数是一个Integer类型的。在WebRequest的父层接口RequestAttributes中对它定义了三个常量，分别为：
SCOPE_REQUEST，它的值是0，表示只有在request中可以访问。
SCOPE_SESSION，它的值是1，如果环境允许的话，它表示的是一个局部的隔离的session，否则就代表普通的session，并且在该session范围内可以访问。
SCOPE_GLOBAL_SESSION，它的值是2，如果环境允许的话，它表示的是一个全局共享的session，否则就代表普通的session，并且在该session范围内可以访问。
<code class="language-plaintext highlighter-rouge">postHandle(WebRequest request, ModelMap model)</code>方法，该方法在请求处理之后，也就是在控制器中的方法调用之后被调用，但是会在视图返回被渲染之前被调用，所以可以在这个方法里面通过改变数据模型ModelMap来改变数据的展示。该方法有两个参数，WebRequest对象是用于传递整个请求数据的，比如在preHandle中准备的数据都可以通过WebRequest来传递和访问；ModelMap就是控制器处理之后返回的Model对象，我们可以通过改变它的属性来改变返回的Model模型。
<code class="language-plaintext highlighter-rouge">afterCompletion(WebRequest request, Exception ex)</code>方法，该方法会在整个请求处理完成，也就是在视图返回并被渲染之后执行。因此可以在该方法中进行资源的释放操作。而WebRequest参数就可以把我们在preHandle中准备的资源传递到这里进行释放。Exception参数表示的是当前请求的异常对象，如果在控制器中抛出的异常已经被 Spring 的异常处理器给处理了的话，那么这个异常对象就是是null。
接下来，我们在看看以上接口和抽象类的具体代码：</p>

<p>WebRequestInterceptor 接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">org.springframework.web.context.request</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.ui.ModelMap</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">WebRequestInterceptor</span> <span class="o">{</span>

	<span class="kt">void</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">WebRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

	<span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span><span class="nc">WebRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">ModelMap</span> <span class="n">model</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

	<span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span><span class="nc">WebRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>

<p>WebRequestInterceptorAdapter 抽象类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">org.springframework.web.servlet.handler</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.util.Assert</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.context.request.AsyncWebRequestInterceptor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.context.request.WebRequestInterceptor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.AsyncHandlerInterceptor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.ModelAndView</span><span class="o">;</span>

<span class="cm">/**

 * Adapter that implements the Servlet HandlerInterceptor interface

 * and wraps an underlying WebRequestInterceptor.
   *

 * @author Juergen Hoeller

 * @since 2.0

 * @see org.springframework.web.context.request.WebRequestInterceptor

 * @see org.springframework.web.servlet.HandlerInterceptor
   */</span>
   <span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebRequestHandlerInterceptorAdapter</span> <span class="kd">implements</span> <span class="nc">AsyncHandlerInterceptor</span> <span class="o">{</span>

   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">WebRequestInterceptor</span> <span class="n">requestInterceptor</span><span class="o">;</span>

   <span class="cm">/**

    * Create a new WebRequestHandlerInterceptorAdapter for the given WebRequestInterceptor.
    * @param requestInterceptor the WebRequestInterceptor to wrap
      */</span>
      <span class="kd">public</span> <span class="nf">WebRequestHandlerInterceptorAdapter</span><span class="o">(</span><span class="nc">WebRequestInterceptor</span> <span class="n">requestInterceptor</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">requestInterceptor</span><span class="o">,</span> <span class="s">"WebRequestInterceptor must not be null"</span><span class="o">);</span>
      <span class="k">this</span><span class="o">.</span><span class="na">requestInterceptor</span> <span class="o">=</span> <span class="n">requestInterceptor</span><span class="o">;</span>
      <span class="o">}</span>


	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span>
			<span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

		<span class="k">this</span><span class="o">.</span><span class="na">requestInterceptor</span><span class="o">.</span><span class="na">preHandle</span><span class="o">(</span><span class="k">new</span> <span class="nc">DispatcherServletWebRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">));</span>
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">ModelAndView</span> <span class="n">modelAndView</span><span class="o">)</span>
			<span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

		<span class="k">this</span><span class="o">.</span><span class="na">requestInterceptor</span><span class="o">.</span><span class="na">postHandle</span><span class="o">(</span><span class="k">new</span> <span class="nc">DispatcherServletWebRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">),</span>
				<span class="o">(</span><span class="n">modelAndView</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">modelAndView</span><span class="o">.</span><span class="na">wasCleared</span><span class="o">()</span> <span class="o">?</span> <span class="n">modelAndView</span><span class="o">.</span><span class="na">getModelMap</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">));</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span>
			<span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

		<span class="k">this</span><span class="o">.</span><span class="na">requestInterceptor</span><span class="o">.</span><span class="na">afterCompletion</span><span class="o">(</span><span class="k">new</span> <span class="nc">DispatcherServletWebRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">),</span> <span class="n">ex</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterConcurrentHandlingStarted</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">requestInterceptor</span> <span class="k">instanceof</span> <span class="nc">AsyncWebRequestInterceptor</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">AsyncWebRequestInterceptor</span> <span class="n">asyncInterceptor</span> <span class="o">=</span> <span class="o">(</span><span class="nc">AsyncWebRequestInterceptor</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">requestInterceptor</span><span class="o">;</span>
			<span class="nc">DispatcherServletWebRequest</span> <span class="n">webRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DispatcherServletWebRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
			<span class="n">asyncInterceptor</span><span class="o">.</span><span class="na">afterConcurrentHandlingStarted</span><span class="o">(</span><span class="n">webRequest</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>如上面的代码所示，展示了WebRequestInterceptor接口和WebRequestInterceptorAdapter抽象类的源码。下面，我们以实现WebRequestInterceptor接口为例进行演示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.hit.interceptor</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.ui.ModelMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.context.request.WebRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.context.request.WebRequestInterceptor</span><span class="o">;</span>

<span class="cm">/**

 * @author 维C果糖

 * @create 2017-03-31
   */</span>
   <span class="kd">public</span> <span class="kd">class</span> <span class="nc">WrongCodeInterceptor</span> <span class="kd">implements</span> <span class="nc">WebRequestInterceptor</span> <span class="o">{</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">WebRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"WrongCodeInterceptor, preHandle......"</span><span class="o">);</span>
   <span class="o">}</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span><span class="nc">WebRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">ModelMap</span> <span class="n">model</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"WrongCodeInterceptor, postHandle......"</span><span class="o">);</span>
   <span class="o">}</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span><span class="nc">WebRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"WrongCodeInterceptor, afterCompletion......"</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="33-abstractinterceptor-抽象类">3.3 AbstractInterceptor 抽象类</h5>

<p>除了上面3.2 和3.3所讲的内容，我们还可以通过继承 Struts2 框架提供的<code class="language-plaintext highlighter-rouge">AbstractInterceptor</code>抽象类来实现拦截的功能。如果我们在深入一点研究，会发现AbstractInterceptor实现了Interceptor接口，而Interceptor接口又继承了Serializable接口。</p>

<p>在Interceptor接口中，提供了 3 个方法供我们使用，分别为<code class="language-plaintext highlighter-rouge">init()、destroy()和intercept()</code>，由于AbstractInterceptor实现了Interceptor接口，因此我们就可以直接继承AbstractInterceptor，然后复写方法就可以啦！至于为什么继承AbstractInterceptor而不是直接实现Interceptor接口，是因为AbstractInterceptor已经帮我们实现了空的init()和destroy()方法，不需要我们自己去复写了，我们直接复写intercept()方法就可以了。现在，我们大致了解一下这 3 个方法的作用：</p>

<p>init()方法，一般用来进行初始化操作；
destroy()方法，一般用来进行释放资源的操作；
intercept()方法，该方法是实现拦截功能的主要方法，我们就在该方法中编写拦截的逻辑。
接下来，我们再看看以上接口和抽象类的具体代码：</p>

<p>Interceptor 接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kn">package</span> <span class="nn">com.opensymphony.xwork2.interceptor</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.opensymphony.xwork2.ActionInvocation</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.Serializable</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Interceptor</span> <span class="kd">extends</span> <span class="nc">Serializable</span> <span class="o">{</span>

    <span class="cm">/**
     * Called to let an interceptor clean up any resources it has allocated.
     */</span>
    <span class="kt">void</span> <span class="nf">destroy</span><span class="o">();</span>

    <span class="cm">/**
     * Called after an interceptor is created, but before any requests are processed using
     * {@link #intercept(com.opensymphony.xwork2.ActionInvocation) intercept} , giving
     * the Interceptor a chance to initialize any needed resources.
     */</span>
    <span class="kt">void</span> <span class="nf">init</span><span class="o">();</span>

    <span class="cm">/**
     * Allows the Interceptor to do some processing on the request before and/or after the rest of the processing of the
     * request by the {@link ActionInvocation} or to short-circuit the processing and just return a String return code.
     *
     * @param invocation the action invocation
     * @return the return code, either returned from {@link ActionInvocation#invoke()}, or from the interceptor itself.
     * @throws Exception any system-level error, as defined in {@link com.opensymphony.xwork2.Action#execute()}.
     */</span>
    <span class="nc">String</span> <span class="nf">intercept</span><span class="o">(</span><span class="nc">ActionInvocation</span> <span class="n">invocation</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>

<p>AbstractInterceptor 接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kn">package</span> <span class="nn">com.opensymphony.xwork2.interceptor</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.opensymphony.xwork2.ActionInvocation</span><span class="o">;</span>

<span class="cm">/**

 * Provides default implementations of optional lifecycle methods
   */</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractInterceptor</span> <span class="kd">implements</span> <span class="nc">Interceptor</span> <span class="o">{</span>

   <span class="cm">/**

    * Does nothing
      */</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
      <span class="o">}</span>

   <span class="cm">/**

    * Does nothing
      */</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span>
      <span class="o">}</span>

   <span class="cm">/**

    * Override to handle interception
      */</span>
      <span class="kd">public</span> <span class="kd">abstract</span> <span class="nc">String</span> <span class="nf">intercept</span><span class="o">(</span><span class="nc">ActionInvocation</span> <span class="n">invocation</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如上面的代码所示，展示了Interceptor接口和AbstractInterceptor抽象类的源码。下面，我们以继承AbstractInterceptor抽象类为例进行演示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.hit.interceptor</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.opensymphony.xwork2.ActionInvocation</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.opensymphony.xwork2.interceptor.AbstractInterceptor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.struts2.ServletActionContext</span><span class="o">;</span>


<span class="cm">/**

 * @author 维C果糖

 * @create 2017-03-31
   */</span>
   <span class="kd">public</span> <span class="kd">class</span> <span class="nc">WrongCodeInterceptor</span>  <span class="kd">extends</span> <span class="nc">AbstractInterceptor</span> <span class="o">{</span>

   <span class="cm">/**

    * 通过拦截功能，验证用户是否登录
      */</span>
      <span class="kd">public</span> <span class="nc">String</span> <span class="nf">intercept</span><span class="o">(</span><span class="nc">ActionInvocation</span> <span class="n">invocation</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

      <span class="nc">UserInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="o">(</span><span class="nc">UserInfo</span><span class="o">)</span> <span class="nc">ServletActionContext</span><span class="o">.</span><span class="na">getRequest</span><span class="o">().</span><span class="na">getSession</span><span class="o">().</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"user"</span><span class="o">);</span>

      <span class="k">if</span><span class="o">(</span><span class="n">info</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">info</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">""</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">info</span><span class="o">.</span><span class="na">getPwd</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">""</span><span class="o">))</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">invocation</span><span class="o">.</span><span class="na">invoke</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
      <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>UserInfo 类文件：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**

 * @author 维C果糖

 * @create 2017-03-31
   */</span>
   <span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserInfo</span> <span class="o">{</span>
   <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
   <span class="nc">String</span> <span class="n">pwd</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPwd</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">pwd</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setPwd</span><span class="o">(</span><span class="nc">String</span> <span class="n">pwd</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">this</span><span class="o">.</span><span class="na">pwd</span> <span class="o">=</span> <span class="n">pwd</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="4-配置拦截器">4 配置拦截器</h4>

<p>在前面，我们用了很大篇幅的内容讲述了拦截器如何实现，因此，我相信大家对于如何实现拦截器已经没有问题啦！接下来，我们在看看，如何在 XML 文件中配置拦截器，以使我们的拦截器生效。</p>

<p>在配置拦截器之前，有 4 个名称的概念需要大家先了解一下，分别为：Join Point、Pointcut、Advice和Advisor：</p>

<p>Join Point，表示“连接点”，它是程序运行中的某个阶段点，比如方法的调用、异常的抛出等；
Advice，表示“通知”，它是某个连接点所采用的处理逻辑，也就是向连接点注入的代码；
Pointcut，表示“切入点”，它是“连接点”的集合，是程序中需要注入Advice的位置的集合，指明Advice要在什么样的条件下才能被触发；
Advisor，它是Pointcut和Advice的配置器，包括Pointcut和Advice，是将Advice注入程序中Pointcut位置的代码。
接下来，给出 XML 配置文件的声明：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>  
    <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="na">xmlns:context=</span><span class="s">"http://www.springframework.org/schema/context"</span>  
    <span class="na">xmlns:mvc=</span><span class="s">"http://www.springframework.org/schema/mvc"</span>  
    <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans  
     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
     http://www.springframework.org/schema/context  
     http://www.springframework.org/schema/context/spring-context-3.0.xsd  
     http://www.springframework.org/schema/mvc  
     http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"</span><span class="nt">&gt;</span>  

</code></pre></div></div>

<p>在 XML 文件的头部声明完成之后，我们就可以在 Spring 的配置文件中使用mvc标签啦！而在mvc标签中有一个名为mvc:interceptors的标签，该标签就是用于声明 Spring 拦截器的。下面，给出一个配置示例：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;mvc:interceptors&gt;</span>  
    <span class="c">&lt;!-- 使用 bean 定义一个 Interceptor，直接定义在 mvc:interceptors 下面的 Interceptor 将拦截所有的请求 --&gt;</span>  
    <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"com.hit.interceptor.WrongCodeInterceptor"</span><span class="nt">/&gt;</span>  
    <span class="nt">&lt;mvc:interceptor&gt;</span>  
        <span class="nt">&lt;mvc:mapping</span> <span class="na">path=</span><span class="s">"/demo/hello.do"</span><span class="nt">/&gt;</span>  
        <span class="c">&lt;!-- 定义在 mvc:interceptor 下面的 Interceptor，表示对特定的请求进行拦截 --&gt;</span>  
        <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"com.hit.interceptor.LoginInterceptor"</span><span class="nt">/&gt;</span>  
    <span class="nt">&lt;/mvc:interceptor&gt;</span>  
<span class="nt">&lt;/mvc:interceptors&gt;</span>  

</code></pre></div></div>

<p>在 Spring 的XML 配置文件中，我们可以通过mvc:interceptors标签声明一系列的拦截器，例如：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;mvc:interceptors&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"com.hit.interceptor.ContextInterceptor"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"com.hit.interceptor.LoginInterceptor"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"com.hit.interceptor.WrongCodeInterceptor"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/mvc:interceptors&gt;</span>
</code></pre></div></div>

<p>如上所示，这些拦截器就构成了一个拦截器链，或者称之为拦截器栈。这些拦截器的执行顺序是按声明的先后顺序执行的，即：先声明的拦截器先执行，后声明的拦截器后执行。在mvc:interceptors标签下声明interceptor标签主要有两种方式：</p>

<p>直接定义一个Interceptor实现类的bean对象，使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截；
使用mvc:interceptor标签进行声明，使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。
此外，由于拦截器是 AOP 编程思想的典型应用，也就意味着我们可以“切”到具体的“面”进行某些操作。例如，</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"WrongCodeInterceptor"</span> <span class="na">class=</span><span class="s">"com.hit.interceptor.WrongCodeInterceptor"</span><span class="nt">&gt;</span>
		<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"userName"</span> <span class="na">value=</span><span class="s">"user-module"</span><span class="nt">&gt;&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"loginInterceptor"</span> <span class="na">class=</span><span class="s">"com.hit.interceptor.LoginInterceptor"</span><span class="nt">&gt;</span>
	<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"excludePackages"</span><span class="nt">&gt;</span>
	   <span class="nt">&lt;list&gt;</span>
		  <span class="nt">&lt;value&gt;</span>com.hit.user.exception<span class="nt">&lt;/value&gt;</span>
		  <span class="nt">&lt;value&gt;</span>com.hit.order.exception<span class="nt">&lt;/value&gt;</span>
	   <span class="nt">&lt;/list&gt;</span>
	<span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;aop:config&gt;</span>
	<span class="nt">&lt;aop:advisor</span> <span class="na">advice-ref=</span><span class="s">"WrongCodeInterceptor"</span> <span class="na">pointcut=</span><span class="s">"execution(* com.hit.*.demo..*.*(..)) "</span> <span class="nt">/&gt;</span>
	<span class="nt">&lt;aop:advisor</span> <span class="na">advice-ref=</span><span class="s">"loginInterceptor"</span> <span class="na">pointcut=</span><span class="s">"execution(* com.hit.*.demo..*.*(..))"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/aop:config&gt;</span>
</code></pre></div></div>

<p>如上所示，我们实现了切入到“面”进行特定的拦截功能，其中pointcut表示“切入点”，advisor表示要注入到pointcut的代码。实际上，如果在多个拦截器配置中，pointcut表达式都相同，我们可以将其抽取出来，单独声明，然后通过pointcut-ref标签进行引用，这样可以稍微简化一些配置！</p>

<p>除此之外，大家可能会对pointcut中的*符号有所疑惑，它是“通配符”，表示可以匹配该位置上的任何名称。当然，如果我们要想使用aop标签，就得先在配置文件中进行声明啦！最后，如果大家想进一步了解切入点pointcut表达式的话，可以参考博文「Spring 框架中切入点 pointcut 表达式的常用写法 」。</p>
</div><p><a href="/mianshi/spring/0706/01">Read more</a></p></div><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Jul 06, 2020</span>
            </li><li><i class="far fa-eye"></i> <span class="js-pageview" data-page-key="mianshi-2020-07-06-01">0</span> views</li></ul></div><meta itemprop="author" content="java牛牛"/><meta itemprop="datePublished" content="2020-07-06T00:00:00+08:00">
    <meta itemprop="keywords" content="面试题"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><a href="/mianshi/spring/0706/02"><h2 itemprop="headline" class="item__header">拦截器（Interceptor）和过滤器（Filter）的执行顺序和区别</h2></a></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h4 id="一引言">一、引言</h4>

<p>本来想记录一下关于用户登陆和登陆之后的权限管理、菜单管理的问题，想到解决这个问题用到Interceptor，但想到了Interceptor，就想到了Filter，于是就想说一下它们的执行顺序和区别。关于Interceptor解决权限和菜单管理的问题，在放在下一篇写吧，就酱紫。</p>

<h4 id="二区别">二、区别</h4>

<h5 id="1过滤器filter">1、过滤器（Filter）</h5>

<p>首先说一下Filter的使用地方，我们在配置web.xml时，总会配置下面一段设置字符编码，不然会导致乱码问题：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;filter&gt;</span>
    <span class="nt">&lt;filter-name&gt;</span>encoding<span class="nt">&lt;/filter-name&gt;</span>
    <span class="nt">&lt;filter-class&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="nt">&lt;/filter-class&gt;</span>
    <span class="nt">&lt;init-param&gt;</span>
        <span class="nt">&lt;param-name&gt;</span>encoding<span class="nt">&lt;/param-name&gt;</span>
        <span class="nt">&lt;param-value&gt;</span>UTF-8<span class="nt">&lt;/param-value&gt;</span>
    <span class="nt">&lt;/init-param&gt;</span>
    <span class="nt">&lt;init-param&gt;</span>
        <span class="nt">&lt;param-name&gt;</span>forceEncoding<span class="nt">&lt;/param-name&gt;</span>
        <span class="nt">&lt;param-value&gt;</span>true<span class="nt">&lt;/param-value&gt;</span>
    <span class="nt">&lt;/init-param&gt;</span>
<span class="nt">&lt;/filter&gt;</span>

<span class="nt">&lt;filter-mapping&gt;</span>
    <span class="nt">&lt;filter-name&gt;</span>encoding<span class="nt">&lt;/filter-name&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>/*<span class="nt">&lt;/servlet-name&gt;</span>
<span class="nt">&lt;/filter-mapping&gt;</span>
</code></pre></div></div>

<p>配置这个地方的目的，是让所有的请求都需要进行字符编码的设置，下面来介绍一下Filter。</p>

<p><strong>（1）过滤器(Filter)：</strong> 它依赖于servlet容器。在实现上，基于函数回调，它可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的，是用来做一些过滤操作，获取我们想要获取的数据，比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。通常用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。</p>

<h5 id="2拦截器interceptor">2、拦截器（Interceptor）</h5>

<p>拦截器的配置一般在SpringMVC的配置文件中，使用Interceptors标签，具体配置如下：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;mvc:interceptors&gt;</span>
    <span class="nt">&lt;mvc:interceptor&gt;</span>
        <span class="nt">&lt;mvc:mapping</span> <span class="na">path=</span><span class="s">"/**"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"com.scorpios.atcrowdfunding.web.LoginInterceptor"</span><span class="nt">&gt;&lt;/bean&gt;</span>
    <span class="nt">&lt;/mvc:interceptor&gt;</span>
    <span class="nt">&lt;mvc:interceptor&gt;</span>
        <span class="nt">&lt;mvc:mapping</span> <span class="na">path=</span><span class="s">"/**"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"com.scorpios.atcrowdfunding.web.AuthInterceptor"</span><span class="nt">&gt;&lt;/bean&gt;</span>
    <span class="nt">&lt;/mvc:interceptor&gt;</span>
<span class="nt">&lt;/mvc:interceptors&gt;</span>
</code></pre></div></div>

<p><strong>（2）拦截器（Interceptor）：</strong> 它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。</p>

<h4 id="三代码">三、代码</h4>

<p>下面在一个项目中我们使用既有多个过滤器，又有多个拦截器，并观察它们的执行顺序：</p>

<h5 id="1第一个过滤器">（1）第一个过滤器：</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestFilter1</span> <span class="kd">implements</span> <span class="nc">Filter</span> <span class="o">{</span>  

		<span class="nd">@Override</span>

  	    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>  
        <span class="c1">//在DispatcherServlet之前执行  </span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"############TestFilter1 doFilterInternal executed############"</span><span class="o">);</span>  
        <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>  
        <span class="c1">//在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后  </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"############TestFilter1 doFilter after############"</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
</code></pre></div></div>

<h5 id="2第二个过滤器">（2）第二个过滤器：</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestFilter2</span> <span class="kd">implements</span> <span class="nc">Filter</span> <span class="o">{</span>  

	<span class="nd">@Override</span>
	<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>  
	    <span class="c1">//在DispatcherServlet之前执行  </span>
	    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"############TestFilter2 doFilterInternal executed############"</span><span class="o">);</span>  
	    <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>  
	    <span class="c1">//在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后</span>
	    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"############TestFilter2 doFilter after############"</span><span class="o">);</span>  
	<span class="o">}</span>  

<span class="o">}</span>
</code></pre></div></div>

<h5 id="3在webxml中注册这两个过滤器">（3）在web.xml中注册这两个过滤器：</h5>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 自定义过滤器：testFilter1 --&gt;</span>   
   <span class="nt">&lt;filter&gt;</span>  
        <span class="nt">&lt;filter-name&gt;</span>testFilter1<span class="nt">&lt;/filter-name&gt;</span>  
        <span class="nt">&lt;filter-class&gt;</span>com.scorpios.filter.TestFilter1<span class="nt">&lt;/filter-class&gt;</span>  
    <span class="nt">&lt;/filter&gt;</span>  
    <span class="nt">&lt;filter-mapping&gt;</span>  
        <span class="nt">&lt;filter-name&gt;</span>testFilter1<span class="nt">&lt;/filter-name&gt;</span>  
        <span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>  
    <span class="nt">&lt;/filter-mapping&gt;</span>  
    <span class="c">&lt;!-- 自定义过滤器：testFilter2 --&gt;</span>   
   <span class="nt">&lt;filter&gt;</span>  
        <span class="nt">&lt;filter-name&gt;</span>testFilter2<span class="nt">&lt;/filter-name&gt;</span>  
        <span class="nt">&lt;filter-class&gt;</span>com.scorpios.filter.TestFilter2<span class="nt">&lt;/filter-class&gt;</span>  
    <span class="nt">&lt;/filter&gt;</span>  
    <span class="nt">&lt;filter-mapping&gt;</span>  
        <span class="nt">&lt;filter-name&gt;</span>testFilter2<span class="nt">&lt;/filter-name&gt;</span>  
        <span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>  
    <span class="nt">&lt;/filter-mapping&gt;</span>  
</code></pre></div></div>

<p>再定义两个拦截器：</p>

<h5 id="4第一个拦截器">（4）第一个拦截器：</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaseInterceptor</span> <span class="kd">implements</span> <span class="nc">HandlerInterceptor</span><span class="o">{</span>  


    <span class="cm">/**
     * 在DispatcherServlet之前执行
     * */</span>  
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">arg0</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">arg1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">arg2</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"************BaseInterceptor preHandle executed**********"</span><span class="o">);</span>  
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>  
    <span class="o">}</span>  

    <span class="cm">/**
     * 在controller执行之后的DispatcherServlet之后执行
     * */</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">arg0</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">arg1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">arg2</span><span class="o">,</span> <span class="nc">ModelAndView</span> <span class="n">arg3</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"************BaseInterceptor postHandle executed**********"</span><span class="o">);</span>  
    <span class="o">}</span>  

    <span class="cm">/**
     * 在页面渲染完成返回给客户端之前执行
     * */</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">arg0</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">arg1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">arg2</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">arg3</span><span class="o">)</span>  
            <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"************BaseInterceptor afterCompletion executed**********"</span><span class="o">);</span>  
    <span class="o">}</span>  

<span class="o">}</span>  
</code></pre></div></div>

<h5 id="5第二个拦截器">（5）第二个拦截器：</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestInterceptor</span> <span class="kd">implements</span> <span class="nc">HandlerInterceptor</span> <span class="o">{</span>  

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">arg0</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">arg1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">arg2</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"************TestInterceptor preHandle executed**********"</span><span class="o">);</span>  
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>  
    <span class="o">}</span>  

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">arg0</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">arg1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">arg2</span><span class="o">,</span> <span class="nc">ModelAndView</span> <span class="n">arg3</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"************TestInterceptor postHandle executed**********"</span><span class="o">);</span>  
    <span class="o">}</span>  

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">arg0</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">arg1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">arg2</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">arg3</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"************TestInterceptor afterCompletion executed**********"</span><span class="o">);</span>  
    <span class="o">}</span>  

<span class="o">}</span>  
</code></pre></div></div>

<h5 id="6在springmvc的配置文件中加上拦截器的配置">（6）、在SpringMVC的配置文件中，加上拦截器的配置：</h5>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 拦截器 --&gt;</span>  
<span class="nt">&lt;mvc:interceptors&gt;</span>  
    <span class="c">&lt;!-- 对所有请求都拦截，公共拦截器可以有多个 --&gt;</span>  
    <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">"baseInterceptor"</span> <span class="na">class=</span><span class="s">"com.scorpios.interceptor.BaseInterceptor"</span> <span class="nt">/&gt;</span>  

	<span class="nt">&lt;mvc:interceptor&gt;</span>
	    <span class="c">&lt;!-- 对/test.html进行拦截 --&gt;</span>       
        <span class="nt">&lt;mvc:mapping</span> <span class="na">path=</span><span class="s">"/test.html"</span><span class="nt">/&gt;</span>  
        <span class="c">&lt;!-- 特定请求的拦截器只能有一个 --&gt;</span>  
        <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"com.scorpios.interceptor.TestInterceptor"</span> <span class="nt">/&gt;</span>  
    <span class="nt">&lt;/mvc:interceptor&gt;</span>  
<span class="nt">&lt;/mvc:interceptors&gt;</span>  
</code></pre></div></div>

<h5 id="7定义一个controller控制器">（7）、定义一个Controller控制器：</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.scorpios.controller</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Controller</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RequestMapping</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">org.springframework.web.servlet.ModelAndView</span><span class="o">;</span>  

<span class="nd">@Controller</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="o">{</span>  
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/test"</span><span class="o">)</span>  
    <span class="kd">public</span> <span class="nc">ModelAndView</span> <span class="nf">handleRequest</span><span class="o">(){</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---------TestController executed--------"</span><span class="o">);</span>  
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ModelAndView</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div>

<h5 id="8测试结果">（8）、测试结果：</h5>

<p><img src="/assets/images/mianshiti/0706/20180603132319702.png" alt="1" /></p>

<p>启动测试项目，地址如下：http://www.localhost:8080/demo，可以看到控制台中输出如下：</p>

<p>这就说明了过滤器的运行是依赖于servlet容器，跟springmvc等框架并没有关系。并且，多个过滤器的执行顺序跟xml文件中定义的先后关系有关。</p>

<p>接着清空控制台，并访问：http://www.localhost:8080/demo/test，再次看控制台的输出：</p>

<p><img src="/assets/images/mianshiti/0706/20180603132536413.png" alt="2" /></p>

<p>从这个控制台打印输出，就可以很清晰地看到有多个拦截器和过滤器存在时的整个执行顺序了。当然，对于多个拦截器它们之间的执行顺序跟在SpringMVC的配置文件中定义的先后顺序有关。</p>

<p>四、总结
对于上述过滤器和拦截器的测试，可以得到如下结论：
（1）、Filter需要在web.xml中配置，依赖于Servlet；
（2）、Interceptor需要在SpringMVC中配置，依赖于框架；
（3）、Filter的执行顺序在Interceptor之前，具体的流程见下图；</p>

<p><img src="/assets/images/mianshiti/0706/20180603133007923.png" alt="3" /></p>

<p>（4）、两者的本质区别：拦截器（Interceptor）是基于Java的反射机制，而过滤器（Filter）是基于函数回调。从灵活性上说拦截器功能更强大些，Filter能做的事情，都能做，而且可以在请求前，请求后执行，比较灵活。Filter主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验（比较泛的，比如登录不登录之类），太细的话，还是建议用interceptor。不过还是根据不同情况选择合适的。</p>
</div><p><a href="/mianshi/spring/0706/02">Read more</a></p></div><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Jul 06, 2020</span>
            </li><li><i class="far fa-eye"></i> <span class="js-pageview" data-page-key="mianshi-2020-07-06-02">0</span> views</li></ul></div><meta itemprop="author" content="java牛牛"/><meta itemprop="datePublished" content="2020-07-06T00:00:00+08:00">
    <meta itemprop="keywords" content="面试题"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><a href="/mianshi/SpringBoot/0706"><h2 itemprop="headline" class="item__header">SpringBoot面试题（2）</h2></a></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h4 id="1什么是springboot">1、什么是SpringBoot？</h4>

<p>spring的开源子项目，简化spring开发难度，是spring的一站式解决方案</p>

<p>springboot解决的问题</p>

<p>1、使编码变得简单
2、使配置变得简单
3、使部署变得简单
4、使监控变得简单</p>

<h4 id="2springboot有什么特点">2、SpringBoot有什么特点？</h4>

<ul>
  <li>提供了starter POM，能够非常方便的进行包管理</li>
  <li>项目快速搭建。springboot帮助开发者快速搭建spring框架，可无需配置的自动整合第三方框架</li>
  <li>可以完全不使用xml配置，只需要自动配置和Java config</li>
  <li>对主流框架无配置集成</li>
</ul>

<h4 id="3springboot的核心注解是哪个它主要由哪几个注解组成的">3、SpringBoot的核心注解是哪个？它主要由哪几个注解组成的</h4>

<p>@SpringBootApplication下的三个注解</p>

<ul>
  <li>@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan</li>
</ul>

<h4 id="4springboot自动配置的原理是什么">4、SpringBoot自动配置的原理是什么？</h4>

<p>详细看一看注解 @EnableAutoConfiguration 源码</p>

<h4 id="5什么是yaml">5、什么是YAML？</h4>

<p>YAML是一种__数据序列化语言__，通常用于配置文件，例如application.yml。</p>

<h4 id="6yaml优势在哪里">6、YAML优势在哪里？</h4>

<p>（1）配置有序</p>

<p>（2）树形结构，清晰明了</p>

<p>（3）支持数组，数组中的元素可以是基本数据和对象</p>

<h4 id="7springboot是否可以使用xml配置-">7、SpringBoot是否可以使用XML配置 ?</h4>

<p>Spring Boot推荐使用Java配置，但是同样也可以使用XML配置。</p>

<h4 id="8spring-boot-核心配置文件是什么bootstrappeoperties和applicationproperties有何区别">8、spring boot 核心配置文件是什么？bootstrap.peoperties和application.properties有何区别</h4>

<p>spring boot核心配置文件是application.properties或者application.yml</p>

<ul>
  <li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；</li>
  <li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</li>
</ul>

<h4 id="9什么是spring-profiles">9、什么是Spring Profiles？</h4>

<p>Spring Profiles允许用户根据配置文件（dev，test，prod等）来注册bean。因此，当应用程序在开发中运行时，只有某些bean可以加载，而在PRODUCTION中，某些其他bean可以加载。假设我们的要求是Swagger文档仅适用于QA环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot使得使用配置文件非常简单</p>

<p>在实际应用中，给中配置对于不同的环境</p>

<h4 id="10如何在自定义端口上运行spring-boot应用程序">10、如何在自定义端口上运行Spring Boot应用程序</h4>

<p>在配置文件中配置 port 为自定义端口</p>

<h4 id="11如何实现spring-boot应用程序的安全性">11、如何实现Spring Boot应用程序的安全性？</h4>

<p>spring可集合 spring security 或者shiro 作为安全组件，集成到程序中</p>

<p>使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码，配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。</p>

<h4 id="12比较一下spring-security和shiro各自的优缺点">12、比较一下Spring Security和Shiro各自的优缺点</h4>

<p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p>

<ol>
  <li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li>
  <li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li>
  <li>Spring Security 功能强大；Shiro 功能简单</li>
</ol>

<h4 id="13spring-boot中如何解决跨域问题-">13、Spring Boot中如何解决跨域问题 ?</h4>

<p>跨域可以在前端通过JSONP来解决，但是JSONP只可以发送GET请求，无法发送其他类型的请求，在 RESTful风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过（CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非Spring Boot特有的，在传统的SSM框架中，就可以通过 CORS来解决跨域问题，只不过之前我们是在XML文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CorsConfig</span> <span class="kd">implements</span> <span class="nc">WebMvcConfigurer</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addCorsMappings</span><span class="o">(</span><span class="nc">CorsRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">addMapping</span><span class="o">(</span><span class="s">"/**"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">allowedOrigins</span><span class="o">(</span><span class="s">"*"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">allowCredentials</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
                <span class="o">.</span><span class="na">allowedMethods</span><span class="o">(</span><span class="s">"GET"</span><span class="o">,</span> <span class="s">"POST"</span><span class="o">,</span> <span class="s">"PUT"</span><span class="o">,</span> <span class="s">"DELETE"</span><span class="o">,</span> <span class="s">"OPTIONS"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">maxAge</span><span class="o">(</span><span class="mi">3600</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>项目中前后端分离部署，所以需要解决跨域的问题。我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CorsConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">CorsFilter</span> <span class="nf">corsFilter</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">CorsConfiguration</span> <span class="n">corsConfiguration</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CorsConfiguration</span><span class="o">();</span>
        <span class="n">corsConfiguration</span><span class="o">.</span><span class="na">addAllowedOrigin</span><span class="o">(</span><span class="s">"*"</span><span class="o">);</span>
        <span class="n">corsConfiguration</span><span class="o">.</span><span class="na">addAllowedHeader</span><span class="o">(</span><span class="s">"*"</span><span class="o">);</span>
        <span class="n">corsConfiguration</span><span class="o">.</span><span class="na">addAllowedMethod</span><span class="o">(</span><span class="s">"*"</span><span class="o">);</span>
        <span class="n">corsConfiguration</span><span class="o">.</span><span class="na">setAllowCredentials</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="nc">UrlBasedCorsConfigurationSource</span> <span class="n">urlBasedCorsConfigurationSource</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UrlBasedCorsConfigurationSource</span><span class="o">();</span>
        <span class="n">urlBasedCorsConfigurationSource</span><span class="o">.</span><span class="na">registerCorsConfiguration</span><span class="o">(</span><span class="s">"/**"</span><span class="o">,</span> <span class="n">corsConfiguration</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">CorsFilter</span><span class="o">(</span><span class="n">urlBasedCorsConfigurationSource</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="14什么是csrf攻击">14、什么是CSRF攻击？</h4>

<p>跨站请求伪</p>

<h4 id="15spring-boot中的监视器是什么">15、Spring Boot中的监视器是什么？</h4>

<p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p>

<h4 id="16如何在spring-boot中禁用actuator端点安全性">16、如何在Spring Boot中禁用Actuator端点安全性？</h4>

<p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。<strong>安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的</strong>。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p>

<h4 id="17我们如何监视所有spring-boot微服务">17、我们如何监视所有Spring Boot微服务？</h4>

<p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。<strong>想象一下涉及 50 个应用程序的微服务</strong>，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量</p>

<h4 id="18什么是websockets">18、什么是WebSockets？</h4>

<p>WebSocket是一种__计算机通信协议__，通过单个TCP连接提供全双工通信信道。</p>

<p>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p>

<p>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p>

<p>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信。</p>

<p>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多</p>

<h4 id="19什么是spring-data-">19、什么是Spring Data ?</h4>

<p>Spring Data是Spring的一个子项目，用于__简化数据库访问__，支持NoSQL和关系数据存储，其主要目标是使数据库的访问变得方便快捷。Spring Data具有如下特点：</p>

<p>SpringData项目支持NoSQL存储：</p>

<ol>
  <li>MongoDB （文档数据库）</li>
  <li>Neo4j（图形数据库）</li>
  <li>Redis（键/值存储）</li>
  <li>Hbase（列族数据库）</li>
</ol>

<p>SpringData项目所支持的关系数据存储技术：</p>

<ol>
  <li>JDBC</li>
  <li>JPA</li>
</ol>

<p>Spring Data Jpa致力于减少数据访问层(DAO)的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给Spring Data JPA来帮你完成！Spring Data JPA通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p>

<h4 id="20什么是spring-batch">20、什么是Spring Batch？</h4>

<p>Spring Boot Batch__提供可重用的函数__，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，<strong>通过优化和分区技术，可以实现极高批量和高性能批处理作业</strong>。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p>

<h4 id="21什么是freemarker模板">21、什么是FreeMarker模板？</h4>

<p>FreeMarker是一个__基于Java的模板引擎__，最初专注于使用MVC软件架构进行动态网页生成。使用 Freemarker的__主要优点是表示层和业务层的完全分离__。程序员可以处理应用程序代码，而设计人员可以处理html页面设计。最后使用freemarker可以将这些结合起来，给出最终的输出页面。</p>

<h4 id="22如何集成spring-boot和activemq">22、如何集成Spring Boot和ActiveMQ？</h4>

<p>maven配置 ActiveMQ</p>

<h4 id="23什么是apache-kafka">23、什么是Apache Kafka？</h4>

<p>Apache Kafka是一个__分布式发布 - 订阅消息系统__。它是一个__可扩展的，容错的发布 - 订阅消息系统__，它使我们能够构建分布式应用程序。这是一个Apache顶级项目。Kafka适合离线和在线消息消费。</p>

<h4 id="24什么是-swagger你用spring-boot实现了它吗">24、什么是 Swagger？你用Spring Boot实现了它吗？</h4>

<p>Swagger广泛用于__可视化API__，<strong>使用Swagger UI为前端开发人员提供在线沙箱</strong>。<strong>Swagger是用于生成 RESTful Web服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新</strong>。当通过Swagger正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p>

<h4 id="25前后端分离如何维护接口文档-">25、前后端分离，如何维护接口文档 ?</h4>

<p>统一的接口规范，手写</p>

<p>使用第三方框架，自动或者半自动编辑</p>

<h4 id="26如何重新加载spring-boot上的更改而无需重新启动服务项目如何热部署">26、如何重新加载Spring Boot上的更改，而无需重新启动服务，项目如何热部署</h4>

<p>spring-detools</p>

<h4 id="27spring-boot-中的-starter到底是什么">27、Spring Boot 中的 starter到底是什么</h4>

<p>首先，这个Starter并非什么新的技术点，基本上还是基于Spring已有功能来实现的。首先它__提供了一个自动化配置类，一般命名为XXXAutoConfiguration __，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义Starter。</p>

<h4 id="28spring-boot-starter-parent有什么用">28、spring-boot-starter-parent有什么用？</h4>

<p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p>

<p>1、定义了 Java 编译版本为 1.8 。
2、使用 UTF-8 格式编码。
3、继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所4、以我们在写依赖时才不需要写版本号。
5、执行打包操作的配置。
6、自动化的资源过滤。
7、自动化的插件配置。
8、针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配 置文件，例如 application-dev.properties 和 application-dev.yml。</p>

<h4 id="29spring-boot打成的jar和普通的jar有什么区别">29、Spring Boot打成的jar和普通的jar有什么区别</h4>

<p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，<strong>即使依赖了也无法使用其中的类</strong>。</p>

<p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。<strong>如果非要引用，可以在 pom.xml 文件中增加配置</strong>，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p>

<h4 id="30运行spring-boot有哪几种方式">30、运行Spring Boot有哪几种方式？</h4>

<p>1）直接运行main文件</p>

<p>2）打包用命令或放到容器中运行</p>

<p>3）用Maven/Gradle插件运行</p>

<h4 id="31spring-boot需要独立的容器运行吗">31、Spring Boot需要独立的容器运行吗？</h4>

<p>可以不需要，因为Spring Boot有内嵌服务器tomcat</p>

<h4 id="32开启spring-boot特性有哪几种方式">32、开启Spring Boot特性有哪几种方式？</h4>

<p>1）继承spring-boot-starter-parent项目</p>

<p>2）导入spring-boot-dependencies项目依赖</p>

<h4 id="33如何使用spring-boot实现异常处理">33、如何使用Spring Boot实现异常处理？</h4>

<p>Spring提供了一种使用__ControllerAdvice__处理异常的非常有用的方法。我们通过实现一个 ControlerAdvice类，来处理控制器类抛出的所有异常。</p>

<h4 id="34如何使用-spring-boot-实现分页和排序">34、如何使用 Spring Boot 实现分页和排序</h4>

<p>spirng-data-jpa，或者使用第三方插件，自己实现</p>

<h4 id="35微服务中如何实现session共享">35、微服务中如何实现session共享</h4>

<p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的session被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享session，常见的方案就是Spring Session + Redis来实现session共享。将所有微服务的session统一保存在Redis 上，当各个微服务对session有相关的读写操作时，都去操作Redis上的session 。这样就实现了session 共享，Spring Session基于Spring中的代理过滤器实现，使得session的同步操作对开发人员而言是透明的，非常简便。</p>

<h4 id="36spring-boot中如何实现定时任务">36、Spring Boot中如何实现定时任务</h4>

<p>定时任务也是一个常见的需求，Spring Boot中对于定时任务的支持主要还是来自Spring框架。在Spring Boot中使用定时任务主要有两种不同的方式，<strong>一个就是使用Spring中的@Scheduled注解</strong>，<strong>另一个则是使用第三方框架Quartz</strong>。</p>

<h4 id="37springboot的-actuator-是做什么的">37、SpringBoot的 Actuator 是做什么的？</h4>

<p>本质上，Actuator 通过启用 production-ready 功能使得 SpringBoot 应用程序变得更有生命力。这些功能允许我们对生产环境中的应用程序进行监视和管理。</p>

<p>集成 SpringBoot Actuator 到项目中非常简单。我们需要做的只是将 <em>spring-boot-starter-actuator</em> starter 引入到 POM.xml 文件当中：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 &lt;dependency&gt;
2     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
3     &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
4 &lt;/dependency&gt;
</code></pre></div></div>

<p>SpringBoot Actuaor 可以使用 HTTP 或者 JMX endpoints来浏览操作信息。大多数应用程序都是用 HTTP，作为 endpoint 的标识以及使用 <em>/actuator</em> 前缀作为 URL路径。</p>

<p>这里有一些常用的内置 endpoints Actuator：</p>

<ul>
  <li><em>auditevents</em>：查看 audit 事件信息</li>
  <li><em>env</em>：查看 环境变量</li>
  <li><em>health</em>：查看应用程序健康信息</li>
  <li><em>httptrace</em>：展示 HTTP 路径信息</li>
  <li><em>info</em>：展示 <em>arbitrary</em> 应用信息</li>
  <li><em>metrics</em>：展示 metrics 信息</li>
  <li><em>loggers</em>：显示并修改应用程序中日志器的配置</li>
  <li><em>mappings</em>：展示所有 <em>@RequestMapping</em> 路径信息</li>
  <li><em>scheduledtasks</em>：展示应用程序中的定时任务信息</li>
  <li><em>threaddump</em>：执行 <em>Thread Dump</em></li>
</ul>

<h4 id="38怎么编写一个集成测试">38、怎么编写一个集成测试？</h4>

<p>当我们使用 Spring 应用去跑一个集成测试时，我们需要一个 <em>ApplicationContext</em>。</p>

<p>为了使我们开发更简单，SpringBoot 为测试提供一个注解 – <em>@SpringBootTest</em>。这个注释由其 classes 属性指示的配置类创建一个 <em>ApplicationContext</em>。</p>

<p><strong>如果没有配置 classes 属性，SpringBoot 将会搜索主配置类</strong>。搜索会从包含测试类的包开始直到找到一个使用 <em>@SpringBootApplication</em> 或者 <em>@SpringBootConfiguration</em> 的类为止。</p>

<p>注意如果使用 JUnit4，我们必须使用 <em>@RunWith(SpringRunner.class)</em> 来修饰这个测试类。</p>

<h4 id="38springboot-支持松绑定代表什么">38、SpringBoot 支持松绑定代表什么</h4>

<p>SpringBoot中的松绑定适用于配置属性的类型安全绑定。使用松绑定，环境属性的键不需要与属性名完全匹配。这样就可以用驼峰式、短横线式、蛇形式或者下划线分割来命名。</p>

<p>例如，在一个有 <em>@ConfigurationProperties</em> 声明的 bean 类中带有一个名为 <em>myProp</em> 的属性，它可以绑定到以下任何一个参数中，<em>myProp</em>、 <em>my-prop</em>、<em>my_prop</em> 或者 <em>MY_PROP</em>。</p>

<h4 id="39怎么将-springboot-web-应用程序部署为-jar-或-war-文件">39、怎么将 SpringBoot web 应用程序部署为 JAR 或 WAR 文件？</h4>

<p>通常，我们将 web 应用程序打包成 WAR 文件，然后将它部署到另外的服务器上。这样做使得我们能够在相同的服务器上处理多个项目。当 CPU 和内存有限的情况下，这是一种最好的方法来节省资源。</p>

<p>然而，事情发生了转变。现在的计算机硬件相比起来已经很便宜了，并且现在的注意力大多转移到服务器配置上。部署中对服务器配置的一个细小的失误都会导致无可预料的灾难发生。</p>

<p>Spring 通过提供插件来解决这个问题，也就是 <em>spring-boot-maven-plugin</em> 来打包 web 应用程序到一个额外的 JAR 文件当中。为了引入这个插件，只需要在 <em>pom.xml</em>中添加一个 <em>plugin</em> 属性：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;
</code></pre></div></div>

<p>有了这个插件，我们会在执行 <em>package</em> 步骤后得到一个 JAR 包。这个 JAR 包包含所需的所有依赖以及一个嵌入的服务器。因此，我们不再需要担心去配置一个额外的服务器了。</p>

<p>我们能够通过运行一个普通的 JAR 包来启动应用程序。</p>

<p>注意一点，为了打包成 JAR 文件，<em>pom.xml</em> 中的 <em>packgaing</em> 属性必须定义为 <em>jar</em>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;packaging&gt;jar&lt;/packaging&gt;
</code></pre></div></div>

<p>如果我们不定义这个元素，它的默认值也为 <em>jar</em>。</p>

<p>如果我们想构建一个 WAR 文件，将 <em>packaging</em> 元素修改为 <em>war</em>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;packaging&gt;war&lt;/packaging&gt;
</code></pre></div></div>

<p>并且将容器依赖从打包文件中移除：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre></div></div>

<p>执行 Maven 的 <em>package</em> 步骤之后，我们得到一个可部署的 WAR 文件</p>

<h4 id="40当-bean-存在的时候怎么置后执行自动配置">40、当 bean 存在的时候怎么置后执行自动配置？</h4>

<p>为了当 bean 已存在的时候通知自动配置类置后执行，我们可以使用 <em>@ConditionalOnMissingBean</em> 注解。这个注解中最值得注意的属性是：</p>

<ul>
  <li>value：被检查的 beans 的类型</li>
  <li>name：被检查的 beans 的名字</li>
</ul>

<p>当将 <em>@Bean</em> 修饰到方法时，目标类型默认为方法的返回类型：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="nd">@Configuration</span>
<span class="mi">2</span> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomConfiguration</span> <span class="o">{</span>
<span class="mi">3</span>     <span class="nd">@Bean</span>
<span class="mi">4</span>     <span class="nd">@ConditionalOnMissingBean</span>
<span class="mi">5</span>     <span class="kd">public</span> <span class="nc">CustomService</span> <span class="nf">service</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="mi">6</span> <span class="o">}</span>
</code></pre></div></div>
</div><p><a href="/mianshi/SpringBoot/0706">Read more</a></p></div><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Jul 06, 2020</span>
            </li><li><i class="far fa-eye"></i> <span class="js-pageview" data-page-key="mianshi-2020-07-06-010">0</span> views</li></ul></div><meta itemprop="author" content="java牛牛"/><meta itemprop="datePublished" content="2020-07-06T00:00:00+08:00">
    <meta itemprop="keywords" content="面试题"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><a href="/mianshi/spring/0706/06"><h2 itemprop="headline" class="item__header">Spring经典面试题和答案</h2></a></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p>1、什么是spring?</p>

</div><p><a href="/mianshi/spring/0706/06">Read more</a></p></div><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Jul 06, 2020</span>
            </li><li><i class="far fa-eye"></i> <span class="js-pageview" data-page-key="mianshi-2020-07-06-06">0</span> views</li></ul></div><meta itemprop="author" content="java牛牛"/><meta itemprop="datePublished" content="2020-07-06T00:00:00+08:00">
    <meta itemprop="keywords" content="面试题"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><a href="/mianshi/Redis/0705/04"><h2 itemprop="headline" class="item__header">降低Redis内存占用</h2></a></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><p><strong>1、降低redis内存占用的优点</strong></p>

<p>　　1、有助于减少创建快照和加载快照所用的时间</p>

<p>　　2、提升载入AOF文件和重写AOF文件时的效率</p>

<p>　　3、缩短从服务器进行同步所需的时间</p>

<p>　　4、无需添加额外的硬件就可以让redis存贮更多的数据</p>

<p><strong>2、短结构</strong></p>

<p>　　Redis为列表、集合、散列、有序集合提供了一组配置选项，这些选项可以让redis以更节约的方式存储较短的结构。</p>

<p>　　<strong>2.1、ziplist压缩列表（列表、散列、有续集和）</strong></p>

<p>　　通常情况下使用的存储方式</p>

<p><img src="/assets/images/mianshiti/0705/1734531-20190723145231193-1166923194.jpg" alt="img" /></p>

<p>　　</p>

<p>　　当列表、散列、有序集合的长度较短或者体积较小的时候，redis将会采用一种名为ziplist的紧凑存储方式来存储这些结构。</p>

<p>　　ziplist是列表、散列、有序集合这三种不同类型的对象的一种非结构化表示，它会以序列化的方式存储数据，这些序列化的数据每次被读取的时候都需要进行解码，每次写入的时候也要进行编码。</p>

<p><strong>双向列表与压缩列表的区别：</strong></p>

<p>　  为了了解压缩列表比其他数据结构更加节约内存，我们以列表结构为例进行深入研究。</p>

<p>　　<strong>典型的双向列表</strong></p>

<p>　　　　1、在典型双向列表里面，每个值都都会有一个节点表示。每个节点都会带有指向链表前一个节点和后一个节点的指针，以及一个指向节点包含的字符串值的指针。</p>

<p>　　　　2、每个节点包含的字符串值都会分为三部分进行存储。包括字符串长度、字符串值中剩余可用字节数量、以空字符结尾的字符串本身。</p>

<p>　　<strong>例子：</strong></p>

<p>　　假若一个某个节点存储了’abc’字符串，在32位的平台下保守估计需要21个字节的额外开销（三个指针+两个int+空字符即：3<em>4+2</em>4+1=21）</p>

<p>　　由例子可知存储一个3字节字符串就需要付出至少21个字节的额外开销。</p>

<p>　　<strong>ziplist</strong></p>

<p>　　　　压缩列表是由节点组成的序列，每个节点包含两个长度和一个字符串。第一个长度记录前一个节点的长度（用于对压缩列表从后向前遍历）；第二个长度是记录本当前点的长度；被存储的字符串。</p>

<p>　　<strong>例子：</strong></p>

<p>　　存储字符串’abc’，两个长度都可以用1字节来存储，因此所带来的额外开销为2字节（两个长度即1+1=2）</p>

<p>　　<strong>结论：</strong></p>

<p>　　压缩列表是通过避免存储额外的指针和元数据，从而达到降低额外的开销。</p>

<p>　　<strong>配置：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 #list2 list-max-ziplist-entries 51
2 #表示允许包含的最大元素数量
3 list-max-ziplist-value 64    #表示压缩节点允许存储的最大体积
4 #hash                  #当超过任一限制后，将不会使用ziplist方式进行存储
5 hash-max-ziplist-entries 512
6 hash-max-ziplist-value 64
7 #zset
8 zset-max-ziplist-entries 128
9 zset-max-ziplist-value 64
</code></pre></div></div>

<p>　　<strong>测试list:</strong></p>

<p>　　<strong>1、建立test.php文件</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 #test.php
2 &lt;?php
3     $redis=new Redis();
4     $redis-&gt;connect('192.168.95.11','6379');
5         for ($i=0; $i&lt;512  ; $i++) 
6     { 
7         $redis-&gt;lpush('test-list',$i.'-test-list');  #往test-list推入512条数据
8     }
9 ?&gt;    
</code></pre></div></div>

<p><img src="/Users/minp/GitHub/javaniuniu.github.io/_posts/docs-mianshi/1734531-20190723145957416-1822584668.png" alt="img" /></p>

<p>　　　　此时的test-list中含有512条数据，没有超除配置文件中的限制</p>

<p>　　<strong>2、往test-list中再推入一条数据</strong></p>

<p><img src="/assets/images/mianshiti/0705/1734531-20190723150126455-831466601.png" alt="img" /></p>

<p>　　　　此时test-list含有513条数据，大于配置文件中限制的512条，索引将放弃ziplist存储方式，采用其原来的linkedlist存储方式,散列与有序集合同理。</p>

<p>　　　　<strong>2.2、intset整数集合（集合）</strong></p>

<p>　　　　前提条件，集合中包含的所有member都可以被解析为十进制整数。</p>

<p>　　　　以有序数组的方式存储集合不仅可以降低内存消耗，还可以提升集合操作的执行速度。</p>

<p>　　　　<strong>配置：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 set-max-intset-entries  512   #限制集合中member个数，超出则不采取i那个tset存储
</code></pre></div></div>

<p>　　　<strong>测试：</strong></p>

<p>　　　　建立test.php文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 #test.php
 2 &lt;?php
 3     $redis=new Redis();
 4     $redis-&gt;connect('192.168.95.11','6379');
 5         for ($i=0; $i&lt;512  ; $i++) 
 6     { 
 7         $redis-&gt;sadd('test-set',$i);   #给集合test-set插入512个member
 8     } 
 9 ?&gt;           
10  
</code></pre></div></div>

<p>　　　<strong>2.3、性能问题</strong></p>

<p>　　　　不管列表、散列、有序集合、集合，当超出限制的条件后，就会转换为更为典型的底层结构类型。因为随着紧凑结构的体积不断变大，操作这些结构的速度将会变得越来越慢。</p>

<p>　　　　<strong>测试：</strong></p>

<p>　　　　#将采用list进行代表性测试</p>

<p>　　　　<strong>测试思路：</strong></p>

<p>　　　　　　<strong>1、在默认配置下往test-list推入50000条数据，查看所需时间；接着在使用rpoplpush将test-list数据全部推入到新列表list-new中，查看所需时间</strong></p>

<p>　　　　　　<strong>2、修改配置，list-max-ziplist-entries 100000，再执行上面的同样操作</strong></p>

<p>　　　　　　<strong>3、对比时间，得出结论</strong></p>

<p>　　　　　　　　<strong>默认配置下测试：</strong></p>

<p>　　　　　　　　<strong>1、插入数据，查看时间</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 #test1.php 
 2 &lt;?php 
 3     header("content-type: text/html;charset=utf8;"); 
 4     $redis=new Redis(); 
 5     $redis-&gt;connect('192.168.95.11','6379'); 
 6     $start=time(); 
 7         for ($i=0; $i&lt;50000  ; $i++) 
 8     { 
 9         $redis-&gt;lpush('test-list',$i.'-aaaassssssddddddkkk');
10     }
11     $end=time();
12 echo "插入耗时为：".($end-$start).'s';
13 ?&gt;                
</code></pre></div></div>

<p><img src="/assets/images/mianshiti/0705/1734531-20190723150824482-2109961153.png" alt="img" /></p>

<p>　　　　　　结果耗时4秒</p>

<p>　　　　　　　　<strong>2、执行相应命令，查看耗时</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 #test2.php 
 2 &lt;?php 
 3     header("content-type: text/html;charset=utf8;"); 
 4     $redis=new Redis(); 
 5     $redis-&gt;connect('192.168.95.11','6379'); 
 6     $start=time(); 
 7     $num=0;  
 8     while($redis-&gt;rpoplpush('test-list','test-new')) 
 9     {
10         $num+=1;
11     }
12     echo '执行次数为：'.$num."&lt;br/&gt;";
13 $end=time();
14 echo "耗时为：".($end-$start).'s';
15 ?&gt;
</code></pre></div></div>

<p>　　　　　　　　<strong>更改配置文件下测试</strong>　　</p>

<p>　　　　　　　　　　<strong>1、先修改配置文件</strong></p>

<p>　　　　　　　　　　list-max-ziplist-entries 100000 #将这个值修改大一点，可以更好的凸显对性能的影响</p>

<p>　　　　　　　　　　list-max-ziplist-value 64  #此值可不做修改</p>

<p>　　　　　　　　　　<strong>2、插入数据</strong></p>

<p>　　　　　　　　　　执行test1.php</p>

<p>　　　　　　　　　　结果为：耗时12s</p>

<p><img src="/assets/images/mianshiti/0705/1734531-20190723151326952-1965499675.png" alt="img" /></p>

<p>　　　　　　　　　　<strong>3、执行相应命令，查看耗时</strong></p>

<p>　　　　　　　　　　执行test2.php</p>

<p>　　　　　　　　　　结果为：执行次数：50000，耗时12s</p>

<p>　　　　　　<strong>结论：</strong></p>

<p>　　　　　　<strong>在本机中执行测试50000条数据就相差8s，若在高并发下，长压缩列表和大整数集合将起不到任何的优化，反而使得性能降低。</strong></p>

<p><strong>3、片结构</strong></p>

<p>　　分片的本质就是基于简单的规则将数据划分为更小的部分，然后根据数据所属的部分来决定将数据发送到哪个位置上。很多数据库使用这种技术来扩展存储空间，并提高自己所能处理的负载量。</p>

<p>　　结合前面讲到的，我们不难发现分片结构对于redis的重要意义。因此我们需要在配置文件中关于ziplist以及intset的相关配置做出适当的调整。</p>

<p>　　<strong>3.1、分片式散列</strong></p>

<p>　　#ShardHash.class.php</p>

<p>　　散列分片主要是根据基础键以及散列包含的键计算出分片键ID，然后再与基础键拼接成一个完整的分片键。在执行hset与hget以及大部分hash命令时，都需要先将key（field）通过shardKey方法处理，得到分片键才能够进行下一步操作。</p>

<p>回到顶部</p>

<p>　　<strong>3.2、分片式集合</strong></p>

<p>　　如何构造分片式集合才能够让它更节省内存，性能更加强大呢？主要的思路就是，将集合里面的存储的数据尽量在不改变其原有功能的情况下转换成可以被解析为十进制的数据。根据前面所讲到的，当集合中的所有成员都能够被解析为十进制数据时，将会采用intset存储方式，这不仅能够节省内存，而且还可以提高响应的性能。</p>

<p><strong>4、将信息打包转换成存储字节</strong></p>

<p>　　结合前面所讲的分片技术，采用string分片结构为大量连续的ID用户存储信息。</p>

<p>　　使用定长字符串，为每一个ID分配n个字节进行存储相应的信息。</p>
</div><p><a href="/mianshi/Redis/0705/04">Read more</a></p></div><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Jul 05, 2020</span>
            </li><li><i class="far fa-eye"></i> <span class="js-pageview" data-page-key="mianshi-2020-07-05-04">0</span> views</li></ul></div><meta itemprop="author" content="java牛牛"/><meta itemprop="datePublished" content="2020-07-05T00:00:00+08:00">
    <meta itemprop="keywords" content="面试题"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><a href="/mianshi/Redis/0705/02"><h2 itemprop="headline" class="item__header">单进程单线程的Redis如何能够高并发</h2></a></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h4 id="1基本原理">1、基本原理</h4>

<p>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）</p>

<h5 id="1为什么不采用多进程或多线程处理">（1）为什么不采用多进程或多线程处理？</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>多线程处理可能涉及到锁 
多线程处理会涉及到线程切换而消耗CPU
</code></pre></div></div>

<h5 id="2单线程处理的缺点">（2）单线程处理的缺点？</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善
</code></pre></div></div>

<h4 id="2redis不存在线程安全问题">2、Redis不存在线程安全问题？</h4>

<p>Redis采用了线程封闭的方式，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁</p>

<h4 id="3什么是多路io复用epoll">3、什么是多路I/O复用（Epoll）</h4>

<p>（1） 网络IO都是通过Socket实现，Server在某一个端口持续监听，客户端通过Socket（IP+Port）与服务器建立连接（ServerSocket.accept），成功建立连接之后，就可以使用Socket中封装的InputStream和OutputStream进行IO交互了。针对每个客户端，Server都会创建一个新线程专门用于处理 
（2） 默认情况下，网络IO是阻塞模式，即服务器线程在数据到来之前处于【阻塞】状态，等到数据到达，会自动唤醒服务器线程，着手进行处理。阻塞模式下，一个线程只能处理一个流的IO事件 
（3） 为了提升服务器线程处理效率，有以下三种思路</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>（1）非阻塞【忙轮询】：采用死循环方式轮询每一个流，如果有IO事件就处理，这样可以使得一个线程可以处理多个流，但是效率不高，容易导致CPU空转

（2）Select代理（无差别轮询）：可以观察多个流的IO事件，如果所有流都没有IO事件，则将线程进入阻塞状态，如果有一个或多个发生了IO事件，则唤醒线程去处理。但是还是得遍历所有的流，才能找出哪些流需要处理。如果流个数为N，则时间复杂度为O（N）

（3）Epoll代理：Select代理有一个缺点，线程在被唤醒后轮询所有的Stream，还是存在无效操作。 Epoll会哪个流发生了怎样的I/O事件通知处理线程，因此对这些流的操作都是有意义的，复杂度降低到了O(1)
</code></pre></div></div>

<h4 id="4其它开源软件采用的模型">4、其它开源软件采用的模型</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Nginx：多进程单线程模型 
Memcached：单进程多线程模型
</code></pre></div></div>

<h5 id="redis为什么是单线程的">Redis为什么是单线程的？</h5>

<p><strong>因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽</strong>。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求，参见：<a href="https://link.zhihu.com/?target=https%3A//redis.io/topics/benchmarks">How fast is Redis?</a></p>

<h5 id="如果万一cpu成为你的redis瓶颈了或者你就是不想让服务器其他核闲置那怎么办">如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？</h5>

<p>那也很简单，<strong>你多起几个Redis进程就好了</strong>。Redis是keyvalue数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好。</p>

<h5 id="单线程可以处理高并发请求吗">单线程可以处理高并发请求吗？</h5>

<p>当然可以了，Redis都实现了。</p>

<p>有一点概念需要澄清，并发并不是并行。</p>

<p>（相关概念：并发性I/O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。并行性，意味着服务器能够同时执行几个事情，具有多个计算单元）</p>

<h5 id="redis总体快速的原因">Redis总体快速的原因：</h5>

<p>采用队列模式将并发访问变为串行访问（？）</p>

<p>单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），其他模块仍用了多个线程。</p>

<h4 id="总体来说快速的原因如下">总体来说快速的原因如下：</h4>

<p>1）绝大部分请求是纯粹的内存操作（非常快速）</p>

<p>2）采用单线程,避免了不必要的上下文切换和竞争条件</p>

<p>3）非阻塞IO</p>

<p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</p>

<p>这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。</p>

<ol>
  <li>Redis服务端是个单线程的架构，不同的Client虽然看似可以同时保持连接，但发出去的命令是序列化执行的，这在通常的数据库理论下是最高级别的隔离（serialize）</li>
  <li>用MULTI/EXEC 来把多个命令组装成一次发送，达到原子性</li>
  <li>用WATCH提供的乐观锁功能，在你EXEC的那一刻，如果被WATCH的键发生过改动，则MULTI到EXEC之间的指令全部不执行，不需要rollback</li>
  <li>其他回答中提到的DISCARD指令只是用来撤销EXEC之前被暂存的指令，并不是回滚</li>
</ol>

<p>多线程对同一个Key操作时，Redis服务是根据先到先作的原则，其他排队（可设置为直接丢弃），因为是单线程。</p>

<p>修改默认的超时时间，默认2秒。但是大部份的操作都在30ms以内。</p>

<ol>
  <li>
    <h5 id="使用redis有哪些好处">使用<a href="http://lib.csdn.net/base/redis">Redis</a>有哪些好处？</h5>
  </li>
</ol>

<p>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p>

<p>(2) 支持丰富数据类型，支持string，list，set，sorted set，hash</p>

<p>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p>

<p>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>

<ol>
  <li>
    <h5 id="redis相比memcached有哪些优势"><a href="http://lib.csdn.net/base/redis">Redis</a>相比memcached有哪些优势？</h5>
  </li>
</ol>

<p>(1) memcached所有的值均是简单的字符串，<a href="http://lib.csdn.net/base/redis">redis</a>作为其替代者，支持更为丰富的数据类型</p>

<p>(2) redis的速度比memcached快很多</p>

<p>(3) redis可以持久化其数据</p>

<p>(4)Redis支持数据的备份，即master-slave模式的数据备份。</p>

<p>(5)、使用底层模型不同</p>

<p>它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。</p>

<p>Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>

<p>(6）value大小：redis最大可以达到1GB，而memcache只有1MB</p>

<ol>
  <li>
    <h5 id="redis常见性能问题和解决方案">redis常见性能问题和解决方案：</h5>
  </li>
</ol>

<p>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</p>

<p>(Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照;AOF文件过大会影响Master重启的恢复速度)</p>

<p>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</p>

<p>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</p>

<p>(4) 尽量避免在压力很大的主库上增加从库</p>

<p>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…</p>

<p>这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p>

<h4 id="redis的一些其他特点">redis的一些其他特点：</h4>

<h5 id="1redis是单进程单线程的">（1）Redis是单进程单线程的</h5>

<p>redis利用队列技术将并发访问变为串行访问，消除了传统<a href="http://lib.csdn.net/base/mysql">数据库</a>串行控制的开销</p>

<h5 id="2读写分离模型">（2）读写分离模型</h5>

<p>通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。
读写分离<a href="http://lib.csdn.net/base/architecture">架构</a>的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离<a href="http://lib.csdn.net/base/architecture">架构</a>并不适合。</p>

<h5 id="3数据分片模型">（3）数据分片模型</h5>

<p>为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。</p>

<p>可以将每个节点看成都是独立的master，然后通过业务实现数据分片。</p>

<p>结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。</p>

<h5 id="4redis的回收策略">（4）Redis的回收策略</h5>

<ul>
  <li>
    <ul>
      <li>
        <p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p>
      </li>
      <li>
        <p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p>
      </li>
      <li>
        <p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p>
      </li>
      <li>
        <p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p>
      </li>
      <li>
        <p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p>
      </li>
      <li>
        <p>no-enviction（驱逐）：禁止驱逐数据</p>
      </li>
      <li></li>
    </ul>

    <p>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。</p>

    <p>　　使用策略规则：</p>

    <p>　　1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</p>

    <p>　　2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</p>
  </li>
</ul>
</div><p><a href="/mianshi/Redis/0705/02">Read more</a></p></div><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Jul 05, 2020</span>
            </li><li><i class="far fa-eye"></i> <span class="js-pageview" data-page-key="mianshi-2020-07-05-02">0</span> views</li></ul></div><meta itemprop="author" content="java牛牛"/><meta itemprop="datePublished" content="2020-07-05T00:00:00+08:00">
    <meta itemprop="keywords" content="面试题"></div>
      </article><article class="item" itemscope itemtype="http://schema.org/BlogPosting"><div class="item__content">
          <header><a href="/mianshi/spring/0705/10"><h2 itemprop="headline" class="item__header">关于Spring 和 Spring MVC的43个问题</h2></a></header>
          <div class="item__description"><div class="article__content" itemprop="description articleBody"><h4 id="1为什么使用spring">1、为什么使用spring？</h4>

<ol>
  <li>社区活跃，使用的企业多</li>
  <li>很多第三方框架集成了spring</li>
  <li>提供了Ioc容器，对象间的依赖关系由spring进行控制，避免了硬代码之间的耦合</li>
  <li>提供AOP编程的支持，通过spring的AOP功能，避免了业务之间的耦合</li>
</ol>

<h4 id="2什么是ioc为什使用ioc-">2、什么是IoC，为什使用IoC ?</h4>

<p><strong>控制什么？为什么要控制？</strong> 把创建对象的权限托管给了spring统一管理，控制对象之间的依赖关系，避免硬编码之间的耦合</p>

<p><strong>什么是反转？怎么反转：</strong> 如果把自己主动new的对象称为正转，那么通过spring创建的的对象称为反转，spring创建对象的方式使用了反转和代理的机制</p>

<h4 id="3什么是aop为什么使用aop-">3、什么是AOP，为什么使用AOP ?</h4>

<p>AOP（面向切面编程）是一种编程思想，其主要思想是让开发者把诸多业务流程中的通用功能抽取出来，单独编写功能代码，形成独立的模块，这些模块也被称为切面。AOP在spring中是的核心模块，并提供了编程模范。降低了因不同业务之间的依赖造成的耦合度。</p>

<h4 id="4什么是spring的事务管理">4、什么是Spring的事务管理</h4>

<p>作为企业级的开发框架，spring在不同的事务api上定义了一个抽象层，而开发人员不必了解底底层是事务api，就可以使用spring的事务管理器</p>

<p>Spring既支持编程式事务管理(也称编码式事务)，也支持声明式的事务管理</p>

<p><strong>编程式事务管理</strong>：将事务管理代码嵌入到业务方法中来控制事务的提交和回滚，在编程式事务中，必须在每个业务操作中包含额外的事务管理代码</p>

<p><strong>声明式事务管理</strong>：大多数情况下比编程式事务管理更好用。它将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。事务管理作为一种横切关注点，可以通过AOP方法模块化。Spring通过Spring AOP框架支持声明式事务管理。</p>

<h4 id="5spring框架支持以下五种bean的作用域">5、Spring框架支持以下五种bean的作用域?</h4>

<p><strong>单例：</strong> 默认值，bean在每个spring ioc 容器中只有一个对象</p>

<p><strong>多例：</strong> 一个bean的定义可以有多个实例</p>

<p><strong>request：</strong> 针对每一次Http请求，Spring容器根据该bean的定义创建一个全新的实例，且该实例仅在当前Http请求内有效，而其它请求无法看到当前请求中状态的变化，当当前Http请求结束，该bean实例也将会被销毁。</p>

<p><strong>seession：</strong> 在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效</p>

<p><strong>global session：</strong> 在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。</p>

<h4 id="6什么是spring的mvc框架">6、什么是Spring的MVC框架？</h4>

<ul>
  <li>springmvc 是基于mvc的web框架，</li>
  <li>spring mvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。</li>
  <li>
    <p>将web层进行职责解耦</p>
  </li>
  <li>它允许以声明的方式把请求参数和业务对象绑定。</li>
</ul>

<h5 id="以下组件通常使用框架提供实现">以下组件通常使用框架提供实现：</h5>

<p><strong>DispatcherServlet：</strong> 作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</p>

<p><strong>HandlerMapping：</strong> 通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>

<p><strong>HandlAdapter：</strong> 通过扩展处理器适配器，支持更多类型的处理器。</p>

<p><strong>ViewResolver：</strong> 通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。</p>

<h4 id="7如何启用注解">7、如何启用注解?</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;context:annotation-config/&gt;
如果使用&lt;context:component-scan base-package="com.tgb.web.controller.annotation"&gt; &lt;/context:component-scan&gt;  则上面内容可以省略
</code></pre></div></div>

<h4 id="8spring-mvc的请求流程">8、Spring MVC的请求流程?</h4>

<p><img src="/assets/images/mianshiti/0705/249993-20170207140151791-1932120070.png" alt="img" /></p>

<p><strong>看到这个图大家可能会有很多的疑惑，现在我们来看一下这个图的步骤：（可以对比MVC的原理图进行理解）</strong></p>

<p>第一步:用户发起请求到前端控制器（DispatcherServlet）</p>

<p>第二步：前端控制器请求处理器映射器（HandlerMappering）去查找处理器（Handle）：通过xml配置或者注解进行查找</p>

<p>第三步：找到以后处理器映射器（HandlerMappering）像前端控制器返回执行链（HandlerExecutionChain）</p>

<p>第四步：前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler）</p>

<p>第五步：处理器适配器去执行Handler</p>

<p>第六步：Handler执行完给处理器适配器返回ModelAndView</p>

<p>第七步：处理器适配器向前端控制器返回ModelAndView</p>

<p>第八步：前端控制器请求视图解析器（ViewResolver）去进行视图解析</p>

<p>第九步：视图解析器像前端控制器返回View</p>

<p>第十步：前端控制器对视图进行渲染</p>

<p>第十一步：前端控制器向用户响应结果</p>

<h4 id="9webxml的配置">9、web.xml的配置</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;web-app</span> <span class="na">xmlns=</span><span class="s">"http://xmlns.jcp.org/xml/ns/javaee"</span>
         <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="na">xsi:schemaLocation=</span><span class="s">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span>
         <span class="na">version=</span><span class="s">"3.1"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!--添加过滤器--&gt;</span>
    <span class="nt">&lt;filter&gt;</span>
        <span class="nt">&lt;filter-name&gt;</span>characterEncodingFilter<span class="nt">&lt;/filter-name&gt;</span>
        <span class="nt">&lt;filter-class&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="nt">&lt;/filter-class&gt;</span>
        <span class="nt">&lt;init-param&gt;</span>
            <span class="nt">&lt;param-name&gt;</span>encoding<span class="nt">&lt;/param-name&gt;</span>
            <span class="nt">&lt;param-value&gt;</span>UTF-8<span class="nt">&lt;/param-value&gt;</span>
        <span class="nt">&lt;/init-param&gt;</span>
        <span class="nt">&lt;init-param&gt;</span>
            <span class="nt">&lt;param-name&gt;</span>forceEncoding<span class="nt">&lt;/param-name&gt;</span>
            <span class="nt">&lt;param-value&gt;</span>true<span class="nt">&lt;/param-value&gt;</span>
        <span class="nt">&lt;/init-param&gt;</span>
    <span class="nt">&lt;/filter&gt;</span>
    <span class="nt">&lt;filter-mapping&gt;</span>
        <span class="nt">&lt;filter-name&gt;</span>characterEncodingFilter<span class="nt">&lt;/filter-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/filter-mapping&gt;</span>
    <span class="c">&lt;!--配置spring--&gt;</span>
    <span class="nt">&lt;servlet&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>dispatcherServlet<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="nt">&lt;/servlet-class&gt;</span>
        <span class="nt">&lt;init-param&gt;</span>
            <span class="nt">&lt;param-name&gt;</span>contextConfigLocation<span class="nt">&lt;/param-name&gt;</span>
            <span class="nt">&lt;param-value&gt;</span>classpath:spring-config.xml<span class="nt">&lt;/param-value&gt;</span>
        <span class="nt">&lt;/init-param&gt;</span>
    <span class="nt">&lt;/servlet&gt;</span>
    <span class="nt">&lt;servlet-mapping&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>dispatcherServlet<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>/<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/servlet-mapping&gt;</span>
    <span class="c">&lt;!--自定义首页--&gt;</span>
  <span class="c">&lt;!--  &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;/first/page&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;--&gt;</span>
    <span class="c">&lt;!--配置404错误页面--&gt;</span>
    <span class="nt">&lt;error-page&gt;</span>
        <span class="nt">&lt;error-code&gt;</span>404<span class="nt">&lt;/error-code&gt;</span>
        <span class="nt">&lt;location&gt;</span>/error_pages/404.jsp<span class="nt">&lt;/location&gt;</span>
    <span class="nt">&lt;/error-page&gt;</span>
    <span class="c">&lt;!--配置500错误提示--&gt;</span>
    <span class="nt">&lt;error-page&gt;</span>
        <span class="nt">&lt;error-code&gt;</span>500<span class="nt">&lt;/error-code&gt;</span>
        <span class="nt">&lt;location&gt;</span>/error_pages/500.jsp<span class="nt">&lt;/location&gt;</span>
    <span class="nt">&lt;/error-page&gt;</span>


    <span class="c">&lt;!--读取静态文件--&gt;</span>
    <span class="nt">&lt;servlet-mapping&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>default<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.js<span class="nt">&lt;/url-pattern&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.css<span class="nt">&lt;/url-pattern&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.woff<span class="nt">&lt;/url-pattern&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.woff2<span class="nt">&lt;/url-pattern&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.ttf<span class="nt">&lt;/url-pattern&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.png<span class="nt">&lt;/url-pattern&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.jpg<span class="nt">&lt;/url-pattern&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.ogg<span class="nt">&lt;/url-pattern&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.mp4<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/servlet-mapping&gt;</span>


<span class="nt">&lt;/web-app&gt;</span>
</code></pre></div></div>

<h4 id="10注解的处理器映射器和适配器">10、注解的处理器映射器和适配器?</h4>

<p>spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping注解映射器。</p>

<p>在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter注解适配器。</p>

<p>使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置</p>

<h4 id="11spring-与-mybatis整合过程">11、spring 与 mybatis整合过程?</h4>

<h5 id="第一步整合dao层">第一步：整合dao层</h5>

<p>mybatis和spring整合，通过spring管理mapper接口。</p>

<p>使用mapper的扫描器自动扫描mapper接口在spring中进行注册。</p>

<h5 id="第二步整合service层">第二步：整合service层</h5>

<p>通过spring管理 service接口。</p>

<p>使用配置方式将service接口配置在spring配置文件中。</p>

<p>实现事务控制。</p>

<h5 id="第三步整合springmvc">第三步：整合springmvc</h5>

<p>由于springmvc是spring的模块，不需要整合</p>

<h5 id="主要配置有">主要配置有：</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1). mybatis配置文件sqlMapConfig.xml配置别名自动扫描(实体类)

  2). mapper扫描器(接口，数据库访问接口)

  3). 数据库连接池配置

  4). 声明式事务配置

  5). 启用注解扫描：&lt;context:component-scan base-package="cn.itcast.ssm.controller"&gt;&lt;/context:component-scan&gt;

  6). 配置注解映射器和适配器： &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;

  7). 视图解析器：&lt;bean  class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;

  8). 配置控制类： DispatcherServlet前端控制器

  9). 配置spring配置文件加载类：ClassLoadListener
</code></pre></div></div>

<h4 id="12视图解析器配置前缀和后缀">12、视图解析器配置前缀和后缀?</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="nt">&gt;</span>
    <span class="c">&lt;!--前缀--&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"prefix"</span> <span class="na">value=</span><span class="s">"/WEB-INF/jsp/"</span><span class="nt">/&gt;</span>
    <span class="c">&lt;!--后缀--&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"suffix"</span> <span class="na">value=</span><span class="s">".jsp"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

</code></pre></div></div>

<h4 id="13sqlmapconfigxmlmybatis自己的配置文件">13、sqlMapConfig.xml，mybatis自己的配置文件?</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;properties</span> <span class="na">resource=</span><span class="s">"db.properties"</span><span class="nt">/&gt;</span>
	<span class="nt">&lt;environments</span> <span class="na">default=</span><span class="s">"development"</span><span class="nt">&gt;</span>
		<span class="nt">&lt;environment</span> <span class="na">id=</span><span class="s">"development"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;transactionManager</span> <span class="na">type=</span><span class="s">"JDBC"</span><span class="nt">/&gt;</span>
			<span class="nt">&lt;dataSource</span> <span class="na">type=</span><span class="s">"POOLED"</span><span class="nt">&gt;</span>
				<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"driver"</span> <span class="na">value=</span><span class="s">"${jdbc.driver}"</span><span class="nt">/&gt;</span>
				<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"url"</span> <span class="na">value=</span><span class="s">"${jdbc.url}"</span><span class="nt">/&gt;</span>
				<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"username"</span> <span class="na">value=</span><span class="s">"${jdbc.username}"</span><span class="nt">/&gt;</span>
				<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"password"</span> <span class="na">value=</span><span class="s">"${jdbc.password}"</span><span class="nt">/&gt;</span>
			<span class="nt">&lt;/dataSource&gt;</span>
		<span class="nt">&lt;/environment&gt;</span>
	<span class="nt">&lt;/environments&gt;</span>

</code></pre></div></div>

<h4 id="14spring自带的数据源">14、spring自带的数据源</h4>

<ul>
  <li>
    <h6 id="spring自带的数据源">spring自带的数据源</h6>
  </li>
  <li>
    <h6 id="dbcp数据源">DBCP数据源</h6>
  </li>
  <li>
    <h6 id="c3p0数据源">C3P0数据源</h6>
  </li>
  <li>
    <h6 id="jndi数据源">JNDI数据源</h6>
  </li>
</ul>

<h4 id="15事务控制applicationcontext-transactionxml">15、事务控制(applicationContext-transaction.xml)?</h4>

<p>在applicationContext-transaction.xml中使用spring声明式事务控制方法。</p>

<h4 id="16加载spring配置">16、加载spring配置?</h4>

<ul>
  <li>
    <p>ClassPathXmlApplication的使用方法//</p>
  </li>
  <li>
    <p>FileSystemXmlApplicationContext的使用方法</p>
  </li>
</ul>

<h4 id="17静态资源访问不被拦截">17、静态资源访问不被拦截?</h4>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;resources</span> <span class="na">mapping=</span><span class="s">"/resources/**"</span> <span class="na">location=</span><span class="s">"/resources/"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;resources</span> <span class="na">mapping=</span><span class="s">"/images/**"</span> <span class="na">location=</span><span class="s">"/images/"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;resources</span> <span class="na">mapping=</span><span class="s">"/js/**"</span> <span class="na">location=</span><span class="s">"/js/"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<h4 id="18requestmapping的作用">18、@RequestMapping的作用?</h4>

<p><strong>url映射：</strong> 在方法上田间</p>

<p><strong>限制http请求方法：</strong> 该注解的配置属性</p>

<p><strong>窄化请求映射：</strong> 在类上添加</p>

<h4 id="19controller方法的返回值">19、controller方法的返回值?</h4>

<h5 id="1-返回modelandview">1 返回ModelAndView</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>需要方法结束时，定义ModelAndView，将model和view分别进行设置。
</code></pre></div></div>

<h5 id="2-返回string">2 返回string</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 如果controller方法返回string，

 1). 表示返回逻辑视图名。真正视图(jsp路径)=前缀+逻辑视图名+后缀

 2). redirect重定向：返回字符串格式为："redirect:queryItem.action"

 3). forward页面转发：返回字符串格式为：“forward:queryItem.action”
</code></pre></div></div>

<h5 id="3-返回void">3 返回void</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  在controller方法形参上可以定义request和response，使用request或 response指定响应结果：

 1). 使用request转向页面，如下：request.getRequestDispatcher("页面路径").forward(request, response);

 2). 也可以通过response页面重定向：response.sendRedirect("url")

 3). 也可以通过response指定响应结果，例如响应json数据如下：

       response.setCharacterEncoding("utf-8");

       response.setContentType("application/json;charset=utf-8");

       response.getWriter().write("json串");
</code></pre></div></div>

<h4 id="20参数绑定">20、参数绑定</h4>

<h5 id="1-默认支持的类型">1 默认支持的类型</h5>

<p>直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。</p>

<p>1). HttpServletRequest：通过request对象获取请求信息</p>

<p>2). HttpServletResponse：通过response处理响应信息</p>

<p>3). HttpSession：通过session对象得到session中存放的对象</p>

<p>4). Model/ModelMap：model是一个接口，modelMap是一个接口实现 。作用：将model数据填充到request域。</p>

<h5 id="2-简单类型">2 简单类型</h5>

<p>通过@RequestParam对简单类型的参数进行绑定。</p>

<p>如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。</p>

<p>如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。</p>

<p>通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，会报错。</p>

<h5 id="4-自定义参数绑定实现日期类型绑定">4 自定义参数绑定实现日期类型绑定</h5>

<p>对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。将请求日期数据串转成 日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。</p>

<h4 id="21spring-mvc-和-struts2-对比">21、Spring MVC 和 Struts2 对比?</h4>

<p>1). Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上SpringMVC 就容易实现restful url</p>

<p>2). 由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。</p>

<p>3). 由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。</p>

<p>4). SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。</p>

<p>5). springmvc面向方法开发的（更接近service接口的开发方式），struts2面向类开发。</p>

<p>6). springmvc可以单例开发，struts2只能是多例开发</p>

<h4 id="22乱码处理">22、乱码处理?</h4>

<h5 id="1-post乱码">1). post乱码</h5>

<p>在web.xml添加post乱码filter：CharacterEncodingFilter</p>

<h5 id="2-对于get请求中文参数出现乱码解决方法有两个">2). 对于get请求中文参数出现乱码解决方法有两个：</h5>

<h6 id="a-修改tomcat配置文件添加编码与工程编码一致如下">a. 修改tomcat配置文件添加编码与工程编码一致，如下：</h6>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Connector</span> <span class="na">URIEncoding=</span><span class="s">"utf-8"</span> <span class="na">connectionTimeout=</span><span class="s">"20000"</span> <span class="na">port=</span><span class="s">"8080"</span> <span class="na">protocol=</span><span class="s">"HTTP/1.1"</span> <span class="na">redirectPort=</span><span class="s">"8443"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<h6 id="b-对参数进行重新编码">b. 对参数进行重新编码：</h6>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">userName</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getParamter</span><span class="o">(</span><span class="s">"userName"</span><span class="o">).</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"ISO8859-1"</span><span class="o">),</span><span class="s">"utf-8"</span><span class="o">)</span>
</code></pre></div></div>

<p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>

<h4 id="23集合类型绑定">23、集合类型绑定</h4>

<h5 id="1-数组绑定">1). 数组绑定：</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>controller方法参数使用：(Integer[] itemId)
页面统一使用:itemId 作为name
</code></pre></div></div>

<h5 id="2-list绑定">2). list绑定：</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> pojo属性名为：itemsList
 页面：itemsList[index].属性名
</code></pre></div></div>

<h5 id="3-map-绑定">3). map 绑定：</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> pojo属性名为：Map&lt;String, Object&gt; itemInfo = new HashMap&lt;String, Object&gt;();
 页面： &lt;td&gt;姓名：&lt;inputtype="text"name="itemInfo['name']"/&gt;
</code></pre></div></div>

<h4 id="24spring-校验-">24、spring 校验 ?</h4>

<p>1). 项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。</p>

<p>2). springmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。</p>

<p>校验思路：页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面</p>

<h4 id="25数据回显">25、数据回显?</h4>

<p>1). @ModelAttribute还可以将方法的返回值传到页面：在方法上加注解@ModelAttribute</p>

<p>2). 使用最简单方法使用model，可以不用@ModelAttribute：model.addAttribute(“id”, id);</p>

<p>3). springmvc默认对pojo数据进行回显。pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写）</p>

<p>4). public String testParam(PrintWriter out, @RequestParam(“username”) String username) { //out直接输出</p>

<h4 id="26异常处理">26、异常处理?</h4>

<p>springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。</p>

<p>系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。</p>

<p>Spring 统一异常处理有 3 种方式，分别为：</p>

<ol>
  <li>使用 @ ExceptionHandler 注解</li>
  <li>实现 HandlerExceptionResolver 接口</li>
  <li>使用 @controlleradvice 注解</li>
</ol>

<h4 id="27上传图片">27、上传图片？</h4>

<p>1). 在页面form中提交enctype=”multipart/form-data”的数据时，需要springmvc对multipart类型的数据进行解析。</p>

<p>2). 在springmvc.xml中配置multipart类型解析器。</p>

<p>3). 方法中使用：MultipartFile attach (单个文件上传) 或者  MultipartFile[] attachs (多个文件上传)</p>

<h4 id="28json处理">28、Json处理</h4>

<p>1). 加载json转换的jar包：springmvc中使用jackson的包进行json转换（@requestBody和@responseBody使用下边的包进行json转）</p>

<p>2). 配置json转换器。在注解适配器RequestMappingHandlerAdapter中加入messageConverters。如果使用<mvc:annotation-driven></mvc:annotation-driven> 则会自动加入。</p>

<p>3). ajax</p>

<p>4). Controller (ResponseBody、RequestBody)</p>

<p>5). 注意ajax中contentType如果不设置为json类型，则传的参数为key/value类型。上面设置后，传的是json类型。</p>

<h4 id="29拦截器">29、拦截器?</h4>

<h5 id="1-定义拦截器实现handlerinterceptor接口接口中提供三个方法">1). 定义拦截器，实现HandlerInterceptor接口。接口中提供三个方法。</h5>

<p>a. preHandle ：进入 Handler方法之前执行，用于身份认证、身份授权，比如身份认证，如果认证不通过表示当前用户没有登陆，需要此方法拦截不再向下执行</p>

<p>b. postHandle：进入Handler方法之后，返回modelAndView之前执行，应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图</p>

<p>c. afterCompletion：执行Handler完成执行此方法，应用场景：统一异常处理，统一日志处理</p>

<h5 id="2-拦截器配置">2). 拦截器配置：</h5>

<p>a. 针对HandlerMapping配置(不推荐)：springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该 HandlerMapping映射成功的handler最终使用该 拦截器。  (一般不推荐使用)</p>

<p>b. 类似全局的拦截器：springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中</p>

<h4 id="30spring中自动装配的方式有哪些">30、spring中自动装配的方式有哪些？</h4>

<p>1、No：即不启用自动装配。</p>

<p>2、byName：通过属性的名字的方式查找JavaBean依赖的对象并为其注入。比如说类Computer有个属性printer，指定其autowire属性为byName后，Spring IoC容器会在配置文件中查找id/name属性为printer的bean，然后使用Seter方法为其注入。</p>

<p>3、byType：通过属性的类型查找JavaBean依赖的对象并为其注入。比如类Computer有个属性printer，类型为Printer，那么，指定其autowire属性为byType后，Spring IoC容器会查找Class属性为Printer的bean，使用Seter方法为其注入。</p>

<p>4、constructor：通byType一样，也是通过类型查找依赖对象。与byType的区别在于它不是使用Seter方法注入，而是使用构造子注入。</p>

<p>5、autodetect：在byType和constructor之间自动的选择注入方式。</p>

<p>6、default：由上级标签<beans>的default-autowire属性确定。</beans></p>

<h4 id="31spring中aop的应用场景aop原理好处">31、Spring中AOP的应用场景、Aop原理、好处？</h4>

<p>AOP–Aspect Oriented Programming面向切面编程；用来封装横切关注点，具体可以在下面的场景中使用:</p>

<p>Authentication 权限、Caching 缓存、Context passing 内容传递、Error handling 错误处理Lazy loading懒加载、Debugging调试、logging, tracing, profiling and monitoring 记录跟踪优化　校准、Performance optimization　性能优化、Persistence 持久化、Resource pooling　资源池、Synchronization　同步、Transactions 事务。</p>

<p><strong>原理：</strong>AOP是面向切面编程，是通过__动态代理__的方式为程序添加统一功能，集中解决一些公共问题。</p>

<p><strong>优点：</strong>1.各个步骤之间的良好隔离性耦合性大大降低 	
      2.源代码无关性，再扩展功能的同时不对源码进行修改操作</p>

<h4 id="32spring中ioc的作用与原理对象创建的过程">32、Spring中IOC的作用与原理？对象创建的过程？</h4>

<p>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦</p>

<p><strong>对象创建的过程：</strong></p>

<ol>
  <li>读取resources文件下spring_ioc.xml</li>
  <li>Xml解析spring_ioc.xml</li>
  <li>把解析xml里的内容存储到内存的map集合中</li>
  <li>从map集合中读取集合内容，就是<Bean></Bean>清单里的内容</li>
  <li>遍历集合中的所有数据，并反射实例化对象</li>
</ol>

<p>Class.forName(“com.spring.ioc.Hello”).newInstance()</p>

<h4 id="33spring常见创建对象的注解">33、Spring常见创建对象的注解？</h4>

<p>@Component@Controller@ Service@ Repository</p>

<h4 id="34spring中用到的设计模式">34、Spring中用到的设计模式？</h4>

<ul>
  <li>单例模式 bean默认单例</li>
  <li>工厂模式 beanFactory ApplicationContext</li>
  <li>代理模式 springAOP</li>
  <li>模版模式 jdbcTemplate</li>
  <li>观察者模式  Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
  <li>适配器模式 Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code class="language-plaintext highlighter-rouge">Controller</code></li>
</ul>

<h4 id="35spring的优点">35、Spring的优点？</h4>

<p>1.<strong>降低了组件之间的耦合性</strong> ，实现了软件各层之间的解耦
2.可以使用容易__提供的众多服务__，如事务管理，消息服务等
3.容器提供__单例模式__支持
4.容器提供了__AOP技术__，利用它很容易实现如权限拦截，运行期监控等功能
5.容器提供了__众多的辅助类__，能加快应用的开发
6.spring对于__主流的应用框架提供了集成支持__，如hibernate，JPA，Struts等
7.spring属于低__侵入式设计__，代码的污染极低
8.独立于各种应用服务器
9.spring的DI机制降低了业务对象替换的复杂性</p>

<h4 id="36spring-bean的作用域之间有什么区别">36、Spring Bean的作用域之间有什么区别？</h4>

<p>Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：</p>

<p>singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。</p>

<p>prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。</p>

<p>request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</p>

<p>Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</p>

<p>global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。</p>

<p>全局作用域与Servlet中的session作用域效果相同。</p>

<h4 id="37spring管理事务有几种方式">37、Spring管理事务有几种方式？</h4>

<p>有两种方式：</p>

<p>1、编程式事务，在代码中硬编码。(不推荐使用)</p>

<p>2、声明式事务，在配置文件中配置（推荐使用）</p>

<p>声明式事务又分为两种：</p>

<p>a、基于XML的声明式事务</p>

<p>b、基于注解的声明式事务</p>

<h4 id="38spring中的核心类有那些各有什么作用">38、spring中的核心类有那些，各有什么作用？</h4>

<p>BeanFactory：产生一个新的实例，可以实现单例模式</p>

<p>BeanWrapper：提供统一的get及set方法</p>

<p>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</p>

<h4 id="39bean的调用方式有哪些">39、Bean的调用方式有哪些？</h4>

<p>有三种方式可以得到Bean并进行调用：
1、使用BeanWrapper
HelloWorld hw=new HelloWorld();
BeanWrapper bw=new BeanWrapperImpl(hw);
bw.setPropertyvalue(”msg”,”HelloWorld”);
system.out.println(bw.getPropertyCalue(”msg”));
2、使用BeanFactory
InputStream is=new FileInputStream(”config.xml”);
XmlBeanFactory factory=new XmlBeanFactory(is);
HelloWorld hw=(HelloWorld) factory.getBean(”HelloWorld”);
system.out.println(hw.getMsg());
3、使用ApplicationConttext
ApplicationContext actx=new FleSystemXmlApplicationContext(”config.xml”);
HelloWorld hw=(HelloWorld) actx.getBean(”HelloWorld”);
System.out.println(hw.getMsg());</p>

<h4 id="40什么是ioc什么又是di他们有什么区别">40、什么是IOC，什么又是DI，他们有什么区别？</h4>

<p>依赖注入DI是一个程序设计模式和架构模型， 一些时候也称作控制反转，尽管在技术上来讲，依赖注入是一个IOC的特殊实现，依赖注入是指一个对象应用另外一个对象来提供一个特殊的能力，例如：把一个 数据库连接 以参数的形式传到另一个对象的结构方法里面 而不是在那个对象内部自行创建一个连接。控制反转和依赖注入的基本思想就是把类的依赖从类内部转化到外 部以减少依赖</p>

<p>应用控制反转，对象在被创建的时候，将实体依赖对象的引用传递给调控系统。也可以说，依赖被注入到对象中。所以，控制反转是，关于一个对象如何获取他所依赖的对象的引用，这个责任的反转</p>

<h4 id="41spring有两种代理方式">41、spring有两种代理方式？</h4>

<p>若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>优点：因为有接口，所以使系统更加松耦合
缺点：为每一个目标类创建接口
</code></pre></div></div>

<p>若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。
缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好。 #### 42、springMVC的流程？
</code></pre></div></div>

<p>请求-&gt;dispaterServlet-&gt;映射处理器-&gt;适配器-&gt;handle-&gt;modelView-&gt;view</p>

<h4 id="43springmvc的优点">43、Springmvc的优点？</h4>

<p>__Spring MVC__是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p>

<h5 id="springmvc的优点">Springmvc的优点:</h5>

<p>（1）可以支持各种视图技术,而不仅仅局限于JSP；</p>

<p>（2）与Spring框架集成（如IoC容器、AOP等）；</p>

<p>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</p>

<p>（4） 支持各种请求资源的映射策略</p>

<h4 id="44过滤器和拦截器的区别">44、过滤器和拦截器的区别：</h4>

<p>　　①拦截器是基于java的反射机制的，而过滤器是基于函数回调。
　　②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。
　　③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
　　④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。
　　⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</p>

<p>　　⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p>
</div><p><a href="/mianshi/spring/0705/10">Read more</a></p></div><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/archive.html?tag=%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Jul 05, 2020</span>
            </li><li><i class="far fa-eye"></i> <span class="js-pageview" data-page-key="mianshi-2020-07-05-010">0</span> views</li></ul></div><meta itemprop="author" content="java牛牛"/><meta itemprop="datePublished" content="2020-07-05T00:00:00+08:00">
    <meta itemprop="keywords" content="面试题"></div>
      </article></div>
</div><div class="layout--home"><div class="pagination"><p>291 post articles, 37 pages.</p>
    <div class="pagination__menu">
      <ul class="menu menu--nowrap"><li><div class="button button--secondary button--circle disabled">
            <i class="fas fa-angle-left"></i>
          </div></li><li>
              <div class="button button--primary button--circle focus"><span>1</span></div>
            </li><li>
                  <a class="button button--secondary button--circle" href="/home/page2"><span>2</span></a>
                </li><li>
                  <a class="button button--secondary button--circle" href="/home/page3"><span>3</span></a>
                </li><li>
                  <a class="button button--secondary button--circle" href="/home/page4"><span>4</span></a>
                </li><li><span class="pagination__omit"><i class="fas fa-ellipsis-h"></i></span></li><li>
                  <a class="button button--secondary button--circle" href="/home/page37"><span>37</span></a>
                </li><li><a class="button button--secondary button--circle" href="/home/page2">
            <i class="fas fa-angle-right"></i>
          </a></li></ul>
    </div>
  </div></div>
<script>/*(function () {

})();*/
</script>



</div><section class="page__comments d-print-none"></section></article><!-- start custom main bottom snippet -->

<!-- end custom main bottom snippet -->
</div>
            </div></div></div><div class="page__footer d-print-none">
<footer class="footer py-4 js-page-footer">
  <div class="main"><div itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="java牛牛"><meta itemprop="url" content="/javaniuniu.com"><meta itemprop="description" content="I am an amazing person.
"><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"><link itemprop="url" href="javaniuniu.com"><li title="Send me an Email.">
      <a class="button button--circle mail-button" itemprop="email" href="mailto:king101125s@gmail.com" target="_blank">
        <i class="fas fa-envelope"></i>
      </a><li title="Follow me on Facebook.">
        <a class="button button--circle facebook-button" itemprop="sameAs" href="https://www.facebook.com/minplemon" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M767.428571 6.857143l0 150.857143-89.714286 0q-49.142857 0-66.285714 20.571429t-17.142857 61.714286l0 108 167.428571 0-22.285714 169.142857-145.142857 0 0 433.714286-174.857143 0 0-433.714286-145.714286 0 0-169.142857 145.714286 0 0-124.571429q0-106.285714 59.428571-164.857143t158.285714-58.571429q84 0 130.285714 6.857143z" />
</svg>
</div>
        </a>
      </li><li title="Follow me on Twitter.">
        <a class="button button--circle twitter-button" itemprop="sameAs" href="https://twitter.com/minplemon" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M1024.032 194.432c-37.664 16.704-78.176 28-120.672 33.088 43.36-26.016 76.672-67.168 92.384-116.224-40.608 24.064-85.568 41.568-133.408 50.976-38.336-40.832-92.928-66.336-153.344-66.336-116.032 0-210.08 94.048-210.08 210.08 0 16.48 1.856 32.512 5.44 47.872-174.592-8.768-329.408-92.416-433.024-219.52-18.08 31.04-28.448 67.104-28.448 105.632 0 72.896 37.088 137.184 93.472 174.88-34.432-1.088-66.816-10.528-95.168-26.272-0.032 0.864-0.032 1.76-0.032 2.656 0 101.792 72.416 186.688 168.512 205.984-17.632 4.8-36.192 7.36-55.36 7.36-13.536 0-26.688-1.312-39.52-3.776 26.72 83.456 104.32 144.192 196.256 145.888-71.904 56.352-162.496 89.92-260.928 89.92-16.96 0-33.664-0.992-50.112-2.944 92.96 59.616 203.392 94.4 322.048 94.4 386.432 0 597.728-320.128 597.728-597.76 0-9.12-0.192-18.176-0.608-27.168 41.056-29.632 76.672-66.624 104.832-108.736z" />
</svg>
</div>
        </a>
      </li><li title="Follow me on Github.">
        <a class="button button--circle github-button" itemprop="sameAs" href="https://github.com/javaniuniu" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path class="svgpath" data-index="path_0" fill="#272636" d="M0 525.2c0 223.6 143.3 413.7 343 483.5 26.9 6.8 22.8-12.4 22.8-25.4l0-88.7c-155.3 18.2-161.5-84.6-172-101.7-21.1-36-70.8-45.2-56-62.3 35.4-18.2 71.4 4.6 113.1 66.3 30.2 44.7 89.1 37.2 119 29.7 6.5-26.9 20.5-50.9 39.7-69.6C248.8 728.2 181.7 630 181.7 513.2c0-56.6 18.7-108.7 55.3-150.7-23.3-69.3 2.2-128.5 5.6-137.3 66.5-6 135.5 47.6 140.9 51.8 37.8-10.2 80.9-15.6 129.1-15.6 48.5 0 91.8 5.6 129.8 15.9 12.9-9.8 77-55.8 138.8-50.2 3.3 8.8 28.2 66.7 6.3 135 37.1 42.1 56 94.6 56 151.4 0 117-67.5 215.3-228.8 243.7 26.9 26.6 43.6 63.4 43.6 104.2l0 128.8c0.9 10.3 0 20.5 17.2 20.5C878.1 942.4 1024 750.9 1024 525.3c0-282.9-229.3-512-512-512C229.1 13.2 0 242.3 0 525.2L0 525.2z" />
</svg>
</div>
        </a>
      </li></ul>
</div>
</div>
    </div><div class="site-info mt-2">
      <div>© JAVA 牛牛 2020, <a href="http://www.beian.miit.gov.cn/">浙ICP备20011288号</a>
        Powered by <a title="Jekyll is a simple, blog-aware, static site generator." href="http://jekyllrb.com/">Jekyll</a> & <a
        title="TeXt is a super customizable Jekyll theme." href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt Theme</a>.
      </div>
    </div>
  </div>
</footer>
</div></div>
    </div><script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $body = $('body'), $window = $(window);
    var $pageRoot = $('.js-page-root'), $pageMain = $('.js-page-main');
    var activeCount = 0;
    function modal(options) {
      var $root = this, visible, onChange, hideWhenWindowScroll = false;
      var scrollTop;
      function setOptions(options) {
        var _options = options || {};
        visible = _options.initialVisible === undefined ? false : show;
        onChange = _options.onChange;
        hideWhenWindowScroll = _options.hideWhenWindowScroll;
      }
      function init() {
        setState(visible);
      }
      function setState(isShow) {
        if (isShow === visible) {
          return;
        }
        visible = isShow;
        if (visible) {
          activeCount++;
          scrollTop = $(window).scrollTop() || $pageMain.scrollTop();
          $root.addClass('modal--show');
          $pageMain.scrollTop(scrollTop);
          activeCount === 1 && ($pageRoot.addClass('show-modal'), $body.addClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.on('scroll', hide);
          $window.on('keyup', handleKeyup);
        } else {
          activeCount > 0 && activeCount--;
          $root.removeClass('modal--show');
          $window.scrollTop(scrollTop);
          activeCount === 0 && ($pageRoot.removeClass('show-modal'), $body.removeClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.off('scroll', hide);
          $window.off('keyup', handleKeyup);
        }
        onChange && onChange(visible);
      }
      function show() {
        setState(true);
      }
      function hide() {
        setState(false);
      }
      function handleKeyup(e) {
        // Char Code: 27  ESC
        if (e.which ===  27) {
          hide();
        }
      }
      setOptions(options);
      init();
      return {
        show: show,
        hide: hide,
        $el: $root
      };
    }
    $.fn.modal = modal;
  });
})();
</script><div class="modal modal--overflow page__search-modal d-print-none js-page-search-modal"><script>
(function () {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    // search panel
    var search = (window.search || (window.search = {}));
    var useDefaultSearchBox = window.useDefaultSearchBox === undefined ?
      true : window.useDefaultSearchBox ;

    var $searchModal = $('.js-page-search-modal');
    var $searchToggle = $('.js-search-toggle');
    var searchModal = $searchModal.modal({ onChange: handleModalChange, hideWhenWindowScroll: true });
    var modalVisible = false;
    search.searchModal = searchModal;

    var $searchBox = null;
    var $searchInput = null;
    var $searchClear = null;

    function getModalVisible() {
      return modalVisible;
    }
    search.getModalVisible = getModalVisible;

    function handleModalChange(visible) {
      modalVisible = visible;
      if (visible) {
        search.onShow && search.onShow();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].focus();
      } else {
        search.onShow && search.onHide();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].blur();
        setTimeout(function() {
          useDefaultSearchBox && ($searchInput.val(''), $searchBox.removeClass('not-empty'));
          search.clear && search.clear();
          window.pageAsideAffix && window.pageAsideAffix.refresh();
        }, 400);
      }
    }

    $searchToggle.on('click', function() {
      modalVisible ? searchModal.hide() : searchModal.show();
    });
    // Char Code: 83  S, 191 /
    $(window).on('keyup', function(e) {
      if (!modalVisible && !window.isFormElement(e.target || e.srcElement) && (e.which === 83 || e.which === 191)) {
        modalVisible || searchModal.show();
      }
    });

    if (useDefaultSearchBox) {
      $searchBox = $('.js-search-box');
      $searchInput = $searchBox.children('input');
      $searchClear = $searchBox.children('.js-icon-clear');
      search.getSearchInput = function() {
        return $searchInput.get(0);
      };
      search.getVal = function() {
        return $searchInput.val();
      };
      search.setVal = function(val) {
        $searchInput.val(val);
      };

      $searchInput.on('focus', function() {
        $(this).addClass('focus');
      });
      $searchInput.on('blur', function() {
        $(this).removeClass('focus');
      });
      $searchInput.on('input', window.throttle(function() {
        var val = $(this).val();
        if (val === '' || typeof val !== 'string') {
          search.clear && search.clear();
        } else {
          $searchBox.addClass('not-empty');
          search.onInputNotEmpty && search.onInputNotEmpty(val);
        }
      }, 400));
      $searchClear.on('click', function() {
        $searchInput.val(''); $searchBox.removeClass('not-empty');
        search.clear && search.clear();
      });
    }
  });
})();
</script><div class="search search--dark">
  <div class="main">
    <div class="search__header">Search</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--theme-dark button--pill search__cancel js-search-toggle">
        Cancel</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>
<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var search = (window.search || (window.search = {}));
  var searchData = window.TEXT_SEARCH_DATA || {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) { return null; }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function clear() {
    $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }
  function onInputNotEmpty(val) {
    $result.html(render(searchByQuery(val)));
    $resultItems = $('.search-result__item'); activeIndex = 0;
    $resultItems.eq(0).addClass('active');
  }

  search.clear = clear;
  search.onInputNotEmpty = onInputNotEmpty;

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  // Char Code: 13  Enter, 37  ⬅, 38  ⬆, 39  ➡, 40  ⬇
  $(window).on('keyup', function(e) {
    var modalVisible = search.getModalVisible && search.getModalVisible();
    if (modalVisible) {
      if (e.which === 38) {
        modalVisible && moveActiveIndex('up');
      } else if (e.which === 40) {
        modalVisible && moveActiveIndex('down');
      } else if (e.which === 13) {
        modalVisible && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });
});
</script>
</div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function affix(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroll,
        offsetBottom = 0, scrollTarget = window, scroll = window.document, disabled = false, isOverallScroller = true,
        rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop,
        hasInit = false, curState;

      function setOptions(options) {
        var _options = options || {};
        _options.offsetBottom && (offsetBottom = _options.offsetBottom);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroll && (scroll = _options.scroll);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $scrollTarget = $(scrollTarget);
        isOverallScroller = window.isOverallScroller($scrollTarget[0]);
        $scroll = $(scroll);
      }
      function preCalc() {
        top();
        rootHeight = $root.outerHeight();
        rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
        rootLeft = $root.offset().left;
      }
      function calc(needPreCalc) {
        needPreCalc && preCalc();
        scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
        rootBottomTop = scrollBottom - rootTop;
      }
      function top() {
        if (curState !== 'top') {
          $root.removeClass('fixed').css({
            left: 0,
            top: 0
          });
          curState = 'top';
        }
      }
      function fixed() {
        if (curState !== 'fixed') {
          $root.addClass('fixed').css({
            left: rootLeft + 'px',
            top: 0
          });
          curState = 'fixed';
        }
      }
      function bottom() {
        if (curState !== 'bottom') {
          $root.removeClass('fixed').css({
            left: 0,
            top: rootBottomTop + 'px'
          });
          curState = 'bottom';
        }
      }
      function setState() {
        var scrollTop = $scrollTarget.scrollTop();
        if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
          fixed();
        } else if (scrollTop < rootTop) {
          top();
        } else {
          bottom();
        }
      }
      function init() {
        if(!hasInit) {
          var interval, timeout;
          calc(true); setState();
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState();
          });
          $window.on('resize', function() {
            disabled || (calc(true), setState());
          });
          hasInit = true;
        }
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true, { animation: false }); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function toc(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroller, $tocUl = $('<ul class="toc toc--ellipsis"></ul>'), $tocLi, $headings, $activeLast, $activeCur,
        selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false,
        headingsPos, scrolling = false, hasRendered = false, hasInit = false;

      function setOptions(options) {
        var _options = options || {};
        _options.selectors && (selectors = _options.selectors);
        _options.container && (container = _options.container);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroller && (scroller = _options.scroller);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $headings = $(container).find(selectors).filter('[id]');
        $scrollTarget = $(scrollTarget);
        $scroller = $(scroller);
      }
      function calc() {
        headingsPos = [];
        $headings.each(function() {
          headingsPos.push(Math.floor($(this).position().top));
        });
      }
      function setState(element, disabled) {
        var scrollTop = $scrollTarget.scrollTop(), i;
        if (disabled || !headingsPos || headingsPos.length < 1) { return; }
        if (element) {
          $activeCur = element;
        } else {
          for (i = 0; i < headingsPos.length; i++) {
            if (scrollTop >= headingsPos[i]) {
              $activeCur = $tocLi.eq(i);
            } else {
              $activeCur || ($activeCur = $tocLi.eq(i));
              break;
            }
          }
        }
        $activeLast && $activeLast.removeClass('active');
        ($activeLast = $activeCur).addClass('active');
      }
      function render() {
        if(!hasRendered) {
          $root.append($tocUl);
          $headings.each(function() {
            var $this = $(this);
            $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
              .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
          });
          $tocLi = $tocUl.children('li');
          $tocUl.on('click', 'a', function(e) {
            e.preventDefault();
            var $this = $(this);
            scrolling = true;
            setState($this.parent());
            $scroller.scrollToAnchor($this.attr('href'), 400, function() {
              scrolling = false;
            });
          });
        }
        hasRendered = true;
      }
      function init() {
        var interval, timeout;
        if(!hasInit) {
          render(); calc(); setState(null, scrolling);
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState(null, scrolling);
          });
          $window.on('resize', window.throttle(function() {
            if (!disabled) {
              render(); calc(); setState(null, scrolling);
            }
          }, 100));
        }
        hasInit = true;
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();
/*(function () {

})();*/
</script><script>
  window.Lazyload.js(['https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js', 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js'], function() {
    var $canvas = null, $this = null, _ctx = null, _text = '';
    $('.language-chart').each(function(){
      $this = $(this);
      $canvas = $('<canvas></canvas>');
      _text = $this.text();
      $this.text('').append($canvas);
      _ctx = $canvas.get(0).getContext('2d');
      (_ctx && _text) && (new Chart(_ctx, JSON.parse(_text)) && $this.attr('data-processed', true));
    });
  });
</script>
<script type="text/x-mathjax-config">
	var _config = { tex2jax: {
		inlineMath: [['$','$'], ['\\(','\\)']]
	}};_config.TeX = { equationNumbers: { autoNumber: "all" } };MathJax.Hub.Config(_config);
</script>
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  window.Lazyload.js('https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js', function() {
    mermaid.initialize({
      startOnLoad: true
    });
    mermaid.init(undefined, '.language-mermaid');
  });
</script>

    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();
</script>
  </body>
</html>

