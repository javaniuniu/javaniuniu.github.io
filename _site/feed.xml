<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.1.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2020-07-07T09:03:01+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JAVA 牛牛</title><subtitle>主要是想看下自己还能在多做些什么
</subtitle><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><entry><title type="html">谈谈Spring中都用到了哪些设计模式？</title><link href="http://localhost:4000/mianshi/spring/0706/03" rel="alternate" type="text/html" title="谈谈Spring中都用到了哪些设计模式？" /><published>2020-07-06T00:00:00+08:00</published><updated>2020-07-06T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/spring/0706/%E8%B0%88%E8%B0%88Spring%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/mianshi/spring/0706/03">&lt;h1 id=&quot;谈谈spring中都用到了哪些设计模式&quot;&gt;谈谈Spring中都用到了哪些设计模式？&lt;/h1&gt;

&lt;p&gt;JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的常见的设计模式。&lt;/p&gt;

&lt;p&gt;Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?&lt;/p&gt;

&lt;h1 id=&quot;控制反转ioc和依赖注入di&quot;&gt;控制反转（IOC）和依赖注入（DI)&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;IoC(Inversion of Control,控制翻转)&lt;/strong&gt; 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(即Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。&lt;strong&gt;IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0706/Jietu20200706-125354@2x.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ioc-patterns&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spring IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。&lt;/strong&gt; IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。&lt;/p&gt;

&lt;p&gt;在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：&lt;/p&gt;

&lt;p&gt;，非常不错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;控制翻转怎么理解呢?&lt;/strong&gt; 举个例子：”对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中”。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权反转了，这就是控制反转名字的由来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DI（Dependency Inject，依赖注入)，是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;工厂设计模式&quot;&gt;工厂设计模式&lt;/h2&gt;

&lt;p&gt;Spring使用工厂模式可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt; 创建 bean 对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;两者对比：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt; ：延迟注入(使用到某个 bean 的时候才会注入),相比于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt;来说会占用更少的内存，程序启动速度更快。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt; ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt; 仅提供了最基本的依赖注入支持，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt; 扩展了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt; ,除了有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt;的功能之外还有额外更多功能，所以一般开发人员使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt;会更多。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ApplicationContext的三个实现类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassPathXmlApplication&lt;/code&gt;：把上下文文件当成类路径资源。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileSystemXmlApplication&lt;/code&gt;：从文件系统中的 XML 文件载入上下文定义信息。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XmlWebApplicationContext&lt;/code&gt;：从Web系统中的XML文件载入上下文定义信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.context.ApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.context.support.FileSystemXmlApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FileSystemXmlApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;HelloApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HelloApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;helloApplicationContext&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMsg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;单例设计模式&quot;&gt;单例设计模式&lt;/h2&gt;

&lt;p&gt;在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用单例模式的好处：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于频繁使用的对象，可以&lt;strong&gt;省略创建对象所花费的时间&lt;/strong&gt;，这对于那些重量级对象而言，是非常可观的一笔系统开销；&lt;/li&gt;
  &lt;li&gt;由于new操作的次数减少，因而&lt;strong&gt;对系统内存的使用频率也会降低&lt;/strong&gt;，这将减轻GC压力，缩短GC停顿时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Spring中bean的默认作用域就是singleton(单例)的&lt;/strong&gt;，除了singleton作用域，Spring中bean还有下面几种作用域：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;prototype : 每次请求都会创建一个新的 bean 实例。&lt;/li&gt;
  &lt;li&gt;request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。&lt;/li&gt;
  &lt;li&gt;session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。&lt;/li&gt;
  &lt;li&gt;global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Spring实现单例的方式：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;xml:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;注解：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Scope(value = &quot;singleton&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spring通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;实现单例注册表的特殊方式实现单例模式。Spring实现单例的核心代码如下：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 通过 ConcurrentHashMap（线程安全） 实现单例注册表&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObjects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcurrentHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ObjectFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;notNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;'beanName' must not be null&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 检查缓存中是否存在实例  &lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//...省略了很多代码&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//...省略了很多代码&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 如果实例对象在不存在，我们注册到单例注册表中。&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;addSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;NULL_OBJECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//将对象添加到单例注册表&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;singletonObjects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beanName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;singletonObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;NULL_OBJECT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;代理设计模式&quot;&gt;代理设计模式&lt;/h2&gt;

&lt;p&gt;AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p&gt;

&lt;p&gt;Spring AOP就是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，Spring AOP会使用Cglib，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0706/Jietu20200706-125429@2x.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然你也可以使用AspectJ，Spring AOP以及集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。&lt;/p&gt;

&lt;p&gt;使用AOP之后我们可以把一些通用的功能抽象出来，在在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。&lt;/p&gt;

&lt;h3 id=&quot;spring-aop-和-aspectj-aop-有什么区别&quot;&gt;Spring AOP 和 AspectJ AOP 有什么区别?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。&lt;/strong&gt; Spring AOP &lt;strong&gt;基于代理(Proxying)&lt;/strong&gt;，而 AspectJ 基于 &lt;strong&gt;字节码操作(Bytecode Manipulation)&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，功能更弱。&lt;/p&gt;

&lt;p&gt;如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。&lt;/p&gt;

&lt;h1 id=&quot;模板方法&quot;&gt;模板方法&lt;/h1&gt;

&lt;p&gt;模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0706/Jietu20200706-125421@2x.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//这是我们的模板方法&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TemplateMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;PrimitiveOperation1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;PrimitiveOperation2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;PrimitiveOperation3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;nf&quot;&gt;PrimitiveOperation1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//当前类实现&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//被子类实现的方法&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PrimitiveOperation2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PrimitiveOperation3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TemplateImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PrimitiveOperation2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//当前类实现&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PrimitiveOperation3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//当前类实现&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Spring 中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jdbcTemplate&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hibernateTemplate&lt;/code&gt; 等&lt;strong&gt;以 Template 结尾的对数据库操作的类&lt;/strong&gt;，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是&lt;strong&gt;使用Callback 模式与模板方法模式配合&lt;/strong&gt;，既达到了代码复用的效果，同时增加了灵活性。&lt;/p&gt;

&lt;h1 id=&quot;观察者模式&quot;&gt;观察者模式&lt;/h1&gt;

&lt;p&gt;观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring &lt;strong&gt;事件驱动模型&lt;/strong&gt; 就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。&lt;/p&gt;

&lt;p&gt;观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。&lt;/p&gt;

&lt;h3 id=&quot;spring-事件驱动模型中的三种角色&quot;&gt;Spring 事件驱动模型中的三种角色&lt;/h3&gt;

&lt;h4 id=&quot;事件角色&quot;&gt;事件角色&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationEvent&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;org.springframework.context&lt;/code&gt;包下)充当事件的角色,这是一个抽象类，它继承了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.EventObject&lt;/code&gt;并实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.io.Serializable&lt;/code&gt;接口。&lt;/p&gt;

&lt;p&gt;Spring 中默认存在以下事件，他们都是对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContextEvent&lt;/code&gt; 的实现(继承自&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContextEvent&lt;/code&gt;)：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ContextStartedEvent&lt;/code&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt; 启动后触发的事件;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ContextStoppedEvent&lt;/code&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt; 停止后触发的事件;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ContextRefreshedEvent&lt;/code&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt; 初始化或刷新完成后触发的事件;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ContextClosedEvent&lt;/code&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt; 关闭后触发的事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0706/Jietu20200706-125445@2x.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;事件监听者角色&quot;&gt;事件监听者角色&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationListener&lt;/code&gt; 充当了事件监听者角色，它是一个接口，里面只定义了一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onApplicationEvent（）&lt;/code&gt;方法来处理&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationEvent&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationListener&lt;/code&gt;接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationEvent&lt;/code&gt;就可以了。所以，在 Spring中我们只要实现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationListener&lt;/code&gt; 接口实现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onApplicationEvent()&lt;/code&gt; 方法即可完成监听事件&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.EventListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@FunctionalInterface&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EventListener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onApplicationEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;事件发布者角色&quot;&gt;事件发布者角色&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationEventPublisher&lt;/code&gt; 充当了事件的发布者，它也是一个接口。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@FunctionalInterface&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationEventPublisher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;publishEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ApplicationEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;publishEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;publishEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationEventPublisher&lt;/code&gt; 接口的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;publishEvent（）&lt;/code&gt;这个方法在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AbstractApplicationContext&lt;/code&gt;类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationEventMulticaster&lt;/code&gt;来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。&lt;/p&gt;

&lt;h3 id=&quot;spring-的事件流程总结&quot;&gt;Spring 的事件流程总结&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;定义一个事件: 实现一个继承自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationEvent&lt;/code&gt;，并且写相应的构造函数；&lt;/li&gt;
  &lt;li&gt;定义一个事件监听者：实现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationListener&lt;/code&gt; 接口，重写 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onApplicationEvent()&lt;/code&gt; 方法；&lt;/li&gt;
  &lt;li&gt;使用事件发布者发布消息: 可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationEventPublisher&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;publishEvent()&lt;/code&gt; 方法发布消息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DemoEvent&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialVersionUID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DemoEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DemoListener&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DemoEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//使用onApplicationEvent接收消息&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onApplicationEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DemoEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;接收到的信息是：&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DemoPublisher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;publish&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//发布事件&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;publishEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DemoEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DemoPublisher&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;publish()&lt;/code&gt; 方法的时候，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demoPublisher.publish(&quot;你好&quot;)&lt;/code&gt; ，控制台就会打印出:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;接收到的信息是：你好&lt;/code&gt; 。&lt;/p&gt;

&lt;h1 id=&quot;适配器模式&quot;&gt;适配器模式&lt;/h1&gt;

&lt;p&gt;适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。&lt;/p&gt;

&lt;h3 id=&quot;spring-aop中的适配器模式&quot;&gt;spring AOP中的适配器模式&lt;/h3&gt;

&lt;p&gt;我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AdvisorAdapter&lt;/code&gt; 。Advice 常用的类型有：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeforeAdvice&lt;/code&gt;（目标方法调用前,前置通知）、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AfterAdvice&lt;/code&gt;（目标方法调用后,后置通知）、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AfterReturningAdvice&lt;/code&gt;(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MethodBeforeAdviceInterceptor&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AfterReturningAdviceAdapter&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AfterReturningAdviceInterceptor&lt;/code&gt;。Spring预定义的通知要通过对应的适配器，适配成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MethodInterceptor&lt;/code&gt;接口(方法拦截器)类型的对象（如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MethodBeforeAdviceInterceptor&lt;/code&gt; 负责适配 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MethodBeforeAdvice&lt;/code&gt;）。&lt;/p&gt;

&lt;h3 id=&quot;spring-mvc中的适配器模式&quot;&gt;spring MVC中的适配器模式&lt;/h3&gt;

&lt;p&gt;在Spring MVC中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatcherServlet&lt;/code&gt; 根据请求信息调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HandlerMapping&lt;/code&gt;，解析请求对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handler&lt;/code&gt;。解析到对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handler&lt;/code&gt;（也就是我们平常说的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 控制器）后，开始由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HandlerAdapter&lt;/code&gt; 适配器处理。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HandlerAdapter&lt;/code&gt; 作为期望接口，具体的适配器实现类用于对目标类进行适配，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 作为需要适配的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么要在 Spring MVC 中使用适配器模式？&lt;/strong&gt; Spring MVC 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 种类众多，不同类型的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatcherServlet&lt;/code&gt; 直接获取对应类型的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt;，需要的自行来判断，像下面这段代码一样：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(mappedHandler.getHandler() instanceof MultiActionController){  
   ((MultiActionController)mappedHandler.getHandler()).xxx  
}else if(mappedHandler.getHandler() instanceof XXX){  
    ...  
}else if(...){  
   ...  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;假如我们再增加一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt;类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。&lt;/p&gt;

&lt;h1 id=&quot;装饰者模式&quot;&gt;装饰者模式&lt;/h1&gt;

&lt;p&gt;装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InputStream&lt;/code&gt;家族，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InputStream&lt;/code&gt; 类下有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileInputStream&lt;/code&gt; (读取文件)、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BufferedInputStream&lt;/code&gt; (增加缓存,使读取文件速度大大提升)等子类都在不修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InputStream&lt;/code&gt;代码的情况下扩展了它的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0706/Jietu20200706-125402@2x.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​ 装饰者模式示意图&lt;/p&gt;

&lt;p&gt;Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Wrapper&lt;/code&gt;或者 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Decorator&lt;/code&gt;。这些类基本上都是动态地给一个对象添加一些额外的职责&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;Spring 框架中用到了哪些设计模式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;工厂设计模式&lt;/strong&gt; : Spring使用工厂模式通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContext&lt;/code&gt; 创建 bean 对象。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;代理设计模式&lt;/strong&gt; : Spring AOP 功能的实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;单例设计模式&lt;/strong&gt; : Spring 中的 Bean 默认都是单例的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;模板方法模式&lt;/strong&gt; : Spring 中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jdbcTemplate&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hibernateTemplate&lt;/code&gt; 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;包装器设计模式&lt;/strong&gt; : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;观察者模式:&lt;/strong&gt; Spring 事件驱动模型就是观察者模式很经典的一个应用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;适配器模式&lt;/strong&gt; :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">谈谈Spring中都用到了哪些设计模式？ JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的常见的设计模式。 Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式? 控制反转（IOC）和依赖注入（DI) IoC(Inversion of Control,控制翻转) 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(即Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。 ioc-patterns Spring IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。 在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答： ，非常不错。 控制翻转怎么理解呢? 举个例子：”对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中”。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权反转了，这就是控制反转名字的由来。 DI（Dependency Inject，依赖注入)，是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。 工厂设计模式 Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。 两者对比： BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入),相比于BeanFactory来说会占用更少的内存，程序启动速度更快。 ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory ,除了有BeanFactory的功能之外还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。 ApplicationContext的三个实现类： ClassPathXmlApplication：把上下文文件当成类路径资源。 FileSystemXmlApplication：从文件系统中的 XML 文件载入上下文定义信息。 XmlWebApplicationContext：从Web系统中的XML文件载入上下文定义信息。 Example: import org.springframework.context.ApplicationContext; import org.springframework.context.support.FileSystemXmlApplicationContext; public class App { public static void main(String[] args) { ApplicationContext context = new FileSystemXmlApplicationContext( &quot;C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml&quot;); HelloApplicationContext obj = (HelloApplicationContext) context.getBean(&quot;helloApplicationContext&quot;); obj.getMsg(); } } 单例设计模式 在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。 使用单例模式的好处： 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销； 由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。 Spring中bean的默认作用域就是singleton(单例)的，除了singleton作用域，Spring中bean还有下面几种作用域： prototype : 每次请求都会创建一个新的 bean 实例。 request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。 session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话 Spring实现单例的方式： xml:&amp;lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&amp;gt; 注解：@Scope(value = &quot;singleton&quot;) Spring通过ConcurrentHashMap实现单例注册表的特殊方式实现单例模式。Spring实现单例的核心代码如下： // 通过 ConcurrentHashMap（线程安全） 实现单例注册表 private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap&amp;lt;String, Object&amp;gt;(64); public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) { Assert.notNull(beanName, &quot;'beanName' must not be null&quot;); synchronized (this.singletonObjects) { // 检查缓存中是否存在实例 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { //...省略了很多代码 try { singletonObject = singletonFactory.getObject(); } //...省略了很多代码 // 如果实例对象在不存在，我们注册到单例注册表中。 addSingleton(beanName, singletonObject); } return (singletonObject != NULL_OBJECT ? singletonObject : null); } } //将对象添加到单例注册表 protected void addSingleton(String beanName, Object singletonObject) { synchronized (this.singletonObjects) { this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT)); } } } 代理设计模式 AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 Spring AOP就是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，Spring AOP会使用Cglib，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理，如下图所示： 当然你也可以使用AspectJ，Spring AOP以及集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。 使用AOP之后我们可以把一些通用的功能抽象出来，在在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。 Spring AOP 和 AspectJ AOP 有什么区别? Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于 字节码操作(Bytecode Manipulation)。 Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，功能更弱。 如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。 模板方法 模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。 public abstract class Template { //这是我们的模板方法 public final void TemplateMethod(){ PrimitiveOperation1(); PrimitiveOperation2(); PrimitiveOperation3(); } protected void PrimitiveOperation1(){ //当前类实现 } //被子类实现的方法 protected abstract void PrimitiveOperation2(); protected abstract void PrimitiveOperation3(); } public class TemplateImpl extends Template { @Override public void PrimitiveOperation2() { //当前类实现 } @Override public void PrimitiveOperation3() { //当前类实现 } } Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。 观察者模式 观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型 就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。 观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。 Spring 事件驱动模型中的三种角色 事件角色 ApplicationEvent (org.springframework.context包下)充当事件的角色,这是一个抽象类，它继承了java.util.EventObject并实现了 java.io.Serializable接口。 Spring 中默认存在以下事件，他们都是对 ApplicationContextEvent 的实现(继承自ApplicationContextEvent)： ContextStartedEvent：ApplicationContext 启动后触发的事件; ContextStoppedEvent：ApplicationContext 停止后触发的事件; ContextRefreshedEvent：ApplicationContext 初始化或刷新完成后触发的事件; ContextClosedEvent：ApplicationContext 关闭后触发的事件。 事件监听者角色 ApplicationListener 充当了事件监听者角色，它是一个接口，里面只定义了一个 onApplicationEvent（）方法来处理ApplicationEvent。ApplicationListener接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 ApplicationEvent就可以了。所以，在 Spring中我们只要实现 ApplicationListener 接口实现 onApplicationEvent() 方法即可完成监听事件 package org.springframework.context; import java.util.EventListener; @FunctionalInterface public interface ApplicationListener&amp;lt;E extends ApplicationEvent&amp;gt; extends EventListener { void onApplicationEvent(E var1); } 事件发布者角色 ApplicationEventPublisher 充当了事件的发布者，它也是一个接口。 @FunctionalInterface public interface ApplicationEventPublisher { default void publishEvent(ApplicationEvent event) { this.publishEvent((Object)event); } void publishEvent(Object var1); } ApplicationEventPublisher 接口的publishEvent（）这个方法在AbstractApplicationContext类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过ApplicationEventMulticaster来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。 Spring 的事件流程总结 定义一个事件: 实现一个继承自 ApplicationEvent，并且写相应的构造函数； 定义一个事件监听者：实现 ApplicationListener 接口，重写 onApplicationEvent() 方法； 使用事件发布者发布消息: 可以通过 ApplicationEventPublisher 的 publishEvent() 方法发布消息。 Example: // 定义一个事件,继承自ApplicationEvent并且写相应的构造函数 public class DemoEvent extends ApplicationEvent{ private static final long serialVersionUID = 1L; private String message; public DemoEvent(Object source,String message){ super(source); this.message = message; } public String getMessage() { return message; } // 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法； @Component public class DemoListener implements ApplicationListener&amp;lt;DemoEvent&amp;gt;{ //使用onApplicationEvent接收消息 @Override public void onApplicationEvent(DemoEvent event) { String msg = event.getMessage(); System.out.println(&quot;接收到的信息是：&quot;+msg); } } // 发布事件，可以通过ApplicationEventPublisher 的 publishEvent() 方法发布消息。 @Component public class DemoPublisher { @Autowired ApplicationContext applicationContext; public void publish(String message){ //发布事件 applicationContext.publishEvent(new DemoEvent(this, message)); } } 当调用 DemoPublisher 的 publish() 方法的时候，比如 demoPublisher.publish(&quot;你好&quot;) ，控制台就会打印出:接收到的信息是：你好 。 适配器模式 适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。 spring AOP中的适配器模式 我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是AdvisorAdapter 。Advice 常用的类型有：BeforeAdvice（目标方法调用前,前置通知）、AfterAdvice（目标方法调用后,后置通知）、AfterReturningAdvice(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:MethodBeforeAdviceInterceptor、AfterReturningAdviceAdapter、AfterReturningAdviceInterceptor。Spring预定义的通知要通过对应的适配器，适配成 MethodInterceptor接口(方法拦截器)类型的对象（如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice）。 spring MVC中的适配器模式 在Spring MVC中，DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。 为什么要在 Spring MVC 中使用适配器模式？ Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样： if(mappedHandler.getHandler() instanceof MultiActionController){ ((MultiActionController)mappedHandler.getHandler()).xxx }else if(mappedHandler.getHandler() instanceof XXX){ ... }else if(...){ ... } 假如我们再增加一个 Controller类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。 装饰者模式 装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 InputStream家族，InputStream 类下有 FileInputStream (读取文件)、BufferedInputStream (增加缓存,使读取文件速度大大提升)等子类都在不修改InputStream代码的情况下扩展了它的功能。 ​ 装饰者模式示意图 Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 Wrapper或者 Decorator。这些类基本上都是动态地给一个对象添加一些额外的职责 总结 Spring 框架中用到了哪些设计模式： 工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。 包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。 适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。 ……</summary></entry><entry><title type="html">详述 Spring MVC 框架中拦截器 Interceptor 的使用方法</title><link href="http://localhost:4000/mianshi/spring/0706/01" rel="alternate" type="text/html" title="详述 Spring MVC 框架中拦截器 Interceptor 的使用方法" /><published>2020-07-06T00:00:00+08:00</published><updated>2020-07-06T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/spring/0706/%E8%AF%A6%E8%BF%B0%20Spring%20MVC%20%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%8B%A6%E6%88%AA%E5%99%A8%20Interceptor%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/mianshi/spring/0706/01">&lt;h4 id=&quot;1-前言&quot;&gt;1 前言&lt;/h4&gt;

&lt;p&gt;网络上关于Interceptor的文章，但感觉内容都大同小异，而且知识点零零散散，不太方便阅读。&lt;/p&gt;

&lt;p&gt;因此，整理一篇关于拦截器的文章，在此分享给大家，以供大家参考阅读。&lt;/p&gt;

&lt;h4 id=&quot;2-拦截器&quot;&gt;2 拦截器&lt;/h4&gt;

&lt;h5 id=&quot;21-概念&quot;&gt;2.1 概念&lt;/h5&gt;

&lt;p&gt;Java 里的拦截器是动态拦截action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在 AOP（Aspect-Oriented Programming，面向切面编程）中拦截器用于在某个方法（包括构造器）或字段被访问之前进行拦截，然后在之前或之后加入某些操作。特别地，现阶段 Spring 自身仅支持基于方法的拦截操作！如果基于方法的拦截操作不能满足需求，可以使用 AspectJ 与 Spring 进行集成，以实现更细粒度或更多方面的拦截操作。&lt;/p&gt;

&lt;h5 id=&quot;22-原理&quot;&gt;2.2 原理&lt;/h5&gt;

&lt;p&gt;拦截器Interceptor的拦截功能是基于 Java 的动态代理来实现的，具体可以参考博文「用 Java 实现拦截器 Interceptor 的拦截功能 」，也可以通过阅读 Spring 源代码来了解更为权威的实现细节。&lt;/p&gt;

&lt;h4 id=&quot;3-实现方法&quot;&gt;3 实现方法&lt;/h4&gt;

&lt;p&gt;在 Spring 框架之中，我们要想实现拦截器的功能，主要通过两种途径，第一种是实现HandlerInterceptor接口，第二种是实现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebRequestInterceptor&lt;/code&gt;接口。接下来，我们分别详细的介绍两者的实现方法。&lt;/p&gt;

&lt;h5 id=&quot;31-handlerinterceptor-接口&quot;&gt;3.1 HandlerInterceptor 接口&lt;/h5&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HandlerInterceptor&lt;/code&gt;接口中，定义了 3 个方法，分别为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;preHandle()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postHandle()&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterCompletion()&lt;/code&gt;，我们就是通过复写这 3 个方法来对用户的请求进行拦截处理的。因此，我们可以通过直接实现HandlerInterceptor接口来实现拦截器的功能。不过在 Spring 框架之中，其还提供了另外一个接口和一个抽象类，实现了对HandlerInterceptor接口的功能扩展，分别为：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AsyncHandlerIntercepto&lt;/code&gt;r和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HandlerInterceptorAdapter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AsyncHandlerInterceptor&lt;/code&gt;接口，其在继承HandlerInterceptor接口的同时，又声明了一个新的方法afterConcurrentHandlingStarted()；而HandlerInterceptorAdapter抽象类，则是更进一步，在其继承&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AsyncHandlerInterceptor&lt;/code&gt;接口的同时，又复写了preHandle方法。因此，AsyncHandlerInterceptor更像是一个过渡的接口。&lt;/p&gt;

&lt;p&gt;在实际应用中，我们一般都是通过实现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HandlerInterceptor&lt;/code&gt;接口或者继承&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HandlerInterceptorAdapter&lt;/code&gt;抽象类，复写preHandle()、postHandle()和afterCompletion()这 3 个方法来对用户的请求进行拦截处理的。下面，我们就详细介绍这个 3 个方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)&lt;/code&gt; 方法，该方法在请求处理之前进行调用。Spring MVC 中的Interceptor是链式调用的，在一个应用中或者说是在一个请求中可以同时存在多个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interceptor&lt;/code&gt;。每个Interceptor的调用会依据它的声明顺序依次执行，而且最先执行的都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interceptor&lt;/code&gt;中的preHandle方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求做一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔（Boolean）类型的，当它返回为false时，表示请求结束，后续的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interceptor&lt;/code&gt;和控制器（Controller）都不会再执行；当返回值为true时，就会继续调用下一个Interceptor的preHandle方法，如果已经是最后一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interceptor&lt;/code&gt;的时候，就会是调用当前请求的控制器中的方法。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)&lt;/code&gt;方法，通过preHandle方法的解释，我们知道这个方法包括后面要说到的afterCompletion方法都只能在当前所属的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interceptor&lt;/code&gt;的preHandle方法的返回值为true的时候，才能被调用。postHandle方法在当前请求进行处理之后，也就是在控制器中的方法调用之后执行，但是它会在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatcherServlet&lt;/code&gt;进行视图返回渲染之前被调用，所以我们可以在这个方法中对控制器处理之后的ModelAndView对象进行操作。postHandle方法被调用的方向跟&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;preHandle&lt;/code&gt;是相反的，也就是说，先声明的Interceptor的postHandle方法反而会后执行。这和 Struts2 里面的Interceptor的执行过程有点类似，Struts2 里面的Interceptor的执行过程也是链式的，只是在 Struts2 里面需要手动调用ActionInvocation的invoke方法来触发对下一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interceptor&lt;/code&gt;或者是action的调用，然后每一个Interceptor中在invoke方法调用之前的内容都是按照声明顺序执行的，而invoke方法之后的内容就是反向的。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)&lt;/code&gt;方法，也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。因此，该方法将在整个请求结束之后，也就是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatcherServlet&lt;/code&gt;渲染了对应的视图之后执行，这个方法的主要作用是用于进行资源清理的工作。
接下来，我们在看看以上接口和抽象类的具体代码：&lt;/p&gt;

&lt;p&gt;HandlerInterceptor 接口：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.servlet.http.HttpServletRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.servlet.http.HttpServletResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandlerInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	    &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelAndView&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AsyncHandlerInterceptor 接口：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.servlet.http.HttpServletRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.servlet.http.HttpServletResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AsyncHandlerInterceptor&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandlerInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterConcurrentHandlingStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HandlerInterceptorAdapter 抽象类：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet.handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.servlet.http.HttpServletRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.servlet.http.HttpServletResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet.AsyncHandlerInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet.ModelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**

 * Abstract adapter class for the HandlerInterceptor interface,

 * for simplified implementation of pre-only/post-only interceptors.
   *

 * @author Juergen Hoeller

 * @since 05.12.2003
   */&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandlerInterceptorAdapter&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AsyncHandlerInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;cm&quot;&gt;/**

    * This implementation always returns {@code true}.
      */&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;cm&quot;&gt;/**

    * This implementation is empty.
      */&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      	&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelAndView&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      	&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;cm&quot;&gt;/**

    * This implementation is empty.
      */&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      	&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      	&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;cm&quot;&gt;/**

    * This implementation is empty.
      */&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterConcurrentHandlingStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      	&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      	&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如上面的代码所示，其实在HandlerInterceptor和AsyncHandlerInterceptor中还有很多的代码注释，只是博主感觉太多了，就将其全部删除了。如果大家对这些注释感兴趣的话，可以自行查看源代码。下面，我们以继承HandlerInterceptorAdapter抽象类为例进行演示：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.hit.interceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet.ModelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet.handler.HandlerInterceptorAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.servlet.http.HttpServletRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.servlet.http.HttpServletResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**

 * @author 维C果糖

 * @create 2017-03-31
   */&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WrongCodeInterceptor&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandlerInterceptorAdapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WrongCodeInterceptor, preHandle......&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
           &lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelAndView&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WrongCodeInterceptor, postHandle......&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
           &lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WrongCodeInterceptor, afterCompletion......&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterConcurrentHandlingStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
           &lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WrongCodeInterceptor, afterConcurrentHandlingStarted......&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;32-webrequestinterceptor-接口&quot;&gt;3.2 WebRequestInterceptor 接口&lt;/h5&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebRequestInterceptor&lt;/code&gt;接口中也定义了 3 个方法，同HandlerInterceptor接口完全相同，我们也是通过复写这 3 个方法来对用户的请求进行拦截处理的。而且这 3 个方法都传递了同一个参数WebRequest，那么这个WebRequest到底是什么呢？其实这个WebRequest是 Spring 中定义的一个接口，它里面的方法定义跟HttpServletRequest类似，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebRequestInterceptor&lt;/code&gt;中对WebRequest进行的所有操作都将同步到HttpServletRequest中，然后在当前请求中依次传递。&lt;/p&gt;

&lt;p&gt;在 Spring 框架之中，还提供了一个和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebRequestInterceptor&lt;/code&gt;接口长的很像的抽象类，那就是：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebRequestInterceptorAdapter&lt;/code&gt;，其实现了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AsyncHandlerInterceptor&lt;/code&gt;接口，并在内部调用了WebRequestInterceptor接口。&lt;/p&gt;

&lt;p&gt;接下来，我们主要讲一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebRequestInterceptor&lt;/code&gt;接口的 3 个函数：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;preHandle(WebRequest request)&lt;/code&gt;方法，该方法在请求处理之前进行调用，也就是说，其会在控制器中的方法调用之前被调用。这个方法跟&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HandlerInterceptor&lt;/code&gt;中的preHandle不同，主要区别在于该方法的返回值是void类型的，也就是没有返回值，因此我们主要用它来进行资源的准备工作，比如我们在使用 Hibernate 的时候，可以在这个方法中准备一个 Hibernate 的Session对象，然后利用WebRequest的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setAttribute(name, value, scope)&lt;/code&gt;把它放到WebRequest的属性中。在这里，进一步说说setAttribute方法的第三个参数scope，该参数是一个Integer类型的。在WebRequest的父层接口RequestAttributes中对它定义了三个常量，分别为：
SCOPE_REQUEST，它的值是0，表示只有在request中可以访问。
SCOPE_SESSION，它的值是1，如果环境允许的话，它表示的是一个局部的隔离的session，否则就代表普通的session，并且在该session范围内可以访问。
SCOPE_GLOBAL_SESSION，它的值是2，如果环境允许的话，它表示的是一个全局共享的session，否则就代表普通的session，并且在该session范围内可以访问。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postHandle(WebRequest request, ModelMap model)&lt;/code&gt;方法，该方法在请求处理之后，也就是在控制器中的方法调用之后被调用，但是会在视图返回被渲染之前被调用，所以可以在这个方法里面通过改变数据模型ModelMap来改变数据的展示。该方法有两个参数，WebRequest对象是用于传递整个请求数据的，比如在preHandle中准备的数据都可以通过WebRequest来传递和访问；ModelMap就是控制器处理之后返回的Model对象，我们可以通过改变它的属性来改变返回的Model模型。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterCompletion(WebRequest request, Exception ex)&lt;/code&gt;方法，该方法会在整个请求处理完成，也就是在视图返回并被渲染之后执行。因此可以在该方法中进行资源的释放操作。而WebRequest参数就可以把我们在preHandle中准备的资源传递到这里进行释放。Exception参数表示的是当前请求的异常对象，如果在控制器中抛出的异常已经被 Spring 的异常处理器给处理了的话，那么这个异常对象就是是null。
接下来，我们在看看以上接口和抽象类的具体代码：&lt;/p&gt;

&lt;p&gt;WebRequestInterceptor 接口：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.context.request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.ui.ModelMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebRequestInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WebRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WebRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelMap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WebRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;WebRequestInterceptorAdapter 抽象类：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet.handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.servlet.http.HttpServletRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.servlet.http.HttpServletResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.util.Assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.context.request.AsyncWebRequestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.context.request.WebRequestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet.AsyncHandlerInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet.ModelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**

 * Adapter that implements the Servlet HandlerInterceptor interface

 * and wraps an underlying WebRequestInterceptor.
   *

 * @author Juergen Hoeller

 * @since 2.0

 * @see org.springframework.web.context.request.WebRequestInterceptor

 * @see org.springframework.web.servlet.HandlerInterceptor
   */&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebRequestHandlerInterceptorAdapter&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AsyncHandlerInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebRequestInterceptor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;cm&quot;&gt;/**

    * Create a new WebRequestHandlerInterceptorAdapter for the given WebRequestInterceptor.
    * @param requestInterceptor the WebRequestInterceptor to wrap
      */&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;WebRequestHandlerInterceptorAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WebRequestInterceptor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nc&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;notNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;requestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;WebRequestInterceptor must not be null&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requestInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DispatcherServletWebRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelAndView&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DispatcherServletWebRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelAndView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wasCleared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getModelMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DispatcherServletWebRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterConcurrentHandlingStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requestInterceptor&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AsyncWebRequestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;AsyncWebRequestInterceptor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asyncInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AsyncWebRequestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;DispatcherServletWebRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;webRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DispatcherServletWebRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;asyncInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;afterConcurrentHandlingStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;webRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如上面的代码所示，展示了WebRequestInterceptor接口和WebRequestInterceptorAdapter抽象类的源码。下面，我们以实现WebRequestInterceptor接口为例进行演示：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.hit.interceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.ui.ModelMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.context.request.WebRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.context.request.WebRequestInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**

 * @author 维C果糖

 * @create 2017-03-31
   */&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WrongCodeInterceptor&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebRequestInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WebRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WrongCodeInterceptor, preHandle......&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WebRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelMap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WrongCodeInterceptor, postHandle......&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WebRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WrongCodeInterceptor, afterCompletion......&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;33-abstractinterceptor-抽象类&quot;&gt;3.3 AbstractInterceptor 抽象类&lt;/h5&gt;

&lt;p&gt;除了上面3.2 和3.3所讲的内容，我们还可以通过继承 Struts2 框架提供的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AbstractInterceptor&lt;/code&gt;抽象类来实现拦截的功能。如果我们在深入一点研究，会发现AbstractInterceptor实现了Interceptor接口，而Interceptor接口又继承了Serializable接口。&lt;/p&gt;

&lt;p&gt;在Interceptor接口中，提供了 3 个方法供我们使用，分别为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init()、destroy()和intercept()&lt;/code&gt;，由于AbstractInterceptor实现了Interceptor接口，因此我们就可以直接继承AbstractInterceptor，然后复写方法就可以啦！至于为什么继承AbstractInterceptor而不是直接实现Interceptor接口，是因为AbstractInterceptor已经帮我们实现了空的init()和destroy()方法，不需要我们自己去复写了，我们直接复写intercept()方法就可以了。现在，我们大致了解一下这 3 个方法的作用：&lt;/p&gt;

&lt;p&gt;init()方法，一般用来进行初始化操作；
destroy()方法，一般用来进行释放资源的操作；
intercept()方法，该方法是实现拦截功能的主要方法，我们就在该方法中编写拦截的逻辑。
接下来，我们再看看以上接口和抽象类的具体代码：&lt;/p&gt;

&lt;p&gt;Interceptor 接口：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.opensymphony.xwork2.interceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.opensymphony.xwork2.ActionInvocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.io.Serializable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Interceptor&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * Called to let an interceptor clean up any resources it has allocated.
     */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;destroy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * Called after an interceptor is created, but before any requests are processed using
     * {@link #intercept(com.opensymphony.xwork2.ActionInvocation) intercept} , giving
     * the Interceptor a chance to initialize any needed resources.
     */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * Allows the Interceptor to do some processing on the request before and/or after the rest of the processing of the
     * request by the {@link ActionInvocation} or to short-circuit the processing and just return a String return code.
     *
     * @param invocation the action invocation
     * @return the return code, either returned from {@link ActionInvocation#invoke()}, or from the interceptor itself.
     * @throws Exception any system-level error, as defined in {@link com.opensymphony.xwork2.Action#execute()}.
     */&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intercept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ActionInvocation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AbstractInterceptor 接口：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.opensymphony.xwork2.interceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.opensymphony.xwork2.ActionInvocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**

 * Provides default implementations of optional lifecycle methods
   */&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractInterceptor&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Interceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;cm&quot;&gt;/**

    * Does nothing
      */&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;cm&quot;&gt;/**

    * Does nothing
      */&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;destroy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;cm&quot;&gt;/**

    * Override to handle interception
      */&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intercept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ActionInvocation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如上面的代码所示，展示了Interceptor接口和AbstractInterceptor抽象类的源码。下面，我们以继承AbstractInterceptor抽象类为例进行演示：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.hit.interceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.opensymphony.xwork2.ActionInvocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.opensymphony.xwork2.interceptor.AbstractInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.struts2.ServletActionContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;cm&quot;&gt;/**

 * @author 维C果糖

 * @create 2017-03-31
   */&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WrongCodeInterceptor&lt;/span&gt;  &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;cm&quot;&gt;/**

    * 通过拦截功能，验证用户是否登录
      */&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intercept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ActionInvocation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

      &lt;span class=&quot;nc&quot;&gt;UserInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;UserInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServletActionContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;user&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getPwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;login&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;UserInfo 类文件：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**

 * @author 维C果糖

 * @create 2017-03-31
   */&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getPwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setPwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pwd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4-配置拦截器&quot;&gt;4 配置拦截器&lt;/h4&gt;

&lt;p&gt;在前面，我们用了很大篇幅的内容讲述了拦截器如何实现，因此，我相信大家对于如何实现拦截器已经没有问题啦！接下来，我们在看看，如何在 XML 文件中配置拦截器，以使我们的拦截器生效。&lt;/p&gt;

&lt;p&gt;在配置拦截器之前，有 4 个名称的概念需要大家先了解一下，分别为：Join Point、Pointcut、Advice和Advisor：&lt;/p&gt;

&lt;p&gt;Join Point，表示“连接点”，它是程序运行中的某个阶段点，比如方法的调用、异常的抛出等；
Advice，表示“通知”，它是某个连接点所采用的处理逻辑，也就是向连接点注入的代码；
Pointcut，表示“切入点”，它是“连接点”的集合，是程序中需要注入Advice的位置的集合，指明Advice要在什么样的条件下才能被触发；
Advisor，它是Pointcut和Advice的配置器，包括Pointcut和Advice，是将Advice注入程序中Pointcut位置的代码。
接下来，给出 XML 配置文件的声明：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:context=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;xmlns:mvc=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans  
     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
     http://www.springframework.org/schema/context  
     http://www.springframework.org/schema/context/spring-context-3.0.xsd  
     http://www.springframework.org/schema/mvc  
     http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 XML 文件的头部声明完成之后，我们就可以在 Spring 的配置文件中使用mvc标签啦！而在mvc标签中有一个名为mvc:interceptors的标签，该标签就是用于声明 Spring 拦截器的。下面，给出一个配置示例：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:interceptors&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 使用 bean 定义一个 Interceptor，直接定义在 mvc:interceptors 下面的 Interceptor 将拦截所有的请求 --&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.hit.interceptor.WrongCodeInterceptor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:interceptor&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:mapping&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/demo/hello.do&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 定义在 mvc:interceptor 下面的 Interceptor，表示对特定的请求进行拦截 --&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.hit.interceptor.LoginInterceptor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mvc:interceptor&amp;gt;&lt;/span&gt;  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mvc:interceptors&amp;gt;&lt;/span&gt;  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 Spring 的XML 配置文件中，我们可以通过mvc:interceptors标签声明一系列的拦截器，例如：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:interceptors&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.hit.interceptor.ContextInterceptor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.hit.interceptor.LoginInterceptor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.hit.interceptor.WrongCodeInterceptor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mvc:interceptors&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如上所示，这些拦截器就构成了一个拦截器链，或者称之为拦截器栈。这些拦截器的执行顺序是按声明的先后顺序执行的，即：先声明的拦截器先执行，后声明的拦截器后执行。在mvc:interceptors标签下声明interceptor标签主要有两种方式：&lt;/p&gt;

&lt;p&gt;直接定义一个Interceptor实现类的bean对象，使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截；
使用mvc:interceptor标签进行声明，使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。
此外，由于拦截器是 AOP 编程思想的典型应用，也就意味着我们可以“切”到具体的“面”进行某些操作。例如，&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WrongCodeInterceptor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.hit.interceptor.WrongCodeInterceptor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;userName&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;user-module&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;loginInterceptor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.hit.interceptor.LoginInterceptor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;excludePackages&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	   &lt;span class=&quot;nt&quot;&gt;&amp;lt;list&amp;gt;&lt;/span&gt;
		  &lt;span class=&quot;nt&quot;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;com.hit.user.exception&lt;span class=&quot;nt&quot;&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
		  &lt;span class=&quot;nt&quot;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;com.hit.order.exception&lt;span class=&quot;nt&quot;&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
	   &lt;span class=&quot;nt&quot;&gt;&amp;lt;/list&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;aop:config&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;aop:advisor&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;advice-ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WrongCodeInterceptor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pointcut=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;execution(* com.hit.*.demo..*.*(..)) &quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;aop:advisor&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;advice-ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;loginInterceptor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;pointcut=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;execution(* com.hit.*.demo..*.*(..))&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/aop:config&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如上所示，我们实现了切入到“面”进行特定的拦截功能，其中pointcut表示“切入点”，advisor表示要注入到pointcut的代码。实际上，如果在多个拦截器配置中，pointcut表达式都相同，我们可以将其抽取出来，单独声明，然后通过pointcut-ref标签进行引用，这样可以稍微简化一些配置！&lt;/p&gt;

&lt;p&gt;除此之外，大家可能会对pointcut中的*符号有所疑惑，它是“通配符”，表示可以匹配该位置上的任何名称。当然，如果我们要想使用aop标签，就得先在配置文件中进行声明啦！最后，如果大家想进一步了解切入点pointcut表达式的话，可以参考博文「Spring 框架中切入点 pointcut 表达式的常用写法 」。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">1 前言 网络上关于Interceptor的文章，但感觉内容都大同小异，而且知识点零零散散，不太方便阅读。 因此，整理一篇关于拦截器的文章，在此分享给大家，以供大家参考阅读。 2 拦截器 2.1 概念 Java 里的拦截器是动态拦截action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在 AOP（Aspect-Oriented Programming，面向切面编程）中拦截器用于在某个方法（包括构造器）或字段被访问之前进行拦截，然后在之前或之后加入某些操作。特别地，现阶段 Spring 自身仅支持基于方法的拦截操作！如果基于方法的拦截操作不能满足需求，可以使用 AspectJ 与 Spring 进行集成，以实现更细粒度或更多方面的拦截操作。 2.2 原理 拦截器Interceptor的拦截功能是基于 Java 的动态代理来实现的，具体可以参考博文「用 Java 实现拦截器 Interceptor 的拦截功能 」，也可以通过阅读 Spring 源代码来了解更为权威的实现细节。 3 实现方法 在 Spring 框架之中，我们要想实现拦截器的功能，主要通过两种途径，第一种是实现HandlerInterceptor接口，第二种是实现WebRequestInterceptor接口。接下来，我们分别详细的介绍两者的实现方法。 3.1 HandlerInterceptor 接口 在HandlerInterceptor接口中，定义了 3 个方法，分别为preHandle()、postHandle()和afterCompletion()，我们就是通过复写这 3 个方法来对用户的请求进行拦截处理的。因此，我们可以通过直接实现HandlerInterceptor接口来实现拦截器的功能。不过在 Spring 框架之中，其还提供了另外一个接口和一个抽象类，实现了对HandlerInterceptor接口的功能扩展，分别为：AsyncHandlerInterceptor和HandlerInterceptorAdapter. 对于AsyncHandlerInterceptor接口，其在继承HandlerInterceptor接口的同时，又声明了一个新的方法afterConcurrentHandlingStarted()；而HandlerInterceptorAdapter抽象类，则是更进一步，在其继承AsyncHandlerInterceptor接口的同时，又复写了preHandle方法。因此，AsyncHandlerInterceptor更像是一个过渡的接口。 在实际应用中，我们一般都是通过实现HandlerInterceptor接口或者继承HandlerInterceptorAdapter抽象类，复写preHandle()、postHandle()和afterCompletion()这 3 个方法来对用户的请求进行拦截处理的。下面，我们就详细介绍这个 3 个方法。 preHandle(HttpServletRequest request, HttpServletResponse response, Object handle) 方法，该方法在请求处理之前进行调用。Spring MVC 中的Interceptor是链式调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor。每个Interceptor的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor中的preHandle方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求做一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔（Boolean）类型的，当它返回为false时，表示请求结束，后续的Interceptor和控制器（Controller）都不会再执行；当返回值为true时，就会继续调用下一个Interceptor的preHandle方法，如果已经是最后一个Interceptor的时候，就会是调用当前请求的控制器中的方法。 postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)方法，通过preHandle方法的解释，我们知道这个方法包括后面要说到的afterCompletion方法都只能在当前所属的Interceptor的preHandle方法的返回值为true的时候，才能被调用。postHandle方法在当前请求进行处理之后，也就是在控制器中的方法调用之后执行，但是它会在DispatcherServlet进行视图返回渲染之前被调用，所以我们可以在这个方法中对控制器处理之后的ModelAndView对象进行操作。postHandle方法被调用的方向跟preHandle是相反的，也就是说，先声明的Interceptor的postHandle方法反而会后执行。这和 Struts2 里面的Interceptor的执行过程有点类似，Struts2 里面的Interceptor的执行过程也是链式的，只是在 Struts2 里面需要手动调用ActionInvocation的invoke方法来触发对下一个Interceptor或者是action的调用，然后每一个Interceptor中在invoke方法调用之前的内容都是按照声明顺序执行的，而invoke方法之后的内容就是反向的。 afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)方法，也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。因此，该方法将在整个请求结束之后，也就是在DispatcherServlet渲染了对应的视图之后执行，这个方法的主要作用是用于进行资源清理的工作。 接下来，我们在看看以上接口和抽象类的具体代码： HandlerInterceptor 接口： package org.springframework.web.servlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public interface HandlerInterceptor { boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception; void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; } AsyncHandlerInterceptor 接口： package org.springframework.web.servlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public interface AsyncHandlerInterceptor extends HandlerInterceptor { void afterConcurrentHandlingStarted( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; } HandlerInterceptorAdapter 抽象类： package org.springframework.web.servlet.handler; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.AsyncHandlerInterceptor; import org.springframework.web.servlet.ModelAndView; /** * Abstract adapter class for the HandlerInterceptor interface, * for simplified implementation of pre-only/post-only interceptors. * * @author Juergen Hoeller * @since 05.12.2003 */ public abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor { /** * This implementation always returns {@code true}. */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return true; } /** * This implementation is empty. */ public void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } /** * This implementation is empty. */ public void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } /** * This implementation is empty. */ public void afterConcurrentHandlingStarted( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { } } 如上面的代码所示，其实在HandlerInterceptor和AsyncHandlerInterceptor中还有很多的代码注释，只是博主感觉太多了，就将其全部删除了。如果大家对这些注释感兴趣的话，可以自行查看源代码。下面，我们以继承HandlerInterceptorAdapter抽象类为例进行演示： package com.hit.interceptor; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @author 维C果糖 * @create 2017-03-31 */ public class WrongCodeInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;WrongCodeInterceptor, preHandle......&quot;); return true; } @Override public void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;WrongCodeInterceptor, postHandle......&quot;); } @Override public void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;WrongCodeInterceptor, afterCompletion......&quot;); } @Override public void afterConcurrentHandlingStarted( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;WrongCodeInterceptor, afterConcurrentHandlingStarted......&quot;); } } 3.2 WebRequestInterceptor 接口 在WebRequestInterceptor接口中也定义了 3 个方法，同HandlerInterceptor接口完全相同，我们也是通过复写这 3 个方法来对用户的请求进行拦截处理的。而且这 3 个方法都传递了同一个参数WebRequest，那么这个WebRequest到底是什么呢？其实这个WebRequest是 Spring 中定义的一个接口，它里面的方法定义跟HttpServletRequest类似，在WebRequestInterceptor中对WebRequest进行的所有操作都将同步到HttpServletRequest中，然后在当前请求中依次传递。 在 Spring 框架之中，还提供了一个和WebRequestInterceptor接口长的很像的抽象类，那就是：WebRequestInterceptorAdapter，其实现了AsyncHandlerInterceptor接口，并在内部调用了WebRequestInterceptor接口。 接下来，我们主要讲一下WebRequestInterceptor接口的 3 个函数： preHandle(WebRequest request)方法，该方法在请求处理之前进行调用，也就是说，其会在控制器中的方法调用之前被调用。这个方法跟HandlerInterceptor中的preHandle不同，主要区别在于该方法的返回值是void类型的，也就是没有返回值，因此我们主要用它来进行资源的准备工作，比如我们在使用 Hibernate 的时候，可以在这个方法中准备一个 Hibernate 的Session对象，然后利用WebRequest的setAttribute(name, value, scope)把它放到WebRequest的属性中。在这里，进一步说说setAttribute方法的第三个参数scope，该参数是一个Integer类型的。在WebRequest的父层接口RequestAttributes中对它定义了三个常量，分别为： SCOPE_REQUEST，它的值是0，表示只有在request中可以访问。 SCOPE_SESSION，它的值是1，如果环境允许的话，它表示的是一个局部的隔离的session，否则就代表普通的session，并且在该session范围内可以访问。 SCOPE_GLOBAL_SESSION，它的值是2，如果环境允许的话，它表示的是一个全局共享的session，否则就代表普通的session，并且在该session范围内可以访问。 postHandle(WebRequest request, ModelMap model)方法，该方法在请求处理之后，也就是在控制器中的方法调用之后被调用，但是会在视图返回被渲染之前被调用，所以可以在这个方法里面通过改变数据模型ModelMap来改变数据的展示。该方法有两个参数，WebRequest对象是用于传递整个请求数据的，比如在preHandle中准备的数据都可以通过WebRequest来传递和访问；ModelMap就是控制器处理之后返回的Model对象，我们可以通过改变它的属性来改变返回的Model模型。 afterCompletion(WebRequest request, Exception ex)方法，该方法会在整个请求处理完成，也就是在视图返回并被渲染之后执行。因此可以在该方法中进行资源的释放操作。而WebRequest参数就可以把我们在preHandle中准备的资源传递到这里进行释放。Exception参数表示的是当前请求的异常对象，如果在控制器中抛出的异常已经被 Spring 的异常处理器给处理了的话，那么这个异常对象就是是null。 接下来，我们在看看以上接口和抽象类的具体代码： WebRequestInterceptor 接口： package org.springframework.web.context.request; import org.springframework.ui.ModelMap; public interface WebRequestInterceptor { void preHandle(WebRequest request) throws Exception; void postHandle(WebRequest request, ModelMap model) throws Exception; void afterCompletion(WebRequest request, Exception ex) throws Exception; } WebRequestInterceptorAdapter 抽象类： package org.springframework.web.servlet.handler; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.util.Assert; import org.springframework.web.context.request.AsyncWebRequestInterceptor; import org.springframework.web.context.request.WebRequestInterceptor; import org.springframework.web.servlet.AsyncHandlerInterceptor; import org.springframework.web.servlet.ModelAndView; /** * Adapter that implements the Servlet HandlerInterceptor interface * and wraps an underlying WebRequestInterceptor. * * @author Juergen Hoeller * @since 2.0 * @see org.springframework.web.context.request.WebRequestInterceptor * @see org.springframework.web.servlet.HandlerInterceptor */ public class WebRequestHandlerInterceptorAdapter implements AsyncHandlerInterceptor { private final WebRequestInterceptor requestInterceptor; /** * Create a new WebRequestHandlerInterceptorAdapter for the given WebRequestInterceptor. * @param requestInterceptor the WebRequestInterceptor to wrap */ public WebRequestHandlerInterceptorAdapter(WebRequestInterceptor requestInterceptor) { Assert.notNull(requestInterceptor, &quot;WebRequestInterceptor must not be null&quot;); this.requestInterceptor = requestInterceptor; } public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { this.requestInterceptor.preHandle(new DispatcherServletWebRequest(request, response)); return true; } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { this.requestInterceptor.postHandle(new DispatcherServletWebRequest(request, response), (modelAndView != null &amp;amp;&amp;amp; !modelAndView.wasCleared() ? modelAndView.getModelMap() : null)); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { this.requestInterceptor.afterCompletion(new DispatcherServletWebRequest(request, response), ex); } public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) { if (this.requestInterceptor instanceof AsyncWebRequestInterceptor) { AsyncWebRequestInterceptor asyncInterceptor = (AsyncWebRequestInterceptor) this.requestInterceptor; DispatcherServletWebRequest webRequest = new DispatcherServletWebRequest(request, response); asyncInterceptor.afterConcurrentHandlingStarted(webRequest); } } } 如上面的代码所示，展示了WebRequestInterceptor接口和WebRequestInterceptorAdapter抽象类的源码。下面，我们以实现WebRequestInterceptor接口为例进行演示： package com.hit.interceptor; import org.springframework.ui.ModelMap; import org.springframework.web.context.request.WebRequest; import org.springframework.web.context.request.WebRequestInterceptor; /** * @author 维C果糖 * @create 2017-03-31 */ public class WrongCodeInterceptor implements WebRequestInterceptor { @Override public void preHandle(WebRequest request) throws Exception { System.out.println(&quot;WrongCodeInterceptor, preHandle......&quot;); } @Override public void postHandle(WebRequest request, ModelMap model) throws Exception { System.out.println(&quot;WrongCodeInterceptor, postHandle......&quot;); } @Override public void afterCompletion(WebRequest request, Exception ex) throws Exception { System.out.println(&quot;WrongCodeInterceptor, afterCompletion......&quot;); } } 3.3 AbstractInterceptor 抽象类 除了上面3.2 和3.3所讲的内容，我们还可以通过继承 Struts2 框架提供的AbstractInterceptor抽象类来实现拦截的功能。如果我们在深入一点研究，会发现AbstractInterceptor实现了Interceptor接口，而Interceptor接口又继承了Serializable接口。 在Interceptor接口中，提供了 3 个方法供我们使用，分别为init()、destroy()和intercept()，由于AbstractInterceptor实现了Interceptor接口，因此我们就可以直接继承AbstractInterceptor，然后复写方法就可以啦！至于为什么继承AbstractInterceptor而不是直接实现Interceptor接口，是因为AbstractInterceptor已经帮我们实现了空的init()和destroy()方法，不需要我们自己去复写了，我们直接复写intercept()方法就可以了。现在，我们大致了解一下这 3 个方法的作用： init()方法，一般用来进行初始化操作； destroy()方法，一般用来进行释放资源的操作； intercept()方法，该方法是实现拦截功能的主要方法，我们就在该方法中编写拦截的逻辑。 接下来，我们再看看以上接口和抽象类的具体代码： Interceptor 接口： package com.opensymphony.xwork2.interceptor; import com.opensymphony.xwork2.ActionInvocation; import java.io.Serializable; public interface Interceptor extends Serializable { /** * Called to let an interceptor clean up any resources it has allocated. */ void destroy(); /** * Called after an interceptor is created, but before any requests are processed using * {@link #intercept(com.opensymphony.xwork2.ActionInvocation) intercept} , giving * the Interceptor a chance to initialize any needed resources. */ void init(); /** * Allows the Interceptor to do some processing on the request before and/or after the rest of the processing of the * request by the {@link ActionInvocation} or to short-circuit the processing and just return a String return code. * * @param invocation the action invocation * @return the return code, either returned from {@link ActionInvocation#invoke()}, or from the interceptor itself. * @throws Exception any system-level error, as defined in {@link com.opensymphony.xwork2.Action#execute()}. */ String intercept(ActionInvocation invocation) throws Exception; } AbstractInterceptor 接口： package com.opensymphony.xwork2.interceptor; import com.opensymphony.xwork2.ActionInvocation; /** * Provides default implementations of optional lifecycle methods */ public abstract class AbstractInterceptor implements Interceptor { /** * Does nothing */ public void init() { } /** * Does nothing */ public void destroy() { } /** * Override to handle interception */ public abstract String intercept(ActionInvocation invocation) throws Exception; } 如上面的代码所示，展示了Interceptor接口和AbstractInterceptor抽象类的源码。下面，我们以继承AbstractInterceptor抽象类为例进行演示： package com.hit.interceptor; import com.opensymphony.xwork2.ActionInvocation; import com.opensymphony.xwork2.interceptor.AbstractInterceptor; import org.apache.struts2.ServletActionContext; /** * @author 维C果糖 * @create 2017-03-31 */ public class WrongCodeInterceptor extends AbstractInterceptor { /** * 通过拦截功能，验证用户是否登录 */ public String intercept(ActionInvocation invocation) throws Exception { UserInfo info = (UserInfo) ServletActionContext.getRequest().getSession().getAttribute(&quot;user&quot;); if(info != null &amp;amp;&amp;amp; !info.getName().equals(&quot;&quot;) &amp;amp;&amp;amp; !info.getPwd().equals(&quot;&quot;)) { return invocation.invoke(); } return &quot;login&quot;; } } UserInfo 类文件： /** * @author 维C果糖 * @create 2017-03-31 */ public class UserInfo { String name; String pwd; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } } 4 配置拦截器 在前面，我们用了很大篇幅的内容讲述了拦截器如何实现，因此，我相信大家对于如何实现拦截器已经没有问题啦！接下来，我们在看看，如何在 XML 文件中配置拦截器，以使我们的拦截器生效。 在配置拦截器之前，有 4 个名称的概念需要大家先了解一下，分别为：Join Point、Pointcut、Advice和Advisor： Join Point，表示“连接点”，它是程序运行中的某个阶段点，比如方法的调用、异常的抛出等； Advice，表示“通知”，它是某个连接点所采用的处理逻辑，也就是向连接点注入的代码； Pointcut，表示“切入点”，它是“连接点”的集合，是程序中需要注入Advice的位置的集合，指明Advice要在什么样的条件下才能被触发； Advisor，它是Pointcut和Advice的配置器，包括Pointcut和Advice，是将Advice注入程序中Pointcut位置的代码。 接下来，给出 XML 配置文件的声明： &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&amp;gt; 在 XML 文件的头部声明完成之后，我们就可以在 Spring 的配置文件中使用mvc标签啦！而在mvc标签中有一个名为mvc:interceptors的标签，该标签就是用于声明 Spring 拦截器的。下面，给出一个配置示例： &amp;lt;mvc:interceptors&amp;gt; &amp;lt;!-- 使用 bean 定义一个 Interceptor，直接定义在 mvc:interceptors 下面的 Interceptor 将拦截所有的请求 --&amp;gt; &amp;lt;bean class=&quot;com.hit.interceptor.WrongCodeInterceptor&quot;/&amp;gt; &amp;lt;mvc:interceptor&amp;gt; &amp;lt;mvc:mapping path=&quot;/demo/hello.do&quot;/&amp;gt; &amp;lt;!-- 定义在 mvc:interceptor 下面的 Interceptor，表示对特定的请求进行拦截 --&amp;gt; &amp;lt;bean class=&quot;com.hit.interceptor.LoginInterceptor&quot;/&amp;gt; &amp;lt;/mvc:interceptor&amp;gt; &amp;lt;/mvc:interceptors&amp;gt; 在 Spring 的XML 配置文件中，我们可以通过mvc:interceptors标签声明一系列的拦截器，例如： &amp;lt;mvc:interceptors&amp;gt; &amp;lt;bean class=&quot;com.hit.interceptor.ContextInterceptor&quot;/&amp;gt; &amp;lt;bean class=&quot;com.hit.interceptor.LoginInterceptor&quot;/&amp;gt; &amp;lt;bean class=&quot;com.hit.interceptor.WrongCodeInterceptor&quot;/&amp;gt; &amp;lt;/mvc:interceptors&amp;gt; 如上所示，这些拦截器就构成了一个拦截器链，或者称之为拦截器栈。这些拦截器的执行顺序是按声明的先后顺序执行的，即：先声明的拦截器先执行，后声明的拦截器后执行。在mvc:interceptors标签下声明interceptor标签主要有两种方式： 直接定义一个Interceptor实现类的bean对象，使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截； 使用mvc:interceptor标签进行声明，使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。 此外，由于拦截器是 AOP 编程思想的典型应用，也就意味着我们可以“切”到具体的“面”进行某些操作。例如， &amp;lt;bean id=&quot;WrongCodeInterceptor&quot; class=&quot;com.hit.interceptor.WrongCodeInterceptor&quot;&amp;gt; &amp;lt;property name=&quot;userName&quot; value=&quot;user-module&quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;loginInterceptor&quot; class=&quot;com.hit.interceptor.LoginInterceptor&quot;&amp;gt; &amp;lt;property name=&quot;excludePackages&quot;&amp;gt; &amp;lt;list&amp;gt; &amp;lt;value&amp;gt;com.hit.user.exception&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;com.hit.order.exception&amp;lt;/value&amp;gt; &amp;lt;/list&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;aop:config&amp;gt; &amp;lt;aop:advisor advice-ref=&quot;WrongCodeInterceptor&quot; pointcut=&quot;execution(* com.hit.*.demo..*.*(..)) &quot; /&amp;gt; &amp;lt;aop:advisor advice-ref=&quot;loginInterceptor&quot; pointcut=&quot;execution(* com.hit.*.demo..*.*(..))&quot; /&amp;gt; &amp;lt;/aop:config&amp;gt; 如上所示，我们实现了切入到“面”进行特定的拦截功能，其中pointcut表示“切入点”，advisor表示要注入到pointcut的代码。实际上，如果在多个拦截器配置中，pointcut表达式都相同，我们可以将其抽取出来，单独声明，然后通过pointcut-ref标签进行引用，这样可以稍微简化一些配置！ 除此之外，大家可能会对pointcut中的*符号有所疑惑，它是“通配符”，表示可以匹配该位置上的任何名称。当然，如果我们要想使用aop标签，就得先在配置文件中进行声明啦！最后，如果大家想进一步了解切入点pointcut表达式的话，可以参考博文「Spring 框架中切入点 pointcut 表达式的常用写法 」。</summary></entry><entry><title type="html">SpringBoot面试题（2）</title><link href="http://localhost:4000/mianshi/SpringBoot/0706" rel="alternate" type="text/html" title="SpringBoot面试题（2）" /><published>2020-07-06T00:00:00+08:00</published><updated>2020-07-06T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/SpringBoot/springboot%E9%9D%A2%E8%AF%95%E9%A2%982</id><content type="html" xml:base="http://localhost:4000/mianshi/SpringBoot/0706">&lt;h4 id=&quot;1什么是springboot&quot;&gt;1、什么是SpringBoot？&lt;/h4&gt;

&lt;p&gt;spring的开源子项目，简化spring开发难度，是spring的一站式解决方案&lt;/p&gt;

&lt;p&gt;springboot解决的问题&lt;/p&gt;

&lt;p&gt;1、使编码变得简单
2、使配置变得简单
3、使部署变得简单
4、使监控变得简单&lt;/p&gt;

&lt;h4 id=&quot;2springboot有什么特点&quot;&gt;2、SpringBoot有什么特点？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;提供了starter POM，能够非常方便的进行包管理&lt;/li&gt;
  &lt;li&gt;项目快速搭建。springboot帮助开发者快速搭建spring框架，可无需配置的自动整合第三方框架&lt;/li&gt;
  &lt;li&gt;可以完全不使用xml配置，只需要自动配置和Java config&lt;/li&gt;
  &lt;li&gt;对主流框架无配置集成&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3springboot的核心注解是哪个它主要由哪几个注解组成的&quot;&gt;3、SpringBoot的核心注解是哪个？它主要由哪几个注解组成的&lt;/h4&gt;

&lt;p&gt;@SpringBootApplication下的三个注解&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4springboot自动配置的原理是什么&quot;&gt;4、SpringBoot自动配置的原理是什么？&lt;/h4&gt;

&lt;p&gt;详细看一看注解 @EnableAutoConfiguration 源码&lt;/p&gt;

&lt;h4 id=&quot;5什么是yaml&quot;&gt;5、什么是YAML？&lt;/h4&gt;

&lt;p&gt;YAML是一种__数据序列化语言__，通常用于配置文件，例如application.yml。&lt;/p&gt;

&lt;h4 id=&quot;6yaml优势在哪里&quot;&gt;6、YAML优势在哪里？&lt;/h4&gt;

&lt;p&gt;（1）配置有序&lt;/p&gt;

&lt;p&gt;（2）树形结构，清晰明了&lt;/p&gt;

&lt;p&gt;（3）支持数组，数组中的元素可以是基本数据和对象&lt;/p&gt;

&lt;h4 id=&quot;7springboot是否可以使用xml配置-&quot;&gt;7、SpringBoot是否可以使用XML配置 ?&lt;/h4&gt;

&lt;p&gt;Spring Boot推荐使用Java配置，但是同样也可以使用XML配置。&lt;/p&gt;

&lt;h4 id=&quot;8spring-boot-核心配置文件是什么bootstrappeoperties和applicationproperties有何区别&quot;&gt;8、spring boot 核心配置文件是什么？bootstrap.peoperties和application.properties有何区别&lt;/h4&gt;

&lt;p&gt;spring boot核心配置文件是application.properties或者application.yml&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；&lt;/li&gt;
  &lt;li&gt;application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;9什么是spring-profiles&quot;&gt;9、什么是Spring Profiles？&lt;/h4&gt;

&lt;p&gt;Spring Profiles允许用户根据配置文件（dev，test，prod等）来注册bean。因此，当应用程序在开发中运行时，只有某些bean可以加载，而在PRODUCTION中，某些其他bean可以加载。假设我们的要求是Swagger文档仅适用于QA环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot使得使用配置文件非常简单&lt;/p&gt;

&lt;p&gt;在实际应用中，给中配置对于不同的环境&lt;/p&gt;

&lt;h4 id=&quot;10如何在自定义端口上运行spring-boot应用程序&quot;&gt;10、如何在自定义端口上运行Spring Boot应用程序&lt;/h4&gt;

&lt;p&gt;在配置文件中配置 port 为自定义端口&lt;/p&gt;

&lt;h4 id=&quot;11如何实现spring-boot应用程序的安全性&quot;&gt;11、如何实现Spring Boot应用程序的安全性？&lt;/h4&gt;

&lt;p&gt;spring可集合 spring security 或者shiro 作为安全组件，集成到程序中&lt;/p&gt;

&lt;p&gt;使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码，配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。&lt;/p&gt;

&lt;h4 id=&quot;12比较一下spring-security和shiro各自的优缺点&quot;&gt;12、比较一下Spring Security和Shiro各自的优缺点&lt;/h4&gt;

&lt;p&gt;由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架&lt;/li&gt;
  &lt;li&gt;Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单&lt;/li&gt;
  &lt;li&gt;Spring Security 功能强大；Shiro 功能简单&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;13spring-boot中如何解决跨域问题-&quot;&gt;13、Spring Boot中如何解决跨域问题 ?&lt;/h4&gt;

&lt;p&gt;跨域可以在前端通过JSONP来解决，但是JSONP只可以发送GET请求，无法发送其他类型的请求，在 RESTful风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过（CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非Spring Boot特有的，在传统的SSM框架中，就可以通过 CORS来解决跨域问题，只不过之前我们是在XML文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CorsConfig&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebMvcConfigurer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addCorsMappings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CorsRegistry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;registry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;registry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/**&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allowedOrigins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allowCredentials&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allowedMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GET&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;PUT&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;DELETE&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;OPTIONS&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;maxAge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3600&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;项目中前后端分离部署，所以需要解决跨域的问题。我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CorsConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CorsFilter&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;corsFilter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;CorsConfiguration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corsConfiguration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CorsConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;corsConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAllowedOrigin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;corsConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAllowedHeader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;corsConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAllowedMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;corsConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAllowCredentials&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;UrlBasedCorsConfigurationSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urlBasedCorsConfigurationSource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UrlBasedCorsConfigurationSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;urlBasedCorsConfigurationSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;registerCorsConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/**&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corsConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CorsFilter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urlBasedCorsConfigurationSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;14什么是csrf攻击&quot;&gt;14、什么是CSRF攻击？&lt;/h4&gt;

&lt;p&gt;跨站请求伪&lt;/p&gt;

&lt;h4 id=&quot;15spring-boot中的监视器是什么&quot;&gt;15、Spring Boot中的监视器是什么？&lt;/h4&gt;

&lt;p&gt;Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。&lt;/p&gt;

&lt;h4 id=&quot;16如何在spring-boot中禁用actuator端点安全性&quot;&gt;16、如何在Spring Boot中禁用Actuator端点安全性？&lt;/h4&gt;

&lt;p&gt;默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。&lt;strong&gt;安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的&lt;/strong&gt;。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。&lt;/p&gt;

&lt;h4 id=&quot;17我们如何监视所有spring-boot微服务&quot;&gt;17、我们如何监视所有Spring Boot微服务？&lt;/h4&gt;

&lt;p&gt;Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。&lt;strong&gt;想象一下涉及 50 个应用程序的微服务&lt;/strong&gt;，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量&lt;/p&gt;

&lt;h4 id=&quot;18什么是websockets&quot;&gt;18、什么是WebSockets？&lt;/h4&gt;

&lt;p&gt;WebSocket是一种__计算机通信协议__，通过单个TCP连接提供全双工通信信道。&lt;/p&gt;

&lt;p&gt;1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。&lt;/p&gt;

&lt;p&gt;2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。&lt;/p&gt;

&lt;p&gt;3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信。&lt;/p&gt;

&lt;p&gt;4、Light -与 http 相比，WebSocket 消息数据交换要轻得多&lt;/p&gt;

&lt;h4 id=&quot;19什么是spring-data-&quot;&gt;19、什么是Spring Data ?&lt;/h4&gt;

&lt;p&gt;Spring Data是Spring的一个子项目，用于__简化数据库访问__，支持NoSQL和关系数据存储，其主要目标是使数据库的访问变得方便快捷。Spring Data具有如下特点：&lt;/p&gt;

&lt;p&gt;SpringData项目支持NoSQL存储：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MongoDB （文档数据库）&lt;/li&gt;
  &lt;li&gt;Neo4j（图形数据库）&lt;/li&gt;
  &lt;li&gt;Redis（键/值存储）&lt;/li&gt;
  &lt;li&gt;Hbase（列族数据库）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;SpringData项目所支持的关系数据存储技术：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;JDBC&lt;/li&gt;
  &lt;li&gt;JPA&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring Data Jpa致力于减少数据访问层(DAO)的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给Spring Data JPA来帮你完成！Spring Data JPA通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。&lt;/p&gt;

&lt;h4 id=&quot;20什么是spring-batch&quot;&gt;20、什么是Spring Batch？&lt;/h4&gt;

&lt;p&gt;Spring Boot Batch__提供可重用的函数__，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，&lt;strong&gt;通过优化和分区技术，可以实现极高批量和高性能批处理作业&lt;/strong&gt;。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。&lt;/p&gt;

&lt;h4 id=&quot;21什么是freemarker模板&quot;&gt;21、什么是FreeMarker模板？&lt;/h4&gt;

&lt;p&gt;FreeMarker是一个__基于Java的模板引擎__，最初专注于使用MVC软件架构进行动态网页生成。使用 Freemarker的__主要优点是表示层和业务层的完全分离__。程序员可以处理应用程序代码，而设计人员可以处理html页面设计。最后使用freemarker可以将这些结合起来，给出最终的输出页面。&lt;/p&gt;

&lt;h4 id=&quot;22如何集成spring-boot和activemq&quot;&gt;22、如何集成Spring Boot和ActiveMQ？&lt;/h4&gt;

&lt;p&gt;maven配置 ActiveMQ&lt;/p&gt;

&lt;h4 id=&quot;23什么是apache-kafka&quot;&gt;23、什么是Apache Kafka？&lt;/h4&gt;

&lt;p&gt;Apache Kafka是一个__分布式发布 - 订阅消息系统__。它是一个__可扩展的，容错的发布 - 订阅消息系统__，它使我们能够构建分布式应用程序。这是一个Apache顶级项目。Kafka适合离线和在线消息消费。&lt;/p&gt;

&lt;h4 id=&quot;24什么是-swagger你用spring-boot实现了它吗&quot;&gt;24、什么是 Swagger？你用Spring Boot实现了它吗？&lt;/h4&gt;

&lt;p&gt;Swagger广泛用于__可视化API__，&lt;strong&gt;使用Swagger UI为前端开发人员提供在线沙箱&lt;/strong&gt;。&lt;strong&gt;Swagger是用于生成 RESTful Web服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新&lt;/strong&gt;。当通过Swagger正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。&lt;/p&gt;

&lt;h4 id=&quot;25前后端分离如何维护接口文档-&quot;&gt;25、前后端分离，如何维护接口文档 ?&lt;/h4&gt;

&lt;p&gt;统一的接口规范，手写&lt;/p&gt;

&lt;p&gt;使用第三方框架，自动或者半自动编辑&lt;/p&gt;

&lt;h4 id=&quot;26如何重新加载spring-boot上的更改而无需重新启动服务项目如何热部署&quot;&gt;26、如何重新加载Spring Boot上的更改，而无需重新启动服务，项目如何热部署&lt;/h4&gt;

&lt;p&gt;spring-detools&lt;/p&gt;

&lt;h4 id=&quot;27spring-boot-中的-starter到底是什么&quot;&gt;27、Spring Boot 中的 starter到底是什么&lt;/h4&gt;

&lt;p&gt;首先，这个Starter并非什么新的技术点，基本上还是基于Spring已有功能来实现的。首先它__提供了一个自动化配置类，一般命名为XXXAutoConfiguration __，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义Starter。&lt;/p&gt;

&lt;h4 id=&quot;28spring-boot-starter-parent有什么用&quot;&gt;28、spring-boot-starter-parent有什么用？&lt;/h4&gt;

&lt;p&gt;我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：&lt;/p&gt;

&lt;p&gt;1、定义了 Java 编译版本为 1.8 。
2、使用 UTF-8 格式编码。
3、继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所4、以我们在写依赖时才不需要写版本号。
5、执行打包操作的配置。
6、自动化的资源过滤。
7、自动化的插件配置。
8、针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配 置文件，例如 application-dev.properties 和 application-dev.yml。&lt;/p&gt;

&lt;h4 id=&quot;29spring-boot打成的jar和普通的jar有什么区别&quot;&gt;29、Spring Boot打成的jar和普通的jar有什么区别&lt;/h4&gt;

&lt;p&gt;Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，&lt;strong&gt;即使依赖了也无法使用其中的类&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。&lt;strong&gt;如果非要引用，可以在 pom.xml 文件中增加配置&lt;/strong&gt;，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。&lt;/p&gt;

&lt;h4 id=&quot;30运行spring-boot有哪几种方式&quot;&gt;30、运行Spring Boot有哪几种方式？&lt;/h4&gt;

&lt;p&gt;1）直接运行main文件&lt;/p&gt;

&lt;p&gt;2）打包用命令或放到容器中运行&lt;/p&gt;

&lt;p&gt;3）用Maven/Gradle插件运行&lt;/p&gt;

&lt;h4 id=&quot;31spring-boot需要独立的容器运行吗&quot;&gt;31、Spring Boot需要独立的容器运行吗？&lt;/h4&gt;

&lt;p&gt;可以不需要，因为Spring Boot有内嵌服务器tomcat&lt;/p&gt;

&lt;h4 id=&quot;32开启spring-boot特性有哪几种方式&quot;&gt;32、开启Spring Boot特性有哪几种方式？&lt;/h4&gt;

&lt;p&gt;1）继承spring-boot-starter-parent项目&lt;/p&gt;

&lt;p&gt;2）导入spring-boot-dependencies项目依赖&lt;/p&gt;

&lt;h4 id=&quot;33如何使用spring-boot实现异常处理&quot;&gt;33、如何使用Spring Boot实现异常处理？&lt;/h4&gt;

&lt;p&gt;Spring提供了一种使用__ControllerAdvice__处理异常的非常有用的方法。我们通过实现一个 ControlerAdvice类，来处理控制器类抛出的所有异常。&lt;/p&gt;

&lt;h4 id=&quot;34如何使用-spring-boot-实现分页和排序&quot;&gt;34、如何使用 Spring Boot 实现分页和排序&lt;/h4&gt;

&lt;p&gt;spirng-data-jpa，或者使用第三方插件，自己实现&lt;/p&gt;

&lt;h4 id=&quot;35微服务中如何实现session共享&quot;&gt;35、微服务中如何实现session共享&lt;/h4&gt;

&lt;p&gt;在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的session被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享session，常见的方案就是Spring Session + Redis来实现session共享。将所有微服务的session统一保存在Redis 上，当各个微服务对session有相关的读写操作时，都去操作Redis上的session 。这样就实现了session 共享，Spring Session基于Spring中的代理过滤器实现，使得session的同步操作对开发人员而言是透明的，非常简便。&lt;/p&gt;

&lt;h4 id=&quot;36spring-boot中如何实现定时任务&quot;&gt;36、Spring Boot中如何实现定时任务&lt;/h4&gt;

&lt;p&gt;定时任务也是一个常见的需求，Spring Boot中对于定时任务的支持主要还是来自Spring框架。在Spring Boot中使用定时任务主要有两种不同的方式，&lt;strong&gt;一个就是使用Spring中的@Scheduled注解&lt;/strong&gt;，&lt;strong&gt;另一个则是使用第三方框架Quartz&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;37springboot的-actuator-是做什么的&quot;&gt;37、SpringBoot的 Actuator 是做什么的？&lt;/h4&gt;

&lt;p&gt;本质上，Actuator 通过启用 production-ready 功能使得 SpringBoot 应用程序变得更有生命力。这些功能允许我们对生产环境中的应用程序进行监视和管理。&lt;/p&gt;

&lt;p&gt;集成 SpringBoot Actuator 到项目中非常简单。我们需要做的只是将 &lt;em&gt;spring-boot-starter-actuator&lt;/em&gt; starter 引入到 POM.xml 文件当中：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 &amp;lt;dependency&amp;gt;
2     &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
3     &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
4 &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;SpringBoot Actuaor 可以使用 HTTP 或者 JMX endpoints来浏览操作信息。大多数应用程序都是用 HTTP，作为 endpoint 的标识以及使用 &lt;em&gt;/actuator&lt;/em&gt; 前缀作为 URL路径。&lt;/p&gt;

&lt;p&gt;这里有一些常用的内置 endpoints Actuator：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;auditevents&lt;/em&gt;：查看 audit 事件信息&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;env&lt;/em&gt;：查看 环境变量&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;health&lt;/em&gt;：查看应用程序健康信息&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;httptrace&lt;/em&gt;：展示 HTTP 路径信息&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;info&lt;/em&gt;：展示 &lt;em&gt;arbitrary&lt;/em&gt; 应用信息&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;metrics&lt;/em&gt;：展示 metrics 信息&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;loggers&lt;/em&gt;：显示并修改应用程序中日志器的配置&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;mappings&lt;/em&gt;：展示所有 &lt;em&gt;@RequestMapping&lt;/em&gt; 路径信息&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;scheduledtasks&lt;/em&gt;：展示应用程序中的定时任务信息&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;threaddump&lt;/em&gt;：执行 &lt;em&gt;Thread Dump&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;38怎么编写一个集成测试&quot;&gt;38、怎么编写一个集成测试？&lt;/h4&gt;

&lt;p&gt;当我们使用 Spring 应用去跑一个集成测试时，我们需要一个 &lt;em&gt;ApplicationContext&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;为了使我们开发更简单，SpringBoot 为测试提供一个注解 – &lt;em&gt;@SpringBootTest&lt;/em&gt;。这个注释由其 classes 属性指示的配置类创建一个 &lt;em&gt;ApplicationContext&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果没有配置 classes 属性，SpringBoot 将会搜索主配置类&lt;/strong&gt;。搜索会从包含测试类的包开始直到找到一个使用 &lt;em&gt;@SpringBootApplication&lt;/em&gt; 或者 &lt;em&gt;@SpringBootConfiguration&lt;/em&gt; 的类为止。&lt;/p&gt;

&lt;p&gt;注意如果使用 JUnit4，我们必须使用 &lt;em&gt;@RunWith(SpringRunner.class)&lt;/em&gt; 来修饰这个测试类。&lt;/p&gt;

&lt;h4 id=&quot;38springboot-支持松绑定代表什么&quot;&gt;38、SpringBoot 支持松绑定代表什么&lt;/h4&gt;

&lt;p&gt;SpringBoot中的松绑定适用于配置属性的类型安全绑定。使用松绑定，环境属性的键不需要与属性名完全匹配。这样就可以用驼峰式、短横线式、蛇形式或者下划线分割来命名。&lt;/p&gt;

&lt;p&gt;例如，在一个有 &lt;em&gt;@ConfigurationProperties&lt;/em&gt; 声明的 bean 类中带有一个名为 &lt;em&gt;myProp&lt;/em&gt; 的属性，它可以绑定到以下任何一个参数中，&lt;em&gt;myProp&lt;/em&gt;、 &lt;em&gt;my-prop&lt;/em&gt;、&lt;em&gt;my_prop&lt;/em&gt; 或者 &lt;em&gt;MY_PROP&lt;/em&gt;。&lt;/p&gt;

&lt;h4 id=&quot;39怎么将-springboot-web-应用程序部署为-jar-或-war-文件&quot;&gt;39、怎么将 SpringBoot web 应用程序部署为 JAR 或 WAR 文件？&lt;/h4&gt;

&lt;p&gt;通常，我们将 web 应用程序打包成 WAR 文件，然后将它部署到另外的服务器上。这样做使得我们能够在相同的服务器上处理多个项目。当 CPU 和内存有限的情况下，这是一种最好的方法来节省资源。&lt;/p&gt;

&lt;p&gt;然而，事情发生了转变。现在的计算机硬件相比起来已经很便宜了，并且现在的注意力大多转移到服务器配置上。部署中对服务器配置的一个细小的失误都会导致无可预料的灾难发生。&lt;/p&gt;

&lt;p&gt;Spring 通过提供插件来解决这个问题，也就是 &lt;em&gt;spring-boot-maven-plugin&lt;/em&gt; 来打包 web 应用程序到一个额外的 JAR 文件当中。为了引入这个插件，只需要在 &lt;em&gt;pom.xml&lt;/em&gt;中添加一个 &lt;em&gt;plugin&lt;/em&gt; 属性：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了这个插件，我们会在执行 &lt;em&gt;package&lt;/em&gt; 步骤后得到一个 JAR 包。这个 JAR 包包含所需的所有依赖以及一个嵌入的服务器。因此，我们不再需要担心去配置一个额外的服务器了。&lt;/p&gt;

&lt;p&gt;我们能够通过运行一个普通的 JAR 包来启动应用程序。&lt;/p&gt;

&lt;p&gt;注意一点，为了打包成 JAR 文件，&lt;em&gt;pom.xml&lt;/em&gt; 中的 &lt;em&gt;packgaing&lt;/em&gt; 属性必须定义为 &lt;em&gt;jar&lt;/em&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果我们不定义这个元素，它的默认值也为 &lt;em&gt;jar&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;如果我们想构建一个 WAR 文件，将 &lt;em&gt;packaging&lt;/em&gt; 元素修改为 &lt;em&gt;war&lt;/em&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;并且将容器依赖从打包文件中移除：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
  &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行 Maven 的 &lt;em&gt;package&lt;/em&gt; 步骤之后，我们得到一个可部署的 WAR 文件&lt;/p&gt;

&lt;h4 id=&quot;40当-bean-存在的时候怎么置后执行自动配置&quot;&gt;40、当 bean 存在的时候怎么置后执行自动配置？&lt;/h4&gt;

&lt;p&gt;为了当 bean 已存在的时候通知自动配置类置后执行，我们可以使用 &lt;em&gt;@ConditionalOnMissingBean&lt;/em&gt; 注解。这个注解中最值得注意的属性是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;value：被检查的 beans 的类型&lt;/li&gt;
  &lt;li&gt;name：被检查的 beans 的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当将 &lt;em&gt;@Bean&lt;/em&gt; 修饰到方法时，目标类型默认为方法的返回类型：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomConfiguration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;     &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;     &lt;span class=&quot;nd&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;     &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">1、什么是SpringBoot？ spring的开源子项目，简化spring开发难度，是spring的一站式解决方案 springboot解决的问题 1、使编码变得简单 2、使配置变得简单 3、使部署变得简单 4、使监控变得简单 2、SpringBoot有什么特点？ 提供了starter POM，能够非常方便的进行包管理 项目快速搭建。springboot帮助开发者快速搭建spring框架，可无需配置的自动整合第三方框架 可以完全不使用xml配置，只需要自动配置和Java config 对主流框架无配置集成 3、SpringBoot的核心注解是哪个？它主要由哪几个注解组成的 @SpringBootApplication下的三个注解 @SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan 4、SpringBoot自动配置的原理是什么？ 详细看一看注解 @EnableAutoConfiguration 源码 5、什么是YAML？ YAML是一种__数据序列化语言__，通常用于配置文件，例如application.yml。 6、YAML优势在哪里？ （1）配置有序 （2）树形结构，清晰明了 （3）支持数组，数组中的元素可以是基本数据和对象 7、SpringBoot是否可以使用XML配置 ? Spring Boot推荐使用Java配置，但是同样也可以使用XML配置。 8、spring boot 核心配置文件是什么？bootstrap.peoperties和application.properties有何区别 spring boot核心配置文件是application.properties或者application.yml bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖； application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。 9、什么是Spring Profiles？ Spring Profiles允许用户根据配置文件（dev，test，prod等）来注册bean。因此，当应用程序在开发中运行时，只有某些bean可以加载，而在PRODUCTION中，某些其他bean可以加载。假设我们的要求是Swagger文档仅适用于QA环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot使得使用配置文件非常简单 在实际应用中，给中配置对于不同的环境 10、如何在自定义端口上运行Spring Boot应用程序 在配置文件中配置 port 为自定义端口 11、如何实现Spring Boot应用程序的安全性？ spring可集合 spring security 或者shiro 作为安全组件，集成到程序中 使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码，配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。 12、比较一下Spring Security和Shiro各自的优缺点 由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点： Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架 Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单 Spring Security 功能强大；Shiro 功能简单 13、Spring Boot中如何解决跨域问题 ? 跨域可以在前端通过JSONP来解决，但是JSONP只可以发送GET请求，无法发送其他类型的请求，在 RESTful风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过（CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非Spring Boot特有的，在传统的SSM框架中，就可以通过 CORS来解决跨域问题，只不过之前我们是在XML文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。 @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) .maxAge(3600); } } 项目中前后端分离部署，所以需要解决跨域的问题。我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。 @Configuration public class CorsConfig { @Bean public CorsFilter corsFilter() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); corsConfiguration.setAllowCredentials(true); UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource(); urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); return new CorsFilter(urlBasedCorsConfigurationSource); } } 14、什么是CSRF攻击？ 跨站请求伪 15、Spring Boot中的监视器是什么？ Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。 16、如何在Spring Boot中禁用Actuator端点安全性？ 默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。 17、我们如何监视所有Spring Boot微服务？ Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量 18、什么是WebSockets？ WebSocket是一种__计算机通信协议__，通过单个TCP连接提供全双工通信信道。 1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。 2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。 3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信。 4、Light -与 http 相比，WebSocket 消息数据交换要轻得多 19、什么是Spring Data ? Spring Data是Spring的一个子项目，用于__简化数据库访问__，支持NoSQL和关系数据存储，其主要目标是使数据库的访问变得方便快捷。Spring Data具有如下特点： SpringData项目支持NoSQL存储： MongoDB （文档数据库） Neo4j（图形数据库） Redis（键/值存储） Hbase（列族数据库） SpringData项目所支持的关系数据存储技术： JDBC JPA Spring Data Jpa致力于减少数据访问层(DAO)的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给Spring Data JPA来帮你完成！Spring Data JPA通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。 20、什么是Spring Batch？ Spring Boot Batch__提供可重用的函数__，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。 21、什么是FreeMarker模板？ FreeMarker是一个__基于Java的模板引擎__，最初专注于使用MVC软件架构进行动态网页生成。使用 Freemarker的__主要优点是表示层和业务层的完全分离__。程序员可以处理应用程序代码，而设计人员可以处理html页面设计。最后使用freemarker可以将这些结合起来，给出最终的输出页面。 22、如何集成Spring Boot和ActiveMQ？ maven配置 ActiveMQ 23、什么是Apache Kafka？ Apache Kafka是一个__分布式发布 - 订阅消息系统__。它是一个__可扩展的，容错的发布 - 订阅消息系统__，它使我们能够构建分布式应用程序。这是一个Apache顶级项目。Kafka适合离线和在线消息消费。 24、什么是 Swagger？你用Spring Boot实现了它吗？ Swagger广泛用于__可视化API__，使用Swagger UI为前端开发人员提供在线沙箱。Swagger是用于生成 RESTful Web服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过Swagger正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。 25、前后端分离，如何维护接口文档 ? 统一的接口规范，手写 使用第三方框架，自动或者半自动编辑 26、如何重新加载Spring Boot上的更改，而无需重新启动服务，项目如何热部署 spring-detools 27、Spring Boot 中的 starter到底是什么 首先，这个Starter并非什么新的技术点，基本上还是基于Spring已有功能来实现的。首先它__提供了一个自动化配置类，一般命名为XXXAutoConfiguration __，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义Starter。 28、spring-boot-starter-parent有什么用？ 我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用： 1、定义了 Java 编译版本为 1.8 。 2、使用 UTF-8 格式编码。 3、继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所4、以我们在写依赖时才不需要写版本号。 5、执行打包操作的配置。 6、自动化的资源过滤。 7、自动化的插件配置。 8、针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配 置文件，例如 application-dev.properties 和 application-dev.yml。 29、Spring Boot打成的jar和普通的jar有什么区别 Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。 Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。 30、运行Spring Boot有哪几种方式？ 1）直接运行main文件 2）打包用命令或放到容器中运行 3）用Maven/Gradle插件运行 31、Spring Boot需要独立的容器运行吗？ 可以不需要，因为Spring Boot有内嵌服务器tomcat 32、开启Spring Boot特性有哪几种方式？ 1）继承spring-boot-starter-parent项目 2）导入spring-boot-dependencies项目依赖 33、如何使用Spring Boot实现异常处理？ Spring提供了一种使用__ControllerAdvice__处理异常的非常有用的方法。我们通过实现一个 ControlerAdvice类，来处理控制器类抛出的所有异常。 34、如何使用 Spring Boot 实现分页和排序 spirng-data-jpa，或者使用第三方插件，自己实现 35、微服务中如何实现session共享 在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的session被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享session，常见的方案就是Spring Session + Redis来实现session共享。将所有微服务的session统一保存在Redis 上，当各个微服务对session有相关的读写操作时，都去操作Redis上的session 。这样就实现了session 共享，Spring Session基于Spring中的代理过滤器实现，使得session的同步操作对开发人员而言是透明的，非常简便。 36、Spring Boot中如何实现定时任务 定时任务也是一个常见的需求，Spring Boot中对于定时任务的支持主要还是来自Spring框架。在Spring Boot中使用定时任务主要有两种不同的方式，一个就是使用Spring中的@Scheduled注解，另一个则是使用第三方框架Quartz。 37、SpringBoot的 Actuator 是做什么的？ 本质上，Actuator 通过启用 production-ready 功能使得 SpringBoot 应用程序变得更有生命力。这些功能允许我们对生产环境中的应用程序进行监视和管理。 集成 SpringBoot Actuator 到项目中非常简单。我们需要做的只是将 spring-boot-starter-actuator starter 引入到 POM.xml 文件当中： 1 &amp;lt;dependency&amp;gt; 2 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 3 &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; 4 &amp;lt;/dependency&amp;gt; SpringBoot Actuaor 可以使用 HTTP 或者 JMX endpoints来浏览操作信息。大多数应用程序都是用 HTTP，作为 endpoint 的标识以及使用 /actuator 前缀作为 URL路径。 这里有一些常用的内置 endpoints Actuator： auditevents：查看 audit 事件信息 env：查看 环境变量 health：查看应用程序健康信息 httptrace：展示 HTTP 路径信息 info：展示 arbitrary 应用信息 metrics：展示 metrics 信息 loggers：显示并修改应用程序中日志器的配置 mappings：展示所有 @RequestMapping 路径信息 scheduledtasks：展示应用程序中的定时任务信息 threaddump：执行 Thread Dump 38、怎么编写一个集成测试？ 当我们使用 Spring 应用去跑一个集成测试时，我们需要一个 ApplicationContext。 为了使我们开发更简单，SpringBoot 为测试提供一个注解 – @SpringBootTest。这个注释由其 classes 属性指示的配置类创建一个 ApplicationContext。 如果没有配置 classes 属性，SpringBoot 将会搜索主配置类。搜索会从包含测试类的包开始直到找到一个使用 @SpringBootApplication 或者 @SpringBootConfiguration 的类为止。 注意如果使用 JUnit4，我们必须使用 @RunWith(SpringRunner.class) 来修饰这个测试类。 38、SpringBoot 支持松绑定代表什么 SpringBoot中的松绑定适用于配置属性的类型安全绑定。使用松绑定，环境属性的键不需要与属性名完全匹配。这样就可以用驼峰式、短横线式、蛇形式或者下划线分割来命名。 例如，在一个有 @ConfigurationProperties 声明的 bean 类中带有一个名为 myProp 的属性，它可以绑定到以下任何一个参数中，myProp、 my-prop、my_prop 或者 MY_PROP。 39、怎么将 SpringBoot web 应用程序部署为 JAR 或 WAR 文件？ 通常，我们将 web 应用程序打包成 WAR 文件，然后将它部署到另外的服务器上。这样做使得我们能够在相同的服务器上处理多个项目。当 CPU 和内存有限的情况下，这是一种最好的方法来节省资源。 然而，事情发生了转变。现在的计算机硬件相比起来已经很便宜了，并且现在的注意力大多转移到服务器配置上。部署中对服务器配置的一个细小的失误都会导致无可预料的灾难发生。 Spring 通过提供插件来解决这个问题，也就是 spring-boot-maven-plugin 来打包 web 应用程序到一个额外的 JAR 文件当中。为了引入这个插件，只需要在 pom.xml中添加一个 plugin 属性： &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; 有了这个插件，我们会在执行 package 步骤后得到一个 JAR 包。这个 JAR 包包含所需的所有依赖以及一个嵌入的服务器。因此，我们不再需要担心去配置一个额外的服务器了。 我们能够通过运行一个普通的 JAR 包来启动应用程序。 注意一点，为了打包成 JAR 文件，pom.xml 中的 packgaing 属性必须定义为 jar： &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; 如果我们不定义这个元素，它的默认值也为 jar。 如果我们想构建一个 WAR 文件，将 packaging 元素修改为 war： &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; 并且将容器依赖从打包文件中移除： &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 执行 Maven 的 package 步骤之后，我们得到一个可部署的 WAR 文件 40、当 bean 存在的时候怎么置后执行自动配置？ 为了当 bean 已存在的时候通知自动配置类置后执行，我们可以使用 @ConditionalOnMissingBean 注解。这个注解中最值得注意的属性是： value：被检查的 beans 的类型 name：被检查的 beans 的名字 当将 @Bean 修饰到方法时，目标类型默认为方法的返回类型： 1 @Configuration 2 public class CustomConfiguration { 3 @Bean 4 @ConditionalOnMissingBean 5 public CustomService service() { ... } 6 }</summary></entry><entry><title type="html">Spring经典面试题和答案</title><link href="http://localhost:4000/mianshi/spring/0706/06" rel="alternate" type="text/html" title="Spring经典面试题和答案" /><published>2020-07-06T00:00:00+08:00</published><updated>2020-07-06T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/spring/0706/Spring%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E5%92%8C%E7%AD%94%E6%A1%88</id><content type="html" xml:base="http://localhost:4000/mianshi/spring/0706/06">&lt;p&gt;1、什么是spring?&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">1、什么是spring?</summary></entry><entry><title type="html">拦截器（Interceptor）和过滤器（Filter）的执行顺序和区别</title><link href="http://localhost:4000/mianshi/spring/0706/02" rel="alternate" type="text/html" title="拦截器（Interceptor）和过滤器（Filter）的执行顺序和区别" /><published>2020-07-06T00:00:00+08:00</published><updated>2020-07-06T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/spring/0706/%E6%8B%A6%E6%88%AA%E5%99%A8(Interceptor)%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%8C%BA%E5%88%AB</id><content type="html" xml:base="http://localhost:4000/mianshi/spring/0706/02">&lt;h4 id=&quot;一引言&quot;&gt;一、引言&lt;/h4&gt;

&lt;p&gt;本来想记录一下关于用户登陆和登陆之后的权限管理、菜单管理的问题，想到解决这个问题用到Interceptor，但想到了Interceptor，就想到了Filter，于是就想说一下它们的执行顺序和区别。关于Interceptor解决权限和菜单管理的问题，在放在下一篇写吧，就酱紫。&lt;/p&gt;

&lt;h4 id=&quot;二区别&quot;&gt;二、区别&lt;/h4&gt;

&lt;h5 id=&quot;1过滤器filter&quot;&gt;1、过滤器（Filter）&lt;/h5&gt;

&lt;p&gt;首先说一下Filter的使用地方，我们在配置web.xml时，总会配置下面一段设置字符编码，不然会导致乱码问题：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;filter&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-name&amp;gt;&lt;/span&gt;encoding&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-class&amp;gt;&lt;/span&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-class&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;encoding&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;UTF-8&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;forceEncoding&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;true&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-mapping&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-name&amp;gt;&lt;/span&gt;encoding&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;/*&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置这个地方的目的，是让所有的请求都需要进行字符编码的设置，下面来介绍一下Filter。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）过滤器(Filter)：&lt;/strong&gt; 它依赖于servlet容器。在实现上，基于函数回调，它可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的，是用来做一些过滤操作，获取我们想要获取的数据，比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。通常用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。&lt;/p&gt;

&lt;h5 id=&quot;2拦截器interceptor&quot;&gt;2、拦截器（Interceptor）&lt;/h5&gt;

&lt;p&gt;拦截器的配置一般在SpringMVC的配置文件中，使用Interceptors标签，具体配置如下：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:interceptors&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:interceptor&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:mapping&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/**&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.scorpios.atcrowdfunding.web.LoginInterceptor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mvc:interceptor&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:interceptor&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:mapping&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/**&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.scorpios.atcrowdfunding.web.AuthInterceptor&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mvc:interceptor&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mvc:interceptors&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（2）拦截器（Interceptor）：&lt;/strong&gt; 它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。&lt;/p&gt;

&lt;h4 id=&quot;三代码&quot;&gt;三、代码&lt;/h4&gt;

&lt;p&gt;下面在一个项目中我们使用既有多个过滤器，又有多个拦截器，并观察它们的执行顺序：&lt;/p&gt;

&lt;h5 id=&quot;1第一个过滤器&quot;&gt;（1）第一个过滤器：&lt;/h5&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestFilter1&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Filter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  

		&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;

  	    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FilterChain&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filterChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServletException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;c1&quot;&gt;//在DispatcherServlet之前执行  &lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;############TestFilter1 doFilterInternal executed############&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;filterChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;c1&quot;&gt;//在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后  &lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;############TestFilter1 doFilter after############&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2第二个过滤器&quot;&gt;（2）第二个过滤器：&lt;/h5&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestFilter2&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Filter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  

	&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FilterChain&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filterChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServletException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
	    &lt;span class=&quot;c1&quot;&gt;//在DispatcherServlet之前执行  &lt;/span&gt;
	    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;############TestFilter2 doFilterInternal executed############&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
	    &lt;span class=&quot;n&quot;&gt;filterChain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
	    &lt;span class=&quot;c1&quot;&gt;//在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后&lt;/span&gt;
	    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;############TestFilter2 doFilter after############&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;3在webxml中注册这两个过滤器&quot;&gt;（3）在web.xml中注册这两个过滤器：&lt;/h5&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 自定义过滤器：testFilter1 --&amp;gt;&lt;/span&gt;   
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-name&amp;gt;&lt;/span&gt;testFilter1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-name&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-class&amp;gt;&lt;/span&gt;com.scorpios.filter.TestFilter1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-class&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-mapping&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-name&amp;gt;&lt;/span&gt;testFilter1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-name&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/*&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 自定义过滤器：testFilter2 --&amp;gt;&lt;/span&gt;   
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-name&amp;gt;&lt;/span&gt;testFilter2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-name&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-class&amp;gt;&lt;/span&gt;com.scorpios.filter.TestFilter2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-class&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-mapping&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-name&amp;gt;&lt;/span&gt;testFilter2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-name&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/*&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再定义两个拦截器：&lt;/p&gt;

&lt;h5 id=&quot;4第一个拦截器&quot;&gt;（4）第一个拦截器：&lt;/h5&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BaseInterceptor&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandlerInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  


    &lt;span class=&quot;cm&quot;&gt;/**
     * 在DispatcherServlet之前执行
     * */&lt;/span&gt;  
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;************BaseInterceptor preHandle executed**********&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;cm&quot;&gt;/**
     * 在controller执行之后的DispatcherServlet之后执行
     * */&lt;/span&gt;  
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelAndView&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;************BaseInterceptor postHandle executed**********&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;cm&quot;&gt;/**
     * 在页面渲染完成返回给客户端之前执行
     * */&lt;/span&gt;  
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  
            &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;************BaseInterceptor afterCompletion executed**********&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;5第二个拦截器&quot;&gt;（5）第二个拦截器：&lt;/h5&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestInterceptor&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandlerInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;************TestInterceptor preHandle executed**********&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelAndView&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;************TestInterceptor postHandle executed**********&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HttpServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;************TestInterceptor afterCompletion executed**********&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;6在springmvc的配置文件中加上拦截器的配置&quot;&gt;（6）、在SpringMVC的配置文件中，加上拦截器的配置：&lt;/h5&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 拦截器 --&amp;gt;&lt;/span&gt;  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:interceptors&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 对所有请求都拦截，公共拦截器可以有多个 --&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;baseInterceptor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.scorpios.interceptor.BaseInterceptor&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  

	&lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:interceptor&amp;gt;&lt;/span&gt;
	    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 对/test.html进行拦截 --&amp;gt;&lt;/span&gt;       
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:mapping&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/test.html&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 特定请求的拦截器只能有一个 --&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.scorpios.interceptor.TestInterceptor&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mvc:interceptor&amp;gt;&lt;/span&gt;  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mvc:interceptors&amp;gt;&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;7定义一个controller控制器&quot;&gt;（7）、定义一个Controller控制器：&lt;/h5&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.scorpios.controller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.stereotype.Controller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.bind.annotation.RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.web.servlet.ModelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  

&lt;span class=&quot;nd&quot;&gt;@Controller&lt;/span&gt;  
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/test&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ModelAndView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handleRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;---------TestController executed--------&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ModelAndView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;8测试结果&quot;&gt;（8）、测试结果：&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0706/20180603132319702.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;启动测试项目，地址如下：http://www.localhost:8080/demo，可以看到控制台中输出如下：&lt;/p&gt;

&lt;p&gt;这就说明了过滤器的运行是依赖于servlet容器，跟springmvc等框架并没有关系。并且，多个过滤器的执行顺序跟xml文件中定义的先后关系有关。&lt;/p&gt;

&lt;p&gt;接着清空控制台，并访问：http://www.localhost:8080/demo/test，再次看控制台的输出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0706/20180603132536413.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从这个控制台打印输出，就可以很清晰地看到有多个拦截器和过滤器存在时的整个执行顺序了。当然，对于多个拦截器它们之间的执行顺序跟在SpringMVC的配置文件中定义的先后顺序有关。&lt;/p&gt;

&lt;p&gt;四、总结
对于上述过滤器和拦截器的测试，可以得到如下结论：
（1）、Filter需要在web.xml中配置，依赖于Servlet；
（2）、Interceptor需要在SpringMVC中配置，依赖于框架；
（3）、Filter的执行顺序在Interceptor之前，具体的流程见下图；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0706/20180603133007923.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（4）、两者的本质区别：拦截器（Interceptor）是基于Java的反射机制，而过滤器（Filter）是基于函数回调。从灵活性上说拦截器功能更强大些，Filter能做的事情，都能做，而且可以在请求前，请求后执行，比较灵活。Filter主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验（比较泛的，比如登录不登录之类），太细的话，还是建议用interceptor。不过还是根据不同情况选择合适的。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">一、引言 本来想记录一下关于用户登陆和登陆之后的权限管理、菜单管理的问题，想到解决这个问题用到Interceptor，但想到了Interceptor，就想到了Filter，于是就想说一下它们的执行顺序和区别。关于Interceptor解决权限和菜单管理的问题，在放在下一篇写吧，就酱紫。 二、区别 1、过滤器（Filter） 首先说一下Filter的使用地方，我们在配置web.xml时，总会配置下面一段设置字符编码，不然会导致乱码问题： &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;encoding&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;forceEncoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;encoding&amp;lt;/filter-name&amp;gt; &amp;lt;servlet-name&amp;gt;/*&amp;lt;/servlet-name&amp;gt; &amp;lt;/filter-mapping&amp;gt; 配置这个地方的目的，是让所有的请求都需要进行字符编码的设置，下面来介绍一下Filter。 （1）过滤器(Filter)： 它依赖于servlet容器。在实现上，基于函数回调，它可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的，是用来做一些过滤操作，获取我们想要获取的数据，比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。通常用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。 2、拦截器（Interceptor） 拦截器的配置一般在SpringMVC的配置文件中，使用Interceptors标签，具体配置如下： &amp;lt;mvc:interceptors&amp;gt; &amp;lt;mvc:interceptor&amp;gt; &amp;lt;mvc:mapping path=&quot;/**&quot; /&amp;gt; &amp;lt;bean class=&quot;com.scorpios.atcrowdfunding.web.LoginInterceptor&quot;&amp;gt;&amp;lt;/bean&amp;gt; &amp;lt;/mvc:interceptor&amp;gt; &amp;lt;mvc:interceptor&amp;gt; &amp;lt;mvc:mapping path=&quot;/**&quot; /&amp;gt; &amp;lt;bean class=&quot;com.scorpios.atcrowdfunding.web.AuthInterceptor&quot;&amp;gt;&amp;lt;/bean&amp;gt; &amp;lt;/mvc:interceptor&amp;gt; &amp;lt;/mvc:interceptors&amp;gt; （2）拦截器（Interceptor）： 它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。 三、代码 下面在一个项目中我们使用既有多个过滤器，又有多个拦截器，并观察它们的执行顺序： （1）第一个过滤器： public class TestFilter1 implements Filter { @Override protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { //在DispatcherServlet之前执行 System.out.println(&quot;############TestFilter1 doFilterInternal executed############&quot;); filterChain.doFilter(request, response); //在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后 System.out.println(&quot;############TestFilter1 doFilter after############&quot;); } } （2）第二个过滤器： public class TestFilter2 implements Filter { @Override protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { //在DispatcherServlet之前执行 System.out.println(&quot;############TestFilter2 doFilterInternal executed############&quot;); filterChain.doFilter(request, response); //在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后 System.out.println(&quot;############TestFilter2 doFilter after############&quot;); } } （3）在web.xml中注册这两个过滤器： &amp;lt;!-- 自定义过滤器：testFilter1 --&amp;gt; &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;testFilter1&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;com.scorpios.filter.TestFilter1&amp;lt;/filter-class&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;testFilter1&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; &amp;lt;!-- 自定义过滤器：testFilter2 --&amp;gt; &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;testFilter2&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;com.scorpios.filter.TestFilter2&amp;lt;/filter-class&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;testFilter2&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; 再定义两个拦截器： （4）第一个拦截器： public class BaseInterceptor implements HandlerInterceptor{ /** * 在DispatcherServlet之前执行 * */ public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception { System.out.println(&quot;************BaseInterceptor preHandle executed**********&quot;); return true; } /** * 在controller执行之后的DispatcherServlet之后执行 * */ public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception { System.out.println(&quot;************BaseInterceptor postHandle executed**********&quot;); } /** * 在页面渲染完成返回给客户端之前执行 * */ public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception { System.out.println(&quot;************BaseInterceptor afterCompletion executed**********&quot;); } } （5）第二个拦截器： public class TestInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception { System.out.println(&quot;************TestInterceptor preHandle executed**********&quot;); return true; } public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception { System.out.println(&quot;************TestInterceptor postHandle executed**********&quot;); } public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception { System.out.println(&quot;************TestInterceptor afterCompletion executed**********&quot;); } } （6）、在SpringMVC的配置文件中，加上拦截器的配置： &amp;lt;!-- 拦截器 --&amp;gt; &amp;lt;mvc:interceptors&amp;gt; &amp;lt;!-- 对所有请求都拦截，公共拦截器可以有多个 --&amp;gt; &amp;lt;bean name=&quot;baseInterceptor&quot; class=&quot;com.scorpios.interceptor.BaseInterceptor&quot; /&amp;gt; &amp;lt;mvc:interceptor&amp;gt; &amp;lt;!-- 对/test.html进行拦截 --&amp;gt; &amp;lt;mvc:mapping path=&quot;/test.html&quot;/&amp;gt; &amp;lt;!-- 特定请求的拦截器只能有一个 --&amp;gt; &amp;lt;bean class=&quot;com.scorpios.interceptor.TestInterceptor&quot; /&amp;gt; &amp;lt;/mvc:interceptor&amp;gt; &amp;lt;/mvc:interceptors&amp;gt; （7）、定义一个Controller控制器： package com.scorpios.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; @Controller public class TestController { @RequestMapping(&quot;/test&quot;) public ModelAndView handleRequest(){ System.out.println(&quot;---------TestController executed--------&quot;); return new ModelAndView(&quot;test&quot;); } } （8）、测试结果： 启动测试项目，地址如下：http://www.localhost:8080/demo，可以看到控制台中输出如下： 这就说明了过滤器的运行是依赖于servlet容器，跟springmvc等框架并没有关系。并且，多个过滤器的执行顺序跟xml文件中定义的先后关系有关。 接着清空控制台，并访问：http://www.localhost:8080/demo/test，再次看控制台的输出： 从这个控制台打印输出，就可以很清晰地看到有多个拦截器和过滤器存在时的整个执行顺序了。当然，对于多个拦截器它们之间的执行顺序跟在SpringMVC的配置文件中定义的先后顺序有关。 四、总结 对于上述过滤器和拦截器的测试，可以得到如下结论： （1）、Filter需要在web.xml中配置，依赖于Servlet； （2）、Interceptor需要在SpringMVC中配置，依赖于框架； （3）、Filter的执行顺序在Interceptor之前，具体的流程见下图； （4）、两者的本质区别：拦截器（Interceptor）是基于Java的反射机制，而过滤器（Filter）是基于函数回调。从灵活性上说拦截器功能更强大些，Filter能做的事情，都能做，而且可以在请求前，请求后执行，比较灵活。Filter主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验（比较泛的，比如登录不登录之类），太细的话，还是建议用interceptor。不过还是根据不同情况选择合适的。</summary></entry><entry><title type="html">降低Redis内存占用</title><link href="http://localhost:4000/mianshi/Redis/0705/04" rel="alternate" type="text/html" title="降低Redis内存占用" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/Redis/0705/%E9%99%8D%E4%BD%8ERedis%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8</id><content type="html" xml:base="http://localhost:4000/mianshi/Redis/0705/04">&lt;p&gt;&lt;strong&gt;1、降低redis内存占用的优点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　1、有助于减少创建快照和加载快照所用的时间&lt;/p&gt;

&lt;p&gt;　　2、提升载入AOF文件和重写AOF文件时的效率&lt;/p&gt;

&lt;p&gt;　　3、缩短从服务器进行同步所需的时间&lt;/p&gt;

&lt;p&gt;　　4、无需添加额外的硬件就可以让redis存贮更多的数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、短结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Redis为列表、集合、散列、有序集合提供了一组配置选项，这些选项可以让redis以更节约的方式存储较短的结构。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2.1、ziplist压缩列表（列表、散列、有续集和）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　通常情况下使用的存储方式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/1734531-20190723145231193-1166923194.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;p&gt;　　当列表、散列、有序集合的长度较短或者体积较小的时候，redis将会采用一种名为ziplist的紧凑存储方式来存储这些结构。&lt;/p&gt;

&lt;p&gt;　　ziplist是列表、散列、有序集合这三种不同类型的对象的一种非结构化表示，它会以序列化的方式存储数据，这些序列化的数据每次被读取的时候都需要进行解码，每次写入的时候也要进行编码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;双向列表与压缩列表的区别：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　  为了了解压缩列表比其他数据结构更加节约内存，我们以列表结构为例进行深入研究。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;典型的双向列表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　1、在典型双向列表里面，每个值都都会有一个节点表示。每个节点都会带有指向链表前一个节点和后一个节点的指针，以及一个指向节点包含的字符串值的指针。&lt;/p&gt;

&lt;p&gt;　　　　2、每个节点包含的字符串值都会分为三部分进行存储。包括字符串长度、字符串值中剩余可用字节数量、以空字符结尾的字符串本身。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;例子：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　假若一个某个节点存储了’abc’字符串，在32位的平台下保守估计需要21个字节的额外开销（三个指针+两个int+空字符即：3&lt;em&gt;4+2&lt;/em&gt;4+1=21）&lt;/p&gt;

&lt;p&gt;　　由例子可知存储一个3字节字符串就需要付出至少21个字节的额外开销。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;ziplist&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　压缩列表是由节点组成的序列，每个节点包含两个长度和一个字符串。第一个长度记录前一个节点的长度（用于对压缩列表从后向前遍历）；第二个长度是记录本当前点的长度；被存储的字符串。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;例子：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　存储字符串’abc’，两个长度都可以用1字节来存储，因此所带来的额外开销为2字节（两个长度即1+1=2）&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　压缩列表是通过避免存储额外的指针和元数据，从而达到降低额外的开销。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;配置：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 #list2 list-max-ziplist-entries 51
2 #表示允许包含的最大元素数量
3 list-max-ziplist-value 64    #表示压缩节点允许存储的最大体积
4 #hash                  #当超过任一限制后，将不会使用ziplist方式进行存储
5 hash-max-ziplist-entries 512
6 hash-max-ziplist-value 64
7 #zset
8 zset-max-ziplist-entries 128
9 zset-max-ziplist-value 64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;测试list:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;1、建立test.php文件&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 #test.php
2 &amp;lt;?php
3     $redis=new Redis();
4     $redis-&amp;gt;connect('192.168.95.11','6379');
5         for ($i=0; $i&amp;lt;512  ; $i++) 
6     { 
7         $redis-&amp;gt;lpush('test-list',$i.'-test-list');  #往test-list推入512条数据
8     }
9 ?&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/Users/minp/GitHub/javaniuniu.github.io/_posts/docs-mianshi/1734531-20190723145957416-1822584668.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　　　此时的test-list中含有512条数据，没有超除配置文件中的限制&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2、往test-list中再推入一条数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/1734531-20190723150126455-831466601.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　　　此时test-list含有513条数据，大于配置文件中限制的512条，索引将放弃ziplist存储方式，采用其原来的linkedlist存储方式,散列与有序集合同理。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;2.2、intset整数集合（集合）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　前提条件，集合中包含的所有member都可以被解析为十进制整数。&lt;/p&gt;

&lt;p&gt;　　　　以有序数组的方式存储集合不仅可以降低内存消耗，还可以提升集合操作的执行速度。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;配置：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 set-max-intset-entries  512   #限制集合中member个数，超出则不采取i那个tset存储
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　　&lt;strong&gt;测试：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　建立test.php文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1 #test.php
 2 &amp;lt;?php
 3     $redis=new Redis();
 4     $redis-&amp;gt;connect('192.168.95.11','6379');
 5         for ($i=0; $i&amp;lt;512  ; $i++) 
 6     { 
 7         $redis-&amp;gt;sadd('test-set',$i);   #给集合test-set插入512个member
 8     } 
 9 ?&amp;gt;           
10  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　　&lt;strong&gt;2.3、性能问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　不管列表、散列、有序集合、集合，当超出限制的条件后，就会转换为更为典型的底层结构类型。因为随着紧凑结构的体积不断变大，操作这些结构的速度将会变得越来越慢。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;测试：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　#将采用list进行代表性测试&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;测试思路：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;strong&gt;1、在默认配置下往test-list推入50000条数据，查看所需时间；接着在使用rpoplpush将test-list数据全部推入到新列表list-new中，查看所需时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;strong&gt;2、修改配置，list-max-ziplist-entries 100000，再执行上面的同样操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;strong&gt;3、对比时间，得出结论&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　&lt;strong&gt;默认配置下测试：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　&lt;strong&gt;1、插入数据，查看时间&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1 #test1.php 
 2 &amp;lt;?php 
 3     header(&quot;content-type: text/html;charset=utf8;&quot;); 
 4     $redis=new Redis(); 
 5     $redis-&amp;gt;connect('192.168.95.11','6379'); 
 6     $start=time(); 
 7         for ($i=0; $i&amp;lt;50000  ; $i++) 
 8     { 
 9         $redis-&amp;gt;lpush('test-list',$i.'-aaaassssssddddddkkk');
10     }
11     $end=time();
12 echo &quot;插入耗时为：&quot;.($end-$start).'s';
13 ?&amp;gt;                
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/1734531-20190723150824482-2109961153.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　结果耗时4秒&lt;/p&gt;

&lt;p&gt;　　　　　　　　&lt;strong&gt;2、执行相应命令，查看耗时&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1 #test2.php 
 2 &amp;lt;?php 
 3     header(&quot;content-type: text/html;charset=utf8;&quot;); 
 4     $redis=new Redis(); 
 5     $redis-&amp;gt;connect('192.168.95.11','6379'); 
 6     $start=time(); 
 7     $num=0;  
 8     while($redis-&amp;gt;rpoplpush('test-list','test-new')) 
 9     {
10         $num+=1;
11     }
12     echo '执行次数为：'.$num.&quot;&amp;lt;br/&amp;gt;&quot;;
13 $end=time();
14 echo &quot;耗时为：&quot;.($end-$start).'s';
15 ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　　　　　　　&lt;strong&gt;更改配置文件下测试&lt;/strong&gt;　　&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　&lt;strong&gt;1、先修改配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　list-max-ziplist-entries 100000 #将这个值修改大一点，可以更好的凸显对性能的影响&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　list-max-ziplist-value 64  #此值可不做修改&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　&lt;strong&gt;2、插入数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　执行test1.php&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　结果为：耗时12s&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/1734531-20190723151326952-1965499675.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　&lt;strong&gt;3、执行相应命令，查看耗时&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　执行test2.php&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　结果为：执行次数：50000，耗时12s&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;strong&gt;在本机中执行测试50000条数据就相差8s，若在高并发下，长压缩列表和大整数集合将起不到任何的优化，反而使得性能降低。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、片结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　分片的本质就是基于简单的规则将数据划分为更小的部分，然后根据数据所属的部分来决定将数据发送到哪个位置上。很多数据库使用这种技术来扩展存储空间，并提高自己所能处理的负载量。&lt;/p&gt;

&lt;p&gt;　　结合前面讲到的，我们不难发现分片结构对于redis的重要意义。因此我们需要在配置文件中关于ziplist以及intset的相关配置做出适当的调整。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.1、分片式散列&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　#ShardHash.class.php&lt;/p&gt;

&lt;p&gt;　　散列分片主要是根据基础键以及散列包含的键计算出分片键ID，然后再与基础键拼接成一个完整的分片键。在执行hset与hget以及大部分hash命令时，都需要先将key（field）通过shardKey方法处理，得到分片键才能够进行下一步操作。&lt;/p&gt;

&lt;p&gt;回到顶部&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.2、分片式集合&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　如何构造分片式集合才能够让它更节省内存，性能更加强大呢？主要的思路就是，将集合里面的存储的数据尽量在不改变其原有功能的情况下转换成可以被解析为十进制的数据。根据前面所讲到的，当集合中的所有成员都能够被解析为十进制数据时，将会采用intset存储方式，这不仅能够节省内存，而且还可以提高响应的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、将信息打包转换成存储字节&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　结合前面所讲的分片技术，采用string分片结构为大量连续的ID用户存储信息。&lt;/p&gt;

&lt;p&gt;　　使用定长字符串，为每一个ID分配n个字节进行存储相应的信息。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">1、降低redis内存占用的优点 　　1、有助于减少创建快照和加载快照所用的时间 　　2、提升载入AOF文件和重写AOF文件时的效率 　　3、缩短从服务器进行同步所需的时间 　　4、无需添加额外的硬件就可以让redis存贮更多的数据 2、短结构 　　Redis为列表、集合、散列、有序集合提供了一组配置选项，这些选项可以让redis以更节约的方式存储较短的结构。 　　2.1、ziplist压缩列表（列表、散列、有续集和） 　　通常情况下使用的存储方式 　　 　　当列表、散列、有序集合的长度较短或者体积较小的时候，redis将会采用一种名为ziplist的紧凑存储方式来存储这些结构。 　　ziplist是列表、散列、有序集合这三种不同类型的对象的一种非结构化表示，它会以序列化的方式存储数据，这些序列化的数据每次被读取的时候都需要进行解码，每次写入的时候也要进行编码。 双向列表与压缩列表的区别： 　 为了了解压缩列表比其他数据结构更加节约内存，我们以列表结构为例进行深入研究。 　　典型的双向列表 　　　　1、在典型双向列表里面，每个值都都会有一个节点表示。每个节点都会带有指向链表前一个节点和后一个节点的指针，以及一个指向节点包含的字符串值的指针。 　　　　2、每个节点包含的字符串值都会分为三部分进行存储。包括字符串长度、字符串值中剩余可用字节数量、以空字符结尾的字符串本身。 　　例子： 　　假若一个某个节点存储了’abc’字符串，在32位的平台下保守估计需要21个字节的额外开销（三个指针+两个int+空字符即：34+24+1=21） 　　由例子可知存储一个3字节字符串就需要付出至少21个字节的额外开销。 　　ziplist 　　　　压缩列表是由节点组成的序列，每个节点包含两个长度和一个字符串。第一个长度记录前一个节点的长度（用于对压缩列表从后向前遍历）；第二个长度是记录本当前点的长度；被存储的字符串。 　　例子： 　　存储字符串’abc’，两个长度都可以用1字节来存储，因此所带来的额外开销为2字节（两个长度即1+1=2） 　　结论： 　　压缩列表是通过避免存储额外的指针和元数据，从而达到降低额外的开销。 　　配置： 1 #list2 list-max-ziplist-entries 51 2 #表示允许包含的最大元素数量 3 list-max-ziplist-value 64 #表示压缩节点允许存储的最大体积 4 #hash #当超过任一限制后，将不会使用ziplist方式进行存储 5 hash-max-ziplist-entries 512 6 hash-max-ziplist-value 64 7 #zset 8 zset-max-ziplist-entries 128 9 zset-max-ziplist-value 64 　　测试list: 　　1、建立test.php文件 1 #test.php 2 &amp;lt;?php 3 $redis=new Redis(); 4 $redis-&amp;gt;connect('192.168.95.11','6379'); 5 for ($i=0; $i&amp;lt;512 ; $i++) 6 { 7 $redis-&amp;gt;lpush('test-list',$i.'-test-list'); #往test-list推入512条数据 8 } 9 ?&amp;gt; 　　　　此时的test-list中含有512条数据，没有超除配置文件中的限制 　　2、往test-list中再推入一条数据 　　　　此时test-list含有513条数据，大于配置文件中限制的512条，索引将放弃ziplist存储方式，采用其原来的linkedlist存储方式,散列与有序集合同理。 　　　　2.2、intset整数集合（集合） 　　　　前提条件，集合中包含的所有member都可以被解析为十进制整数。 　　　　以有序数组的方式存储集合不仅可以降低内存消耗，还可以提升集合操作的执行速度。 　　　　配置： 1 set-max-intset-entries 512 #限制集合中member个数，超出则不采取i那个tset存储 　　　测试： 　　　　建立test.php文件 1 #test.php 2 &amp;lt;?php 3 $redis=new Redis(); 4 $redis-&amp;gt;connect('192.168.95.11','6379'); 5 for ($i=0; $i&amp;lt;512 ; $i++) 6 { 7 $redis-&amp;gt;sadd('test-set',$i); #给集合test-set插入512个member 8 } 9 ?&amp;gt; 10 　　　2.3、性能问题 　　　　不管列表、散列、有序集合、集合，当超出限制的条件后，就会转换为更为典型的底层结构类型。因为随着紧凑结构的体积不断变大，操作这些结构的速度将会变得越来越慢。 　　　　测试： 　　　　#将采用list进行代表性测试 　　　　测试思路： 　　　　　　1、在默认配置下往test-list推入50000条数据，查看所需时间；接着在使用rpoplpush将test-list数据全部推入到新列表list-new中，查看所需时间 　　　　　　2、修改配置，list-max-ziplist-entries 100000，再执行上面的同样操作 　　　　　　3、对比时间，得出结论 　　　　　　　　默认配置下测试： 　　　　　　　　1、插入数据，查看时间 1 #test1.php 2 &amp;lt;?php 3 header(&quot;content-type: text/html;charset=utf8;&quot;); 4 $redis=new Redis(); 5 $redis-&amp;gt;connect('192.168.95.11','6379'); 6 $start=time(); 7 for ($i=0; $i&amp;lt;50000 ; $i++) 8 { 9 $redis-&amp;gt;lpush('test-list',$i.'-aaaassssssddddddkkk'); 10 } 11 $end=time(); 12 echo &quot;插入耗时为：&quot;.($end-$start).'s'; 13 ?&amp;gt; 　　　　　　结果耗时4秒 　　　　　　　　2、执行相应命令，查看耗时 1 #test2.php 2 &amp;lt;?php 3 header(&quot;content-type: text/html;charset=utf8;&quot;); 4 $redis=new Redis(); 5 $redis-&amp;gt;connect('192.168.95.11','6379'); 6 $start=time(); 7 $num=0; 8 while($redis-&amp;gt;rpoplpush('test-list','test-new')) 9 { 10 $num+=1; 11 } 12 echo '执行次数为：'.$num.&quot;&amp;lt;br/&amp;gt;&quot;; 13 $end=time(); 14 echo &quot;耗时为：&quot;.($end-$start).'s'; 15 ?&amp;gt; 　　　　　　　　更改配置文件下测试　　 　　　　　　　　　　1、先修改配置文件 　　　　　　　　　　list-max-ziplist-entries 100000 #将这个值修改大一点，可以更好的凸显对性能的影响 　　　　　　　　　　list-max-ziplist-value 64 #此值可不做修改 　　　　　　　　　　2、插入数据 　　　　　　　　　　执行test1.php 　　　　　　　　　　结果为：耗时12s 　　　　　　　　　　3、执行相应命令，查看耗时 　　　　　　　　　　执行test2.php 　　　　　　　　　　结果为：执行次数：50000，耗时12s 　　　　　　结论： 　　　　　　在本机中执行测试50000条数据就相差8s，若在高并发下，长压缩列表和大整数集合将起不到任何的优化，反而使得性能降低。 3、片结构 　　分片的本质就是基于简单的规则将数据划分为更小的部分，然后根据数据所属的部分来决定将数据发送到哪个位置上。很多数据库使用这种技术来扩展存储空间，并提高自己所能处理的负载量。 　　结合前面讲到的，我们不难发现分片结构对于redis的重要意义。因此我们需要在配置文件中关于ziplist以及intset的相关配置做出适当的调整。 　　3.1、分片式散列 　　#ShardHash.class.php 　　散列分片主要是根据基础键以及散列包含的键计算出分片键ID，然后再与基础键拼接成一个完整的分片键。在执行hset与hget以及大部分hash命令时，都需要先将key（field）通过shardKey方法处理，得到分片键才能够进行下一步操作。 回到顶部 　　3.2、分片式集合 　　如何构造分片式集合才能够让它更节省内存，性能更加强大呢？主要的思路就是，将集合里面的存储的数据尽量在不改变其原有功能的情况下转换成可以被解析为十进制的数据。根据前面所讲到的，当集合中的所有成员都能够被解析为十进制数据时，将会采用intset存储方式，这不仅能够节省内存，而且还可以提高响应的性能。 4、将信息打包转换成存储字节 　　结合前面所讲的分片技术，采用string分片结构为大量连续的ID用户存储信息。 　　使用定长字符串，为每一个ID分配n个字节进行存储相应的信息。</summary></entry><entry><title type="html">关于Spring 和 Spring MVC的43个问题</title><link href="http://localhost:4000/mianshi/spring/0705/10" rel="alternate" type="text/html" title="关于Spring 和 Spring MVC的43个问题" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/spring/0705/%E5%85%B3%E4%BA%8ESpring%20%E5%92%8C%20Spring%20MVC%E7%9A%8443%E4%B8%AA%E9%97%AE%E9%A2%98</id><content type="html" xml:base="http://localhost:4000/mianshi/spring/0705/10">&lt;h4 id=&quot;1为什么使用spring&quot;&gt;1、为什么使用spring？&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;社区活跃，使用的企业多&lt;/li&gt;
  &lt;li&gt;很多第三方框架集成了spring&lt;/li&gt;
  &lt;li&gt;提供了Ioc容器，对象间的依赖关系由spring进行控制，避免了硬代码之间的耦合&lt;/li&gt;
  &lt;li&gt;提供AOP编程的支持，通过spring的AOP功能，避免了业务之间的耦合&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;2什么是ioc为什使用ioc-&quot;&gt;2、什么是IoC，为什使用IoC ?&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;控制什么？为什么要控制？&lt;/strong&gt; 把创建对象的权限托管给了spring统一管理，控制对象之间的依赖关系，避免硬编码之间的耦合&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是反转？怎么反转：&lt;/strong&gt; 如果把自己主动new的对象称为正转，那么通过spring创建的的对象称为反转，spring创建对象的方式使用了反转和代理的机制&lt;/p&gt;

&lt;h4 id=&quot;3什么是aop为什么使用aop-&quot;&gt;3、什么是AOP，为什么使用AOP ?&lt;/h4&gt;

&lt;p&gt;AOP（面向切面编程）是一种编程思想，其主要思想是让开发者把诸多业务流程中的通用功能抽取出来，单独编写功能代码，形成独立的模块，这些模块也被称为切面。AOP在spring中是的核心模块，并提供了编程模范。降低了因不同业务之间的依赖造成的耦合度。&lt;/p&gt;

&lt;h4 id=&quot;4什么是spring的事务管理&quot;&gt;4、什么是Spring的事务管理&lt;/h4&gt;

&lt;p&gt;作为企业级的开发框架，spring在不同的事务api上定义了一个抽象层，而开发人员不必了解底底层是事务api，就可以使用spring的事务管理器&lt;/p&gt;

&lt;p&gt;Spring既支持编程式事务管理(也称编码式事务)，也支持声明式的事务管理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;编程式事务管理&lt;/strong&gt;：将事务管理代码嵌入到业务方法中来控制事务的提交和回滚，在编程式事务中，必须在每个业务操作中包含额外的事务管理代码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;声明式事务管理&lt;/strong&gt;：大多数情况下比编程式事务管理更好用。它将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。事务管理作为一种横切关注点，可以通过AOP方法模块化。Spring通过Spring AOP框架支持声明式事务管理。&lt;/p&gt;

&lt;h4 id=&quot;5spring框架支持以下五种bean的作用域&quot;&gt;5、Spring框架支持以下五种bean的作用域?&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;单例：&lt;/strong&gt; 默认值，bean在每个spring ioc 容器中只有一个对象&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多例：&lt;/strong&gt; 一个bean的定义可以有多个实例&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;request：&lt;/strong&gt; 针对每一次Http请求，Spring容器根据该bean的定义创建一个全新的实例，且该实例仅在当前Http请求内有效，而其它请求无法看到当前请求中状态的变化，当当前Http请求结束，该bean实例也将会被销毁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;seession：&lt;/strong&gt; 在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;global session：&lt;/strong&gt; 在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。&lt;/p&gt;

&lt;h4 id=&quot;6什么是spring的mvc框架&quot;&gt;6、什么是Spring的MVC框架？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;springmvc 是基于mvc的web框架，&lt;/li&gt;
  &lt;li&gt;spring mvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将web层进行职责解耦&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;它允许以声明的方式把请求参数和业务对象绑定。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;以下组件通常使用框架提供实现&quot;&gt;以下组件通常使用框架提供实现：&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;DispatcherServlet：&lt;/strong&gt; 作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HandlerMapping：&lt;/strong&gt; 通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HandlAdapter：&lt;/strong&gt; 通过扩展处理器适配器，支持更多类型的处理器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ViewResolver：&lt;/strong&gt; 通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。&lt;/p&gt;

&lt;h4 id=&quot;7如何启用注解&quot;&gt;7、如何启用注解?&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;context:annotation-config/&amp;gt;
如果使用&amp;lt;context:component-scan base-package=&quot;com.tgb.web.controller.annotation&quot;&amp;gt; &amp;lt;/context:component-scan&amp;gt;  则上面内容可以省略
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;8spring-mvc的请求流程&quot;&gt;8、Spring MVC的请求流程?&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/249993-20170207140151791-1932120070.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;看到这个图大家可能会有很多的疑惑，现在我们来看一下这个图的步骤：（可以对比MVC的原理图进行理解）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第一步:用户发起请求到前端控制器（DispatcherServlet）&lt;/p&gt;

&lt;p&gt;第二步：前端控制器请求处理器映射器（HandlerMappering）去查找处理器（Handle）：通过xml配置或者注解进行查找&lt;/p&gt;

&lt;p&gt;第三步：找到以后处理器映射器（HandlerMappering）像前端控制器返回执行链（HandlerExecutionChain）&lt;/p&gt;

&lt;p&gt;第四步：前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler）&lt;/p&gt;

&lt;p&gt;第五步：处理器适配器去执行Handler&lt;/p&gt;

&lt;p&gt;第六步：Handler执行完给处理器适配器返回ModelAndView&lt;/p&gt;

&lt;p&gt;第七步：处理器适配器向前端控制器返回ModelAndView&lt;/p&gt;

&lt;p&gt;第八步：前端控制器请求视图解析器（ViewResolver）去进行视图解析&lt;/p&gt;

&lt;p&gt;第九步：视图解析器像前端控制器返回View&lt;/p&gt;

&lt;p&gt;第十步：前端控制器对视图进行渲染&lt;/p&gt;

&lt;p&gt;第十一步：前端控制器向用户响应结果&lt;/p&gt;

&lt;h4 id=&quot;9webxml的配置&quot;&gt;9、web.xml的配置&lt;/h4&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;web-app&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3.1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--添加过滤器--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-name&amp;gt;&lt;/span&gt;characterEncodingFilter&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-class&amp;gt;&lt;/span&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-class&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;encoding&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;UTF-8&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;forceEncoding&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;true&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-mapping&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;filter-name&amp;gt;&lt;/span&gt;characterEncodingFilter&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/*&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--配置spring--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;dispatcherServlet&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;classpath:spring-config.xml&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;dispatcherServlet&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--自定义首页--&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--  &amp;lt;welcome-file-list&amp;gt;
        &amp;lt;welcome-file&amp;gt;/first/page&amp;lt;/welcome-file&amp;gt;
    &amp;lt;/welcome-file-list&amp;gt;--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--配置404错误页面--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;error-page&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;error-code&amp;gt;&lt;/span&gt;404&lt;span class=&quot;nt&quot;&gt;&amp;lt;/error-code&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;location&amp;gt;&lt;/span&gt;/error_pages/404.jsp&lt;span class=&quot;nt&quot;&gt;&amp;lt;/location&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/error-page&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--配置500错误提示--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;error-page&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;error-code&amp;gt;&lt;/span&gt;500&lt;span class=&quot;nt&quot;&gt;&amp;lt;/error-code&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;location&amp;gt;&lt;/span&gt;/error_pages/500.jsp&lt;span class=&quot;nt&quot;&gt;&amp;lt;/location&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/error-page&amp;gt;&lt;/span&gt;


    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--读取静态文件--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;default&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;*.js&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;*.css&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;*.woff&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;*.woff2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;*.ttf&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;*.png&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;*.jpg&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;*.ogg&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;*.mp4&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;


&lt;span class=&quot;nt&quot;&gt;&amp;lt;/web-app&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;10注解的处理器映射器和适配器&quot;&gt;10、注解的处理器映射器和适配器?&lt;/h4&gt;

&lt;p&gt;spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping注解映射器。&lt;/p&gt;

&lt;p&gt;在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter注解适配器。&lt;/p&gt;

&lt;p&gt;使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置&lt;/p&gt;

&lt;h4 id=&quot;11spring-与-mybatis整合过程&quot;&gt;11、spring 与 mybatis整合过程?&lt;/h4&gt;

&lt;h5 id=&quot;第一步整合dao层&quot;&gt;第一步：整合dao层&lt;/h5&gt;

&lt;p&gt;mybatis和spring整合，通过spring管理mapper接口。&lt;/p&gt;

&lt;p&gt;使用mapper的扫描器自动扫描mapper接口在spring中进行注册。&lt;/p&gt;

&lt;h5 id=&quot;第二步整合service层&quot;&gt;第二步：整合service层&lt;/h5&gt;

&lt;p&gt;通过spring管理 service接口。&lt;/p&gt;

&lt;p&gt;使用配置方式将service接口配置在spring配置文件中。&lt;/p&gt;

&lt;p&gt;实现事务控制。&lt;/p&gt;

&lt;h5 id=&quot;第三步整合springmvc&quot;&gt;第三步：整合springmvc&lt;/h5&gt;

&lt;p&gt;由于springmvc是spring的模块，不需要整合&lt;/p&gt;

&lt;h5 id=&quot;主要配置有&quot;&gt;主要配置有：&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1). mybatis配置文件sqlMapConfig.xml配置别名自动扫描(实体类)

  2). mapper扫描器(接口，数据库访问接口)

  3). 数据库连接池配置

  4). 声明式事务配置

  5). 启用注解扫描：&amp;lt;context:component-scan base-package=&quot;cn.itcast.ssm.controller&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;

  6). 配置注解映射器和适配器： &amp;lt;mvc:annotation-driven&amp;gt;&amp;lt;/mvc:annotation-driven&amp;gt;

  7). 视图解析器：&amp;lt;bean  class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;

  8). 配置控制类： DispatcherServlet前端控制器

  9). 配置spring配置文件加载类：ClassLoadListener
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;12视图解析器配置前缀和后缀&quot;&gt;12、视图解析器配置前缀和后缀?&lt;/h4&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--前缀--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;prefix&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/WEB-INF/jsp/&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--后缀--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;suffix&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.jsp&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;13sqlmapconfigxmlmybatis自己的配置文件&quot;&gt;13、sqlMapConfig.xml，mybatis自己的配置文件?&lt;/h4&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;properties&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;db.properties&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;environments&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;default=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;environment&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;transactionManager&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;JDBC&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;dataSource&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POOLED&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;driver&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${jdbc.driver}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;url&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${jdbc.url}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${jdbc.username}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${jdbc.password}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dataSource&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;14spring自带的数据源&quot;&gt;14、spring自带的数据源&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h6 id=&quot;spring自带的数据源&quot;&gt;spring自带的数据源&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h6 id=&quot;dbcp数据源&quot;&gt;DBCP数据源&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h6 id=&quot;c3p0数据源&quot;&gt;C3P0数据源&lt;/h6&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h6 id=&quot;jndi数据源&quot;&gt;JNDI数据源&lt;/h6&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;15事务控制applicationcontext-transactionxml&quot;&gt;15、事务控制(applicationContext-transaction.xml)?&lt;/h4&gt;

&lt;p&gt;在applicationContext-transaction.xml中使用spring声明式事务控制方法。&lt;/p&gt;

&lt;h4 id=&quot;16加载spring配置&quot;&gt;16、加载spring配置?&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ClassPathXmlApplication的使用方法//&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FileSystemXmlApplicationContext的使用方法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;17静态资源访问不被拦截&quot;&gt;17、静态资源访问不被拦截?&lt;/h4&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;resources&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;mapping=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/resources/**&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;location=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/resources/&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;resources&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;mapping=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/images/**&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;location=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/images/&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;resources&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;mapping=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/js/**&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;location=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/js/&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;18requestmapping的作用&quot;&gt;18、@RequestMapping的作用?&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;url映射：&lt;/strong&gt; 在方法上田间&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;限制http请求方法：&lt;/strong&gt; 该注解的配置属性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;窄化请求映射：&lt;/strong&gt; 在类上添加&lt;/p&gt;

&lt;h4 id=&quot;19controller方法的返回值&quot;&gt;19、controller方法的返回值?&lt;/h4&gt;

&lt;h5 id=&quot;1-返回modelandview&quot;&gt;1 返回ModelAndView&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;需要方法结束时，定义ModelAndView，将model和view分别进行设置。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2-返回string&quot;&gt;2 返回string&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 如果controller方法返回string，

 1). 表示返回逻辑视图名。真正视图(jsp路径)=前缀+逻辑视图名+后缀

 2). redirect重定向：返回字符串格式为：&quot;redirect:queryItem.action&quot;

 3). forward页面转发：返回字符串格式为：“forward:queryItem.action”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;3-返回void&quot;&gt;3 返回void&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  在controller方法形参上可以定义request和response，使用request或 response指定响应结果：

 1). 使用request转向页面，如下：request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);

 2). 也可以通过response页面重定向：response.sendRedirect(&quot;url&quot;)

 3). 也可以通过response指定响应结果，例如响应json数据如下：

       response.setCharacterEncoding(&quot;utf-8&quot;);

       response.setContentType(&quot;application/json;charset=utf-8&quot;);

       response.getWriter().write(&quot;json串&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;20参数绑定&quot;&gt;20、参数绑定&lt;/h4&gt;

&lt;h5 id=&quot;1-默认支持的类型&quot;&gt;1 默认支持的类型&lt;/h5&gt;

&lt;p&gt;直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。&lt;/p&gt;

&lt;p&gt;1). HttpServletRequest：通过request对象获取请求信息&lt;/p&gt;

&lt;p&gt;2). HttpServletResponse：通过response处理响应信息&lt;/p&gt;

&lt;p&gt;3). HttpSession：通过session对象得到session中存放的对象&lt;/p&gt;

&lt;p&gt;4). Model/ModelMap：model是一个接口，modelMap是一个接口实现 。作用：将model数据填充到request域。&lt;/p&gt;

&lt;h5 id=&quot;2-简单类型&quot;&gt;2 简单类型&lt;/h5&gt;

&lt;p&gt;通过@RequestParam对简单类型的参数进行绑定。&lt;/p&gt;

&lt;p&gt;如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。&lt;/p&gt;

&lt;p&gt;如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。&lt;/p&gt;

&lt;p&gt;通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，会报错。&lt;/p&gt;

&lt;h5 id=&quot;4-自定义参数绑定实现日期类型绑定&quot;&gt;4 自定义参数绑定实现日期类型绑定&lt;/h5&gt;

&lt;p&gt;对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。将请求日期数据串转成 日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。&lt;/p&gt;

&lt;h4 id=&quot;21spring-mvc-和-struts2-对比&quot;&gt;21、Spring MVC 和 Struts2 对比?&lt;/h4&gt;

&lt;p&gt;1). Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上SpringMVC 就容易实现restful url&lt;/p&gt;

&lt;p&gt;2). 由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。&lt;/p&gt;

&lt;p&gt;3). 由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。&lt;/p&gt;

&lt;p&gt;4). SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。&lt;/p&gt;

&lt;p&gt;5). springmvc面向方法开发的（更接近service接口的开发方式），struts2面向类开发。&lt;/p&gt;

&lt;p&gt;6). springmvc可以单例开发，struts2只能是多例开发&lt;/p&gt;

&lt;h4 id=&quot;22乱码处理&quot;&gt;22、乱码处理?&lt;/h4&gt;

&lt;h5 id=&quot;1-post乱码&quot;&gt;1). post乱码&lt;/h5&gt;

&lt;p&gt;在web.xml添加post乱码filter：CharacterEncodingFilter&lt;/p&gt;

&lt;h5 id=&quot;2-对于get请求中文参数出现乱码解决方法有两个&quot;&gt;2). 对于get请求中文参数出现乱码解决方法有两个：&lt;/h5&gt;

&lt;h6 id=&quot;a-修改tomcat配置文件添加编码与工程编码一致如下&quot;&gt;a. 修改tomcat配置文件添加编码与工程编码一致，如下：&lt;/h6&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;Connector&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;URIEncoding=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;connectionTimeout=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;20000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;port=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;8080&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;protocol=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HTTP/1.1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;redirectPort=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;8443&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;b-对参数进行重新编码&quot;&gt;b. 对参数进行重新编码：&lt;/h6&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParamter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;userName&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ISO8859-1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码&lt;/p&gt;

&lt;h4 id=&quot;23集合类型绑定&quot;&gt;23、集合类型绑定&lt;/h4&gt;

&lt;h5 id=&quot;1-数组绑定&quot;&gt;1). 数组绑定：&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;controller方法参数使用：(Integer[] itemId)
页面统一使用:itemId 作为name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2-list绑定&quot;&gt;2). list绑定：&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; pojo属性名为：itemsList
 页面：itemsList[index].属性名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;3-map-绑定&quot;&gt;3). map 绑定：&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; pojo属性名为：Map&amp;lt;String, Object&amp;gt; itemInfo = new HashMap&amp;lt;String, Object&amp;gt;();
 页面： &amp;lt;td&amp;gt;姓名：&amp;lt;inputtype=&quot;text&quot;name=&quot;itemInfo['name']&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;24spring-校验-&quot;&gt;24、spring 校验 ?&lt;/h4&gt;

&lt;p&gt;1). 项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。&lt;/p&gt;

&lt;p&gt;2). springmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。&lt;/p&gt;

&lt;p&gt;校验思路：页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面&lt;/p&gt;

&lt;h4 id=&quot;25数据回显&quot;&gt;25、数据回显?&lt;/h4&gt;

&lt;p&gt;1). @ModelAttribute还可以将方法的返回值传到页面：在方法上加注解@ModelAttribute&lt;/p&gt;

&lt;p&gt;2). 使用最简单方法使用model，可以不用@ModelAttribute：model.addAttribute(“id”, id);&lt;/p&gt;

&lt;p&gt;3). springmvc默认对pojo数据进行回显。pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写）&lt;/p&gt;

&lt;p&gt;4). public String testParam(PrintWriter out, @RequestParam(“username”) String username) { //out直接输出&lt;/p&gt;

&lt;h4 id=&quot;26异常处理&quot;&gt;26、异常处理?&lt;/h4&gt;

&lt;p&gt;springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。&lt;/p&gt;

&lt;p&gt;系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。&lt;/p&gt;

&lt;p&gt;Spring 统一异常处理有 3 种方式，分别为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用 @ ExceptionHandler 注解&lt;/li&gt;
  &lt;li&gt;实现 HandlerExceptionResolver 接口&lt;/li&gt;
  &lt;li&gt;使用 @controlleradvice 注解&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;27上传图片&quot;&gt;27、上传图片？&lt;/h4&gt;

&lt;p&gt;1). 在页面form中提交enctype=”multipart/form-data”的数据时，需要springmvc对multipart类型的数据进行解析。&lt;/p&gt;

&lt;p&gt;2). 在springmvc.xml中配置multipart类型解析器。&lt;/p&gt;

&lt;p&gt;3). 方法中使用：MultipartFile attach (单个文件上传) 或者  MultipartFile[] attachs (多个文件上传)&lt;/p&gt;

&lt;h4 id=&quot;28json处理&quot;&gt;28、Json处理&lt;/h4&gt;

&lt;p&gt;1). 加载json转换的jar包：springmvc中使用jackson的包进行json转换（@requestBody和@responseBody使用下边的包进行json转）&lt;/p&gt;

&lt;p&gt;2). 配置json转换器。在注解适配器RequestMappingHandlerAdapter中加入messageConverters。如果使用&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 则会自动加入。&lt;/p&gt;

&lt;p&gt;3). ajax&lt;/p&gt;

&lt;p&gt;4). Controller (ResponseBody、RequestBody)&lt;/p&gt;

&lt;p&gt;5). 注意ajax中contentType如果不设置为json类型，则传的参数为key/value类型。上面设置后，传的是json类型。&lt;/p&gt;

&lt;h4 id=&quot;29拦截器&quot;&gt;29、拦截器?&lt;/h4&gt;

&lt;h5 id=&quot;1-定义拦截器实现handlerinterceptor接口接口中提供三个方法&quot;&gt;1). 定义拦截器，实现HandlerInterceptor接口。接口中提供三个方法。&lt;/h5&gt;

&lt;p&gt;a. preHandle ：进入 Handler方法之前执行，用于身份认证、身份授权，比如身份认证，如果认证不通过表示当前用户没有登陆，需要此方法拦截不再向下执行&lt;/p&gt;

&lt;p&gt;b. postHandle：进入Handler方法之后，返回modelAndView之前执行，应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图&lt;/p&gt;

&lt;p&gt;c. afterCompletion：执行Handler完成执行此方法，应用场景：统一异常处理，统一日志处理&lt;/p&gt;

&lt;h5 id=&quot;2-拦截器配置&quot;&gt;2). 拦截器配置：&lt;/h5&gt;

&lt;p&gt;a. 针对HandlerMapping配置(不推荐)：springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该 HandlerMapping映射成功的handler最终使用该 拦截器。  (一般不推荐使用)&lt;/p&gt;

&lt;p&gt;b. 类似全局的拦截器：springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中&lt;/p&gt;

&lt;h4 id=&quot;30spring中自动装配的方式有哪些&quot;&gt;30、spring中自动装配的方式有哪些？&lt;/h4&gt;

&lt;p&gt;1、No：即不启用自动装配。&lt;/p&gt;

&lt;p&gt;2、byName：通过属性的名字的方式查找JavaBean依赖的对象并为其注入。比如说类Computer有个属性printer，指定其autowire属性为byName后，Spring IoC容器会在配置文件中查找id/name属性为printer的bean，然后使用Seter方法为其注入。&lt;/p&gt;

&lt;p&gt;3、byType：通过属性的类型查找JavaBean依赖的对象并为其注入。比如类Computer有个属性printer，类型为Printer，那么，指定其autowire属性为byType后，Spring IoC容器会查找Class属性为Printer的bean，使用Seter方法为其注入。&lt;/p&gt;

&lt;p&gt;4、constructor：通byType一样，也是通过类型查找依赖对象。与byType的区别在于它不是使用Seter方法注入，而是使用构造子注入。&lt;/p&gt;

&lt;p&gt;5、autodetect：在byType和constructor之间自动的选择注入方式。&lt;/p&gt;

&lt;p&gt;6、default：由上级标签&lt;beans&gt;的default-autowire属性确定。&lt;/beans&gt;&lt;/p&gt;

&lt;h4 id=&quot;31spring中aop的应用场景aop原理好处&quot;&gt;31、Spring中AOP的应用场景、Aop原理、好处？&lt;/h4&gt;

&lt;p&gt;AOP–Aspect Oriented Programming面向切面编程；用来封装横切关注点，具体可以在下面的场景中使用:&lt;/p&gt;

&lt;p&gt;Authentication 权限、Caching 缓存、Context passing 内容传递、Error handling 错误处理Lazy loading懒加载、Debugging调试、logging, tracing, profiling and monitoring 记录跟踪优化　校准、Performance optimization　性能优化、Persistence 持久化、Resource pooling　资源池、Synchronization　同步、Transactions 事务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt;AOP是面向切面编程，是通过__动态代理__的方式为程序添加统一功能，集中解决一些公共问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;1.各个步骤之间的良好隔离性耦合性大大降低 	
      2.源代码无关性，再扩展功能的同时不对源码进行修改操作&lt;/p&gt;

&lt;h4 id=&quot;32spring中ioc的作用与原理对象创建的过程&quot;&gt;32、Spring中IOC的作用与原理？对象创建的过程？&lt;/h4&gt;

&lt;p&gt;IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对象创建的过程：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;读取resources文件下spring_ioc.xml&lt;/li&gt;
  &lt;li&gt;Xml解析spring_ioc.xml&lt;/li&gt;
  &lt;li&gt;把解析xml里的内容存储到内存的map集合中&lt;/li&gt;
  &lt;li&gt;从map集合中读取集合内容，就是&lt;Bean&gt;&lt;/Bean&gt;清单里的内容&lt;/li&gt;
  &lt;li&gt;遍历集合中的所有数据，并反射实例化对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Class.forName(“com.spring.ioc.Hello”).newInstance()&lt;/p&gt;

&lt;h4 id=&quot;33spring常见创建对象的注解&quot;&gt;33、Spring常见创建对象的注解？&lt;/h4&gt;

&lt;p&gt;@Component@Controller@ Service@ Repository&lt;/p&gt;

&lt;h4 id=&quot;34spring中用到的设计模式&quot;&gt;34、Spring中用到的设计模式？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;单例模式 bean默认单例&lt;/li&gt;
  &lt;li&gt;工厂模式 beanFactory ApplicationContext&lt;/li&gt;
  &lt;li&gt;代理模式 springAOP&lt;/li&gt;
  &lt;li&gt;模版模式 jdbcTemplate&lt;/li&gt;
  &lt;li&gt;观察者模式  Spring 事件驱动模型就是观察者模式很经典的一个应用。&lt;/li&gt;
  &lt;li&gt;适配器模式 Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;35spring的优点&quot;&gt;35、Spring的优点？&lt;/h4&gt;

&lt;p&gt;1.&lt;strong&gt;降低了组件之间的耦合性&lt;/strong&gt; ，实现了软件各层之间的解耦
2.可以使用容易__提供的众多服务__，如事务管理，消息服务等
3.容器提供__单例模式__支持
4.容器提供了__AOP技术__，利用它很容易实现如权限拦截，运行期监控等功能
5.容器提供了__众多的辅助类__，能加快应用的开发
6.spring对于__主流的应用框架提供了集成支持__，如hibernate，JPA，Struts等
7.spring属于低__侵入式设计__，代码的污染极低
8.独立于各种应用服务器
9.spring的DI机制降低了业务对象替换的复杂性&lt;/p&gt;

&lt;h4 id=&quot;36spring-bean的作用域之间有什么区别&quot;&gt;36、Spring Bean的作用域之间有什么区别？&lt;/h4&gt;

&lt;p&gt;Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：&lt;/p&gt;

&lt;p&gt;singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。&lt;/p&gt;

&lt;p&gt;prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。&lt;/p&gt;

&lt;p&gt;request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。&lt;/p&gt;

&lt;p&gt;Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。&lt;/p&gt;

&lt;p&gt;global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。&lt;/p&gt;

&lt;p&gt;全局作用域与Servlet中的session作用域效果相同。&lt;/p&gt;

&lt;h4 id=&quot;37spring管理事务有几种方式&quot;&gt;37、Spring管理事务有几种方式？&lt;/h4&gt;

&lt;p&gt;有两种方式：&lt;/p&gt;

&lt;p&gt;1、编程式事务，在代码中硬编码。(不推荐使用)&lt;/p&gt;

&lt;p&gt;2、声明式事务，在配置文件中配置（推荐使用）&lt;/p&gt;

&lt;p&gt;声明式事务又分为两种：&lt;/p&gt;

&lt;p&gt;a、基于XML的声明式事务&lt;/p&gt;

&lt;p&gt;b、基于注解的声明式事务&lt;/p&gt;

&lt;h4 id=&quot;38spring中的核心类有那些各有什么作用&quot;&gt;38、spring中的核心类有那些，各有什么作用？&lt;/h4&gt;

&lt;p&gt;BeanFactory：产生一个新的实例，可以实现单例模式&lt;/p&gt;

&lt;p&gt;BeanWrapper：提供统一的get及set方法&lt;/p&gt;

&lt;p&gt;ApplicationContext:提供框架的实现，包括BeanFactory的所有功能&lt;/p&gt;

&lt;h4 id=&quot;39bean的调用方式有哪些&quot;&gt;39、Bean的调用方式有哪些？&lt;/h4&gt;

&lt;p&gt;有三种方式可以得到Bean并进行调用：
1、使用BeanWrapper
HelloWorld hw=new HelloWorld();
BeanWrapper bw=new BeanWrapperImpl(hw);
bw.setPropertyvalue(”msg”,”HelloWorld”);
system.out.println(bw.getPropertyCalue(”msg”));
2、使用BeanFactory
InputStream is=new FileInputStream(”config.xml”);
XmlBeanFactory factory=new XmlBeanFactory(is);
HelloWorld hw=(HelloWorld) factory.getBean(”HelloWorld”);
system.out.println(hw.getMsg());
3、使用ApplicationConttext
ApplicationContext actx=new FleSystemXmlApplicationContext(”config.xml”);
HelloWorld hw=(HelloWorld) actx.getBean(”HelloWorld”);
System.out.println(hw.getMsg());&lt;/p&gt;

&lt;h4 id=&quot;40什么是ioc什么又是di他们有什么区别&quot;&gt;40、什么是IOC，什么又是DI，他们有什么区别？&lt;/h4&gt;

&lt;p&gt;依赖注入DI是一个程序设计模式和架构模型， 一些时候也称作控制反转，尽管在技术上来讲，依赖注入是一个IOC的特殊实现，依赖注入是指一个对象应用另外一个对象来提供一个特殊的能力，例如：把一个 数据库连接 以参数的形式传到另一个对象的结构方法里面 而不是在那个对象内部自行创建一个连接。控制反转和依赖注入的基本思想就是把类的依赖从类内部转化到外 部以减少依赖&lt;/p&gt;

&lt;p&gt;应用控制反转，对象在被创建的时候，将实体依赖对象的引用传递给调控系统。也可以说，依赖被注入到对象中。所以，控制反转是，关于一个对象如何获取他所依赖的对象的引用，这个责任的反转&lt;/p&gt;

&lt;h4 id=&quot;41spring有两种代理方式&quot;&gt;41、spring有两种代理方式？&lt;/h4&gt;

&lt;p&gt;若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;优点：因为有接口，所以使系统更加松耦合
缺点：为每一个目标类创建接口
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。
缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好。 #### 42、springMVC的流程？
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请求-&amp;gt;dispaterServlet-&amp;gt;映射处理器-&amp;gt;适配器-&amp;gt;handle-&amp;gt;modelView-&amp;gt;view&lt;/p&gt;

&lt;h4 id=&quot;43springmvc的优点&quot;&gt;43、Springmvc的优点？&lt;/h4&gt;

&lt;p&gt;__Spring MVC__是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。&lt;/p&gt;

&lt;h5 id=&quot;springmvc的优点&quot;&gt;Springmvc的优点:&lt;/h5&gt;

&lt;p&gt;（1）可以支持各种视图技术,而不仅仅局限于JSP；&lt;/p&gt;

&lt;p&gt;（2）与Spring框架集成（如IoC容器、AOP等）；&lt;/p&gt;

&lt;p&gt;（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。&lt;/p&gt;

&lt;p&gt;（4） 支持各种请求资源的映射策略&lt;/p&gt;

&lt;h4 id=&quot;44过滤器和拦截器的区别&quot;&gt;44、过滤器和拦截器的区别：&lt;/h4&gt;

&lt;p&gt;　　①拦截器是基于java的反射机制的，而过滤器是基于函数回调。
　　②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。
　　③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
　　④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。
　　⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。&lt;/p&gt;

&lt;p&gt;　　⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">1、为什么使用spring？ 社区活跃，使用的企业多 很多第三方框架集成了spring 提供了Ioc容器，对象间的依赖关系由spring进行控制，避免了硬代码之间的耦合 提供AOP编程的支持，通过spring的AOP功能，避免了业务之间的耦合 2、什么是IoC，为什使用IoC ? 控制什么？为什么要控制？ 把创建对象的权限托管给了spring统一管理，控制对象之间的依赖关系，避免硬编码之间的耦合 什么是反转？怎么反转： 如果把自己主动new的对象称为正转，那么通过spring创建的的对象称为反转，spring创建对象的方式使用了反转和代理的机制 3、什么是AOP，为什么使用AOP ? AOP（面向切面编程）是一种编程思想，其主要思想是让开发者把诸多业务流程中的通用功能抽取出来，单独编写功能代码，形成独立的模块，这些模块也被称为切面。AOP在spring中是的核心模块，并提供了编程模范。降低了因不同业务之间的依赖造成的耦合度。 4、什么是Spring的事务管理 作为企业级的开发框架，spring在不同的事务api上定义了一个抽象层，而开发人员不必了解底底层是事务api，就可以使用spring的事务管理器 Spring既支持编程式事务管理(也称编码式事务)，也支持声明式的事务管理 编程式事务管理：将事务管理代码嵌入到业务方法中来控制事务的提交和回滚，在编程式事务中，必须在每个业务操作中包含额外的事务管理代码 声明式事务管理：大多数情况下比编程式事务管理更好用。它将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。事务管理作为一种横切关注点，可以通过AOP方法模块化。Spring通过Spring AOP框架支持声明式事务管理。 5、Spring框架支持以下五种bean的作用域? 单例： 默认值，bean在每个spring ioc 容器中只有一个对象 多例： 一个bean的定义可以有多个实例 request： 针对每一次Http请求，Spring容器根据该bean的定义创建一个全新的实例，且该实例仅在当前Http请求内有效，而其它请求无法看到当前请求中状态的变化，当当前Http请求结束，该bean实例也将会被销毁。 seession： 在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效 global session： 在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。 6、什么是Spring的MVC框架？ springmvc 是基于mvc的web框架， spring mvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。 将web层进行职责解耦 它允许以声明的方式把请求参数和业务对象绑定。 以下组件通常使用框架提供实现： DispatcherServlet： 作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。 HandlerMapping： 通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlAdapter： 通过扩展处理器适配器，支持更多类型的处理器。 ViewResolver： 通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。 7、如何启用注解? &amp;lt;context:annotation-config/&amp;gt; 如果使用&amp;lt;context:component-scan base-package=&quot;com.tgb.web.controller.annotation&quot;&amp;gt; &amp;lt;/context:component-scan&amp;gt; 则上面内容可以省略 8、Spring MVC的请求流程? 看到这个图大家可能会有很多的疑惑，现在我们来看一下这个图的步骤：（可以对比MVC的原理图进行理解） 第一步:用户发起请求到前端控制器（DispatcherServlet） 第二步：前端控制器请求处理器映射器（HandlerMappering）去查找处理器（Handle）：通过xml配置或者注解进行查找 第三步：找到以后处理器映射器（HandlerMappering）像前端控制器返回执行链（HandlerExecutionChain） 第四步：前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler） 第五步：处理器适配器去执行Handler 第六步：Handler执行完给处理器适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndView 第八步：前端控制器请求视图解析器（ViewResolver）去进行视图解析 第九步：视图解析器像前端控制器返回View 第十步：前端控制器对视图进行渲染 第十一步：前端控制器向用户响应结果 9、web.xml的配置 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&amp;gt; &amp;lt;!--添加过滤器--&amp;gt; &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;forceEncoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; &amp;lt;!--配置spring--&amp;gt; &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:spring-config.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;!--自定义首页--&amp;gt; &amp;lt;!-- &amp;lt;welcome-file-list&amp;gt; &amp;lt;welcome-file&amp;gt;/first/page&amp;lt;/welcome-file&amp;gt; &amp;lt;/welcome-file-list&amp;gt;--&amp;gt; &amp;lt;!--配置404错误页面--&amp;gt; &amp;lt;error-page&amp;gt; &amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt; &amp;lt;location&amp;gt;/error_pages/404.jsp&amp;lt;/location&amp;gt; &amp;lt;/error-page&amp;gt; &amp;lt;!--配置500错误提示--&amp;gt; &amp;lt;error-page&amp;gt; &amp;lt;error-code&amp;gt;500&amp;lt;/error-code&amp;gt; &amp;lt;location&amp;gt;/error_pages/500.jsp&amp;lt;/location&amp;gt; &amp;lt;/error-page&amp;gt; &amp;lt;!--读取静态文件--&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;default&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;*.js&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.css&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.woff&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.woff2&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.ttf&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.png&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.jpg&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.ogg&amp;lt;/url-pattern&amp;gt; &amp;lt;url-pattern&amp;gt;*.mp4&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; &amp;lt;/web-app&amp;gt; 10、注解的处理器映射器和适配器? spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping注解映射器。 在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter注解适配器。 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置 11、spring 与 mybatis整合过程? 第一步：整合dao层 mybatis和spring整合，通过spring管理mapper接口。 使用mapper的扫描器自动扫描mapper接口在spring中进行注册。 第二步：整合service层 通过spring管理 service接口。 使用配置方式将service接口配置在spring配置文件中。 实现事务控制。 第三步：整合springmvc 由于springmvc是spring的模块，不需要整合 主要配置有： 1). mybatis配置文件sqlMapConfig.xml配置别名自动扫描(实体类) 2). mapper扫描器(接口，数据库访问接口) 3). 数据库连接池配置 4). 声明式事务配置 5). 启用注解扫描：&amp;lt;context:component-scan base-package=&quot;cn.itcast.ssm.controller&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt; 6). 配置注解映射器和适配器： &amp;lt;mvc:annotation-driven&amp;gt;&amp;lt;/mvc:annotation-driven&amp;gt; 7). 视图解析器：&amp;lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt; 8). 配置控制类： DispatcherServlet前端控制器 9). 配置spring配置文件加载类：ClassLoadListener 12、视图解析器配置前缀和后缀? &amp;lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; &amp;gt; &amp;lt;!--前缀--&amp;gt; &amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&amp;gt; &amp;lt;!--后缀--&amp;gt; &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&amp;gt; &amp;lt;/bean&amp;gt; 13、sqlMapConfig.xml，mybatis自己的配置文件? &amp;lt;properties resource=&quot;db.properties&quot;/&amp;gt; &amp;lt;environments default=&quot;development&quot;&amp;gt; &amp;lt;environment id=&quot;development&quot;&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; 14、spring自带的数据源 spring自带的数据源 DBCP数据源 C3P0数据源 JNDI数据源 15、事务控制(applicationContext-transaction.xml)? 在applicationContext-transaction.xml中使用spring声明式事务控制方法。 16、加载spring配置? ClassPathXmlApplication的使用方法// FileSystemXmlApplicationContext的使用方法 17、静态资源访问不被拦截? &amp;lt;resources mapping=&quot;/resources/**&quot; location=&quot;/resources/&quot; /&amp;gt;       &amp;lt;resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot; /&amp;gt;       &amp;lt;resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot; /&amp;gt; 18、@RequestMapping的作用? url映射： 在方法上田间 限制http请求方法： 该注解的配置属性 窄化请求映射： 在类上添加 19、controller方法的返回值? 1 返回ModelAndView 需要方法结束时，定义ModelAndView，将model和view分别进行设置。 2 返回string 如果controller方法返回string， 1). 表示返回逻辑视图名。真正视图(jsp路径)=前缀+逻辑视图名+后缀 2). redirect重定向：返回字符串格式为：&quot;redirect:queryItem.action&quot; 3). forward页面转发：返回字符串格式为：“forward:queryItem.action” 3 返回void 在controller方法形参上可以定义request和response，使用request或 response指定响应结果： 1). 使用request转向页面，如下：request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response); 2). 也可以通过response页面重定向：response.sendRedirect(&quot;url&quot;) 3). 也可以通过response指定响应结果，例如响应json数据如下： response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;json串&quot;); 20、参数绑定 1 默认支持的类型 直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。 1). HttpServletRequest：通过request对象获取请求信息 2). HttpServletResponse：通过response处理响应信息 3). HttpSession：通过session对象得到session中存放的对象 4). Model/ModelMap：model是一个接口，modelMap是一个接口实现 。作用：将model数据填充到request域。 2 简单类型 通过@RequestParam对简单类型的参数进行绑定。 如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。 如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。 通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，会报错。 4 自定义参数绑定实现日期类型绑定 对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。将请求日期数据串转成 日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。 21、Spring MVC 和 Struts2 对比? 1). Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上SpringMVC 就容易实现restful url 2). 由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。 3). 由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。 4). SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。 5). springmvc面向方法开发的（更接近service接口的开发方式），struts2面向类开发。 6). springmvc可以单例开发，struts2只能是多例开发 22、乱码处理? 1). post乱码 在web.xml添加post乱码filter：CharacterEncodingFilter 2). 对于get请求中文参数出现乱码解决方法有两个： a. 修改tomcat配置文件添加编码与工程编码一致，如下： &amp;lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&amp;gt; b. 对参数进行重新编码： String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;) ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 23、集合类型绑定 1). 数组绑定： controller方法参数使用：(Integer[] itemId) 页面统一使用:itemId 作为name 2). list绑定： pojo属性名为：itemsList 页面：itemsList[index].属性名 3). map 绑定： pojo属性名为：Map&amp;lt;String, Object&amp;gt; itemInfo = new HashMap&amp;lt;String, Object&amp;gt;(); 页面： &amp;lt;td&amp;gt;姓名：&amp;lt;inputtype=&quot;text&quot;name=&quot;itemInfo['name']&quot;/&amp;gt; 24、spring 校验 ? 1). 项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。 2). springmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。 校验思路：页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面 25、数据回显? 1). @ModelAttribute还可以将方法的返回值传到页面：在方法上加注解@ModelAttribute 2). 使用最简单方法使用model，可以不用@ModelAttribute：model.addAttribute(“id”, id); 3). springmvc默认对pojo数据进行回显。pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写） 4). public String testParam(PrintWriter out, @RequestParam(“username”) String username) { //out直接输出 26、异常处理? springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。 系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。 Spring 统一异常处理有 3 种方式，分别为： 使用 @ ExceptionHandler 注解 实现 HandlerExceptionResolver 接口 使用 @controlleradvice 注解 27、上传图片？ 1). 在页面form中提交enctype=”multipart/form-data”的数据时，需要springmvc对multipart类型的数据进行解析。 2). 在springmvc.xml中配置multipart类型解析器。 3). 方法中使用：MultipartFile attach (单个文件上传) 或者 MultipartFile[] attachs (多个文件上传) 28、Json处理 1). 加载json转换的jar包：springmvc中使用jackson的包进行json转换（@requestBody和@responseBody使用下边的包进行json转） 2). 配置json转换器。在注解适配器RequestMappingHandlerAdapter中加入messageConverters。如果使用 则会自动加入。 3). ajax 4). Controller (ResponseBody、RequestBody) 5). 注意ajax中contentType如果不设置为json类型，则传的参数为key/value类型。上面设置后，传的是json类型。 29、拦截器? 1). 定义拦截器，实现HandlerInterceptor接口。接口中提供三个方法。 a. preHandle ：进入 Handler方法之前执行，用于身份认证、身份授权，比如身份认证，如果认证不通过表示当前用户没有登陆，需要此方法拦截不再向下执行 b. postHandle：进入Handler方法之后，返回modelAndView之前执行，应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图 c. afterCompletion：执行Handler完成执行此方法，应用场景：统一异常处理，统一日志处理 2). 拦截器配置： a. 针对HandlerMapping配置(不推荐)：springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该 HandlerMapping映射成功的handler最终使用该 拦截器。 (一般不推荐使用) b. 类似全局的拦截器：springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中 30、spring中自动装配的方式有哪些？ 1、No：即不启用自动装配。 2、byName：通过属性的名字的方式查找JavaBean依赖的对象并为其注入。比如说类Computer有个属性printer，指定其autowire属性为byName后，Spring IoC容器会在配置文件中查找id/name属性为printer的bean，然后使用Seter方法为其注入。 3、byType：通过属性的类型查找JavaBean依赖的对象并为其注入。比如类Computer有个属性printer，类型为Printer，那么，指定其autowire属性为byType后，Spring IoC容器会查找Class属性为Printer的bean，使用Seter方法为其注入。 4、constructor：通byType一样，也是通过类型查找依赖对象。与byType的区别在于它不是使用Seter方法注入，而是使用构造子注入。 5、autodetect：在byType和constructor之间自动的选择注入方式。 6、default：由上级标签的default-autowire属性确定。 31、Spring中AOP的应用场景、Aop原理、好处？ AOP–Aspect Oriented Programming面向切面编程；用来封装横切关注点，具体可以在下面的场景中使用: Authentication 权限、Caching 缓存、Context passing 内容传递、Error handling 错误处理Lazy loading懒加载、Debugging调试、logging, tracing, profiling and monitoring 记录跟踪优化　校准、Performance optimization　性能优化、Persistence 持久化、Resource pooling　资源池、Synchronization　同步、Transactions 事务。 原理：AOP是面向切面编程，是通过__动态代理__的方式为程序添加统一功能，集中解决一些公共问题。 优点：1.各个步骤之间的良好隔离性耦合性大大降低 2.源代码无关性，再扩展功能的同时不对源码进行修改操作 32、Spring中IOC的作用与原理？对象创建的过程？ IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦 对象创建的过程： 读取resources文件下spring_ioc.xml Xml解析spring_ioc.xml 把解析xml里的内容存储到内存的map集合中 从map集合中读取集合内容，就是清单里的内容 遍历集合中的所有数据，并反射实例化对象 Class.forName(“com.spring.ioc.Hello”).newInstance() 33、Spring常见创建对象的注解？ @Component@Controller@ Service@ Repository 34、Spring中用到的设计模式？ 单例模式 bean默认单例 工厂模式 beanFactory ApplicationContext 代理模式 springAOP 模版模式 jdbcTemplate 观察者模式 Spring 事件驱动模型就是观察者模式很经典的一个应用。 适配器模式 Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller 35、Spring的优点？ 1.降低了组件之间的耦合性 ，实现了软件各层之间的解耦 2.可以使用容易__提供的众多服务__，如事务管理，消息服务等 3.容器提供__单例模式__支持 4.容器提供了__AOP技术__，利用它很容易实现如权限拦截，运行期监控等功能 5.容器提供了__众多的辅助类__，能加快应用的开发 6.spring对于__主流的应用框架提供了集成支持__，如hibernate，JPA，Struts等 7.spring属于低__侵入式设计__，代码的污染极低 8.独立于各种应用服务器 9.spring的DI机制降低了业务对象替换的复杂性 36、Spring Bean的作用域之间有什么区别？ Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下： singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。 prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。 request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。 Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。 global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。 全局作用域与Servlet中的session作用域效果相同。 37、Spring管理事务有几种方式？ 有两种方式： 1、编程式事务，在代码中硬编码。(不推荐使用) 2、声明式事务，在配置文件中配置（推荐使用） 声明式事务又分为两种： a、基于XML的声明式事务 b、基于注解的声明式事务 38、spring中的核心类有那些，各有什么作用？ BeanFactory：产生一个新的实例，可以实现单例模式 BeanWrapper：提供统一的get及set方法 ApplicationContext:提供框架的实现，包括BeanFactory的所有功能 39、Bean的调用方式有哪些？ 有三种方式可以得到Bean并进行调用： 1、使用BeanWrapper HelloWorld hw=new HelloWorld(); BeanWrapper bw=new BeanWrapperImpl(hw); bw.setPropertyvalue(”msg”,”HelloWorld”); system.out.println(bw.getPropertyCalue(”msg”)); 2、使用BeanFactory InputStream is=new FileInputStream(”config.xml”); XmlBeanFactory factory=new XmlBeanFactory(is); HelloWorld hw=(HelloWorld) factory.getBean(”HelloWorld”); system.out.println(hw.getMsg()); 3、使用ApplicationConttext ApplicationContext actx=new FleSystemXmlApplicationContext(”config.xml”); HelloWorld hw=(HelloWorld) actx.getBean(”HelloWorld”); System.out.println(hw.getMsg()); 40、什么是IOC，什么又是DI，他们有什么区别？ 依赖注入DI是一个程序设计模式和架构模型， 一些时候也称作控制反转，尽管在技术上来讲，依赖注入是一个IOC的特殊实现，依赖注入是指一个对象应用另外一个对象来提供一个特殊的能力，例如：把一个 数据库连接 以参数的形式传到另一个对象的结构方法里面 而不是在那个对象内部自行创建一个连接。控制反转和依赖注入的基本思想就是把类的依赖从类内部转化到外 部以减少依赖 应用控制反转，对象在被创建的时候，将实体依赖对象的引用传递给调控系统。也可以说，依赖被注入到对象中。所以，控制反转是，关于一个对象如何获取他所依赖的对象的引用，这个责任的反转 41、spring有两种代理方式？ 若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。 优点：因为有接口，所以使系统更加松耦合 缺点：为每一个目标类创建接口 若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。 优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。 缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好。 #### 42、springMVC的流程？ 请求-&amp;gt;dispaterServlet-&amp;gt;映射处理器-&amp;gt;适配器-&amp;gt;handle-&amp;gt;modelView-&amp;gt;view 43、Springmvc的优点？ __Spring MVC__是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。 Springmvc的优点: （1）可以支持各种视图技术,而不仅仅局限于JSP； （2）与Spring框架集成（如IoC容器、AOP等）； （3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。 （4） 支持各种请求资源的映射策略 44、过滤器和拦截器的区别： 　　①拦截器是基于java的反射机制的，而过滤器是基于函数回调。 　　②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。 　　③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。 　　④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。 　　⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。 　　⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</summary></entry><entry><title type="html">什么是IOC(控制反转)、DI(依赖注入)</title><link href="http://localhost:4000/mianshi/spring/0705/02" rel="alternate" type="text/html" title="什么是IOC(控制反转)、DI(依赖注入)" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/spring/0705/%E4%BB%80%E4%B9%88%E6%98%AFIOC(%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)%E3%80%81DI(%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)</id><content type="html" xml:base="http://localhost:4000/mianshi/spring/0705/02">&lt;p&gt;学习过Spring框架的人一定都会听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，总觉得IoC 、DI这两个概念是模糊不清的，是很难理解的，今天和大家分享网上的一些技术大牛们对Spring框架的IOC的理解以及谈谈我对Spring Ioc的理解。&lt;/p&gt;

&lt;h2 id=&quot;一分享iteye的开涛对ioc的精彩讲解&quot;&gt;一、分享Iteye的开涛对Ioc的精彩讲解&lt;/h2&gt;

&lt;p&gt;　　首先要分享的是Iteye的开涛这位技术牛人对Spring框架的IOC的理解，写得非常通俗易懂，以下内容全部来自原文，原文地址：http://jinnianshilongnian.iteye.com/blog/1413846&lt;/p&gt;

&lt;h3 id=&quot;11ioc是什么&quot;&gt;1.1、IoC是什么&lt;/h3&gt;

&lt;p&gt;　　&lt;strong&gt;Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。&lt;/strong&gt;在Java开发中，&lt;strong&gt;Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。&lt;/strong&gt;如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：&lt;/p&gt;

&lt;p&gt;　　●&lt;strong&gt;谁控制谁，控制什么：&lt;/strong&gt;传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；&lt;strong&gt;谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　●&lt;strong&gt;为何是反转，哪些方面反转了：&lt;/strong&gt;有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？&lt;strong&gt;因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvMjg5MjMzLzIwMTUwMS8yNjE0MjEzNzgzMTgyOTIuanBn.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图1-1 传统应用程序示意图&lt;/p&gt;

&lt;p&gt;　　当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/70.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图1-2有IoC/DI容器后程序结构示意图&lt;/p&gt;

&lt;h3 id=&quot;12ioc能做什么&quot;&gt;1.2、IoC能做什么&lt;/h3&gt;

&lt;p&gt;　　IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。&lt;/p&gt;

&lt;p&gt;　　其实&lt;strong&gt;IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;13ioc和di&quot;&gt;1.3、IoC和DI&lt;/h3&gt;

&lt;p&gt;　　&lt;strong&gt;DI—Dependency Injection，即“依赖注入”&lt;/strong&gt;：&lt;strong&gt;组件之间依赖关系&lt;/strong&gt;由容器在运行期决定，形象的说，即&lt;strong&gt;由容器动态的将某个依赖关系注入到组件之中&lt;/strong&gt;。&lt;strong&gt;依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。&lt;/strong&gt;通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。&lt;/p&gt;

&lt;p&gt;　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：&lt;/p&gt;

&lt;p&gt;　　●&lt;strong&gt;谁依赖于谁：&lt;/strong&gt;当然是&lt;strong&gt;应用程序依赖于IoC容器&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;　　●&lt;strong&gt;为什么需要依赖：&lt;/strong&gt;&lt;strong&gt;应用程序需要IoC容器来提供对象需要的外部资源&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;　　●&lt;strong&gt;谁注入谁：&lt;/strong&gt;很明显是&lt;strong&gt;IoC容器注入应用程序某个对象，应用程序依赖的对象&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;●注入了什么：&lt;/strong&gt;就是&lt;strong&gt;注入某个对象所需要的外部资源（包括对象、资源、常量数据）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;IoC和DI&lt;/strong&gt;由什么&lt;strong&gt;关系&lt;/strong&gt;呢？其实它们&lt;strong&gt;是同一个概念的不同角度描述&lt;/strong&gt;，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，&lt;strong&gt;“&lt;/strong&gt;&lt;strong&gt;依赖注入”&lt;/strong&gt;&lt;strong&gt;明确描述了“被注入对象依赖IoC&lt;/strong&gt;&lt;strong&gt;容器配置依赖对象”。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。&lt;/p&gt;

&lt;h2 id=&quot;二分享bromon的blog上对ioc与di浅显易懂的讲解&quot;&gt;二、分享Bromon的blog上对IoC与DI浅显易懂的讲解&lt;/h2&gt;

&lt;h3 id=&quot;21ioc控制反转&quot;&gt;2.1、IoC(控制反转)&lt;/h3&gt;

&lt;p&gt;　　首先想说说&lt;strong&gt;IoC（Inversion of Control，控制反转）&lt;/strong&gt;。这是&lt;strong&gt;spring的核心&lt;/strong&gt;，贯穿始终。&lt;strong&gt;所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。&lt;/strong&gt;这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。&lt;/p&gt;

&lt;p&gt;　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。&lt;strong&gt;Spring所倡导的开发方式&lt;/strong&gt;就是如此，&lt;strong&gt;所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;22di依赖注入&quot;&gt;2.2、DI(依赖注入)&lt;/h3&gt;

&lt;p&gt;　　&lt;strong&gt;IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的&lt;/strong&gt;。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。&lt;/p&gt;

&lt;p&gt;　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">学习过Spring框架的人一定都会听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，总觉得IoC 、DI这两个概念是模糊不清的，是很难理解的，今天和大家分享网上的一些技术大牛们对Spring框架的IOC的理解以及谈谈我对Spring Ioc的理解。 一、分享Iteye的开涛对Ioc的精彩讲解 　　首先要分享的是Iteye的开涛这位技术牛人对Spring框架的IOC的理解，写得非常通俗易懂，以下内容全部来自原文，原文地址：http://jinnianshilongnian.iteye.com/blog/1413846 1.1、IoC是什么 　　Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： 　　●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 　　●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 　　用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来： 图1-1 传统应用程序示意图 　　当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示: 图1-2有IoC/DI容器后程序结构示意图 1.2、IoC能做什么 　　IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 　　其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。 　　IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 1.3、IoC和DI 　　DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： 　　●谁依赖于谁：当然是应用程序依赖于IoC容器； 　　●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； 　　●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； 　　●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 　　IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 　　看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。 二、分享Bromon的blog上对IoC与DI浅显易懂的讲解 2.1、IoC(控制反转) 　　首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 2.2、DI(依赖注入) 　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。</summary></entry><entry><title type="html">redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？</title><link href="http://localhost:4000/mianshi/Redis/0705/03" rel="alternate" type="text/html" title="redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/Redis/0705/redis%20%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%3F%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%3F%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%85%B7%E4%BD%93%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84</id><content type="html" xml:base="http://localhost:4000/mianshi/Redis/0705/03">&lt;h4 id=&quot;redis-的持久化有哪几种方式&quot;&gt;redis 的持久化有哪几种方式？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。&lt;/li&gt;
  &lt;li&gt;AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。
通过 RDB 或 AOF，都可以将 redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。&lt;/p&gt;

&lt;p&gt;如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，&lt;strong&gt;因为 AOF 中的数据更加完整。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;不同的持久化机制都有什么优缺点&quot;&gt;不同的持久化机制都有什么优缺点？&lt;/h4&gt;

&lt;h5 id=&quot;rdb-优缺点&quot;&gt;RDB 优缺点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;aof-优缺点&quot;&gt;AOF 优缺点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据。&lt;/li&gt;
  &lt;li&gt;AOF 日志文件以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。&lt;/li&gt;
  &lt;li&gt;AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。&lt;/li&gt;
  &lt;li&gt;AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。&lt;/li&gt;
  &lt;li&gt;对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。&lt;/li&gt;
  &lt;li&gt;AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）&lt;/li&gt;
  &lt;li&gt;以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;rdb-和-aof-到底该如何选择&quot;&gt;RDB 和 AOF 到底该如何选择&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;不要仅仅使用 RDB，因为那样会导致你丢失很多数据；&lt;/li&gt;
  &lt;li&gt;也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；&lt;/li&gt;
  &lt;li&gt;redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">redis 的持久化有哪几种方式？ RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。 AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。 通过 RDB 或 AOF，都可以将 redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。 如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。 如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。 不同的持久化机制都有什么优缺点？ RDB 优缺点 RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。 RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。 相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。 如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。 RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。 AOF 优缺点 AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据。 AOF 日志文件以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。 AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。 AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。 对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。 AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低） 以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。 RDB 和 AOF 到底该如何选择 不要仅仅使用 RDB，因为那样会导致你丢失很多数据； 也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug； redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</summary></entry><entry><title type="html">Spring中的事务管理详解</title><link href="http://localhost:4000/mianshi/spring/0705/11" rel="alternate" type="text/html" title="Spring中的事务管理详解" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/spring/0705/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3</id><content type="html" xml:base="http://localhost:4000/mianshi/spring/0705/11">&lt;p&gt;在这里主要介绍Spring对事务管理的一些理论知识，实战方面参考上一篇博文:&lt;/p&gt;

&lt;p&gt;http://www.cnblogs.com/longshiyVip/p/5061547.html&lt;/p&gt;

&lt;h4 id=&quot;1-事务简介&quot;&gt;&lt;strong&gt;1. 事务简介：&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;事务管理是企业级应用程序开发中必不可少的技术，用来确保数据的完整性和一致性&lt;/p&gt;

&lt;p&gt;事务就是一系列的动作，它们被当作一个单独的工作单元。这些动作要么全部完成，要么全部不起作用&lt;/p&gt;

&lt;h4 id=&quot;2-事务的四个关键属性acid&quot;&gt;&lt;strong&gt;2. 事务的四个关键属性(ACID)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;① 原子性(atomicity):事务是一个原子操作，有一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用
② 一致性(consistency):一旦所有事务动作完成，事务就被提交。数据和资源就处于一种满足业务规则的一致性状态中
③ 隔离性(isolation):可能有许多事务会同时处理相同的数据，因此每个事物都应该与其他事务隔离开来，防止数据损坏
④ 持久性(durability):一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响。通常情况下，事务的结果被写到持久化存储器中&lt;/p&gt;

&lt;h4 id=&quot;3-spring中的事务管理&quot;&gt;&lt;strong&gt;3. Spring中的事务管理&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;作为企业级应用程序框架，Spring在不同的事务管理API之上定义了一个抽象层。而应用程序开发人员不必了解底层的事务管理API，就可以使用Spring的事务管理机制。&lt;/p&gt;

&lt;p&gt;Spring既支持编程式事务管理(也称编码式事务)，也支持声明式的事务管理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;编程式事务管理&lt;/strong&gt;：将事务管理代码嵌入到业务方法中来控制事务的提交和回滚，在编程式事务中，必须在每个业务操作中包含额外的事务管理代码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;声明式事务管理&lt;/strong&gt;：大多数情况下比编程式事务管理更好用。它将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。事务管理作为一种横切关注点，可以通过AOP方法模块化。Spring通过Spring AOP框架支持声明式事务管理。&lt;/p&gt;

&lt;h4 id=&quot;4-spring的事务管理器&quot;&gt;&lt;strong&gt;4. Spring的事务管理器&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Spring并不直接管理事务，而是提供了多种事务管理器，它们将事务管理的职责委托给JTA或其他持久化机制所提供的平台相关的事务实现。每个事务管理器都会充当某一特定平台的事务实现的门面，这使得用户在Spring中使用事务时，几乎不用关注实际的事务实现是什么。&lt;/p&gt;

&lt;p&gt;Spring提供了许多内置事务管理器实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;DataSourceTransactionManager：&lt;/strong&gt;位于org.springframework.jdbc.datasource包中，数据源事务管理器，提供对单个javax.sql.DataSource事务管理，用于Spring JDBC抽象框架、iBATIS或MyBatis框架的事务管理；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;JdoTransactionManager：&lt;/strong&gt;位于org.springframework.orm.jdo包中，提供对单个javax.jdo.PersistenceManagerFactory事务管理，用于集成JDO框架时的事务管理；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;JpaTransactionManager：&lt;/strong&gt;位于org.springframework.orm.jpa包中，提供对单个javax.persistence.EntityManagerFactory事务支持，用于集成JPA实现框架时的事务管理；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HibernateTransactionManager：&lt;/strong&gt;位于org.springframework.orm.hibernate3包中，提供对单个org.hibernate.SessionFactory事务支持，用于集成Hibernate框架时的事务管理；该事务管理器只支持Hibernate3+版本，且Spring3.0+版本只支持Hibernate 3.2+版本；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;JtaTransactionManager：&lt;/strong&gt;位于org.springframework.transaction.jta包中，提供对分布式事务管理的支持，并将事务管理委托给Java EE应用服务器事务管理器；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OC4JjtaTransactionManager：&lt;/strong&gt;位于org.springframework.transaction.jta包中，Spring提供的对OC4J10.1.3+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;WebSphereUowTransactionManager：&lt;/strong&gt;位于org.springframework.transaction.jta包中，Spring提供的对WebSphere 6.0+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;WebLogicJtaTransactionManager：&lt;/strong&gt;位于org.springframework.transaction.jta包中，Spring提供的对WebLogic 8.1+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spring不仅提供这些事务管理器，还提供对如JMS事务管理的管理器等，Spring提供一致的事务抽象如图9-1所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/632fd877-8165-3a60-ae7e-6429da8ed136.jpg&quot; alt=&quot;点击查看原始大小图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　图9-1 Spring事务管理器&lt;/p&gt;

&lt;p&gt;接下来让我们学习一下如何在Spring配置文件中定义事务管理器：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;声明对本地事务的支持：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;**a)JDBC及iBATIS、MyBatis框架事务管理器 **&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;txManager&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过dataSource属性指定需要事务管理的单个javax.sql.DataSource对象。在幕后DataSourceTransactionManager通过调用java.sql.Connection来管理事务,而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务。同样，事务失败时通过调用rollback()方法进行回滚。&lt;/p&gt;

&lt;p&gt;**b)Jdo事务管理器 **&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;txManager&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.orm.jdo.JdoTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;persistenceManagerFactory&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;persistenceManagerFactory&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过persistenceManagerFactory属性指定需要事务管理的javax.jdo.PersistenceManagerFactory对象。&lt;/p&gt;

&lt;p&gt;**c)Jpa事务管理器 **&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;txManager&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;entityManagerFactory&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;entityManagerFactory&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过entityManagerFactory属性指定需要事务管理的javax.persistence.EntityManagerFactory对象。&lt;/p&gt;

&lt;p&gt;还需要为entityManagerFactory对象指定jpaDialect属性，该属性所对应的对象指定了如何获取连接对象、开启事务、关闭事务等事务管理相关的行为。&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;entityManagerFactory&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        ……
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jpaDialect&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jpaDialect&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jpaDialect&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;**d)Hibernate事务管理器 **&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;txManager&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sessionFactory&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sessionFactory&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;在幕后HibernateTransactionManager&lt;/strong&gt;将事务管理的职责委托给&lt;strong&gt;org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，*&lt;em&gt;HibernateTransactionManager*&lt;/em&gt;将会调用*&lt;em&gt;Transaction*&lt;/em&gt;对象的commit()方法来提交事务。同样，事务失败时通过调用*&lt;em&gt;**Transaction**&lt;/em&gt;*的rollback()方法进行回滚。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spring对全局事务的支持：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;**a)Jta事务管理器 **&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;xmlns:jee=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/jee&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/jee
       http://www.springframework.org/schema/jee/spring-jee-3.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;jee:jndi-lookup&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;jndi-name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jdbc/test&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;txManager&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transactionManagerName&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; java:comp/TransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“dataSource”Bean表示从JNDI中获取的数据源，而txManager是JTA事务管理器，其中属性transactionManagerName指定了JTA事务管理器的JNDI名字，从而将事务管理委托给该事务管理器。&lt;/p&gt;

&lt;h4 id=&quot;5-定义事务属性&quot;&gt;5. 定义事务属性&lt;/h4&gt;

&lt;p&gt;在Spring中，声明式事务是通过事务属性来定义的，事务属性描述了事务策略如何应用到方法上。事务属性包含了5个方面，尽管Spring提供了多种声明式事务的机制，但是所有的方式都依赖这五个参数来控制如何管理事务策略。声明式事务通过&lt;strong&gt;传播行为，隔离级别，只读提示，事务超时及回滚规则&lt;/strong&gt;来进行定义。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spring事务的传播行为：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。&lt;/p&gt;

&lt;p&gt;事务的传播行为可以由传播属性指定。Spring定义了7种传播行为：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;传播行为&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;PROPAGATION_MANDATORY&lt;/td&gt;
      &lt;td&gt;表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PROPAGATION_NESTED&lt;/td&gt;
      &lt;td&gt;表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PROPAGATION_NEVER&lt;/td&gt;
      &lt;td&gt;表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PROPAGATION_NOT_SUPPORTED&lt;/td&gt;
      &lt;td&gt;表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PROPAGATION_REQUIRED&lt;/td&gt;
      &lt;td&gt;表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PROPAGATION_REQUIRED_NEW&lt;/td&gt;
      &lt;td&gt;表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PROPAGATION_SUPPORTS&lt;/td&gt;
      &lt;td&gt;表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中PROPAGATION_REQUIRED为默认的传播属性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spring事务的隔离级别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;隔离级别定义了一个事务可能受其他并发事务影响的程度。在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发，虽然是必须的，可是会导致下面的问题。&lt;/p&gt;

&lt;p&gt;并发事务所导致的问题可以分为以下三类：&lt;/p&gt;

&lt;p&gt;① &lt;strong&gt;脏读(Dirty reads)&lt;/strong&gt;：脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。&lt;/p&gt;

&lt;p&gt;② &lt;strong&gt;不可重复读(Nonrepeatable read)&lt;/strong&gt;：不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间更新了数据&lt;/p&gt;

&lt;p&gt;③ &lt;strong&gt;幻读(Phantom read)&lt;/strong&gt;：幻读与不可重复读类似。它发生在一个事务(T1)读取了几行数据，接着另一个并发事务(T2)插入了一些数据时。在随后的查询中，第一个事务(T1)就会发现多了一些原本不存在的记录&lt;/p&gt;

&lt;p&gt;Spring事务的隔离级别&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ISOLATION_DEFAULT： 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.
   另外四个与JDBC的隔离级别相对应&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。
   这种隔离级别会产生脏读，不可重复读和幻像读。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。
   它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。
   除了防止脏读，不可重复读外，还避免了幻像读。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Spring事务的只读&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。“只读事务”仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spring事务的事务超时&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了使应用程序更好的运行，事务不能运行太长的时间。因此，声明式事务的第四个特性就是超时。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spring事务的回滚规则&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认情况下，事务只有在遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚，但是也可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">在这里主要介绍Spring对事务管理的一些理论知识，实战方面参考上一篇博文: http://www.cnblogs.com/longshiyVip/p/5061547.html 1. 事务简介： 事务管理是企业级应用程序开发中必不可少的技术，用来确保数据的完整性和一致性 事务就是一系列的动作，它们被当作一个单独的工作单元。这些动作要么全部完成，要么全部不起作用 2. 事务的四个关键属性(ACID) ① 原子性(atomicity):事务是一个原子操作，有一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用 ② 一致性(consistency):一旦所有事务动作完成，事务就被提交。数据和资源就处于一种满足业务规则的一致性状态中 ③ 隔离性(isolation):可能有许多事务会同时处理相同的数据，因此每个事物都应该与其他事务隔离开来，防止数据损坏 ④ 持久性(durability):一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响。通常情况下，事务的结果被写到持久化存储器中 3. Spring中的事务管理 作为企业级应用程序框架，Spring在不同的事务管理API之上定义了一个抽象层。而应用程序开发人员不必了解底层的事务管理API，就可以使用Spring的事务管理机制。 Spring既支持编程式事务管理(也称编码式事务)，也支持声明式的事务管理 编程式事务管理：将事务管理代码嵌入到业务方法中来控制事务的提交和回滚，在编程式事务中，必须在每个业务操作中包含额外的事务管理代码 声明式事务管理：大多数情况下比编程式事务管理更好用。它将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。事务管理作为一种横切关注点，可以通过AOP方法模块化。Spring通过Spring AOP框架支持声明式事务管理。 4. Spring的事务管理器 Spring并不直接管理事务，而是提供了多种事务管理器，它们将事务管理的职责委托给JTA或其他持久化机制所提供的平台相关的事务实现。每个事务管理器都会充当某一特定平台的事务实现的门面，这使得用户在Spring中使用事务时，几乎不用关注实际的事务实现是什么。 Spring提供了许多内置事务管理器实现： DataSourceTransactionManager：位于org.springframework.jdbc.datasource包中，数据源事务管理器，提供对单个javax.sql.DataSource事务管理，用于Spring JDBC抽象框架、iBATIS或MyBatis框架的事务管理； JdoTransactionManager：位于org.springframework.orm.jdo包中，提供对单个javax.jdo.PersistenceManagerFactory事务管理，用于集成JDO框架时的事务管理； JpaTransactionManager：位于org.springframework.orm.jpa包中，提供对单个javax.persistence.EntityManagerFactory事务支持，用于集成JPA实现框架时的事务管理； HibernateTransactionManager：位于org.springframework.orm.hibernate3包中，提供对单个org.hibernate.SessionFactory事务支持，用于集成Hibernate框架时的事务管理；该事务管理器只支持Hibernate3+版本，且Spring3.0+版本只支持Hibernate 3.2+版本； JtaTransactionManager：位于org.springframework.transaction.jta包中，提供对分布式事务管理的支持，并将事务管理委托给Java EE应用服务器事务管理器； OC4JjtaTransactionManager：位于org.springframework.transaction.jta包中，Spring提供的对OC4J10.1.3+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持； WebSphereUowTransactionManager：位于org.springframework.transaction.jta包中，Spring提供的对WebSphere 6.0+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持； WebLogicJtaTransactionManager：位于org.springframework.transaction.jta包中，Spring提供的对WebLogic 8.1+应用服务器事务管理器的适配器，此适配器用于对应用服务器提供的高级事务的支持。 Spring不仅提供这些事务管理器，还提供对如JMS事务管理的管理器等，Spring提供一致的事务抽象如图9-1所示。 　　　　　　　　　　　　图9-1 Spring事务管理器 接下来让我们学习一下如何在Spring配置文件中定义事务管理器： 声明对本地事务的支持： **a)JDBC及iBATIS、MyBatis框架事务管理器 ** &amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt; &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt; &amp;lt;/bean&amp;gt; 通过dataSource属性指定需要事务管理的单个javax.sql.DataSource对象。在幕后DataSourceTransactionManager通过调用java.sql.Connection来管理事务,而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务。同样，事务失败时通过调用rollback()方法进行回滚。 **b)Jdo事务管理器 ** &amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.jdo.JdoTransactionManager&quot;&amp;gt; &amp;lt;property name=&quot;persistenceManagerFactory&quot; ref=&quot;persistenceManagerFactory&quot;/&amp;gt; &amp;lt;/bean&amp;gt; 通过persistenceManagerFactory属性指定需要事务管理的javax.jdo.PersistenceManagerFactory对象。 **c)Jpa事务管理器 ** &amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&amp;gt; &amp;lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&amp;gt; &amp;lt;/bean&amp;gt; 通过entityManagerFactory属性指定需要事务管理的javax.persistence.EntityManagerFactory对象。 还需要为entityManagerFactory对象指定jpaDialect属性，该属性所对应的对象指定了如何获取连接对象、开启事务、关闭事务等事务管理相关的行为。 &amp;lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&amp;gt; …… &amp;lt;property name=&quot;jpaDialect&quot; ref=&quot;jpaDialect&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;jpaDialect&quot; class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot;/&amp;gt; **d)Hibernate事务管理器 ** &amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&amp;gt; &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt; &amp;lt;/bean&amp;gt; 在幕后HibernateTransactionManager将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，*HibernateTransactionManager*将会调用*Transaction*对象的commit()方法来提交事务。同样，事务失败时通过调用***Transaction***的rollback()方法进行回滚。 Spring对全局事务的支持： **a)Jta事务管理器 ** &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd&quot;&amp;gt; &amp;lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;jdbc/test&quot;/&amp;gt; &amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&amp;gt; &amp;lt;property name=&quot;transactionManagerName&quot; value=&quot; java:comp/TransactionManager&quot;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt; “dataSource”Bean表示从JNDI中获取的数据源，而txManager是JTA事务管理器，其中属性transactionManagerName指定了JTA事务管理器的JNDI名字，从而将事务管理委托给该事务管理器。 5. 定义事务属性 在Spring中，声明式事务是通过事务属性来定义的，事务属性描述了事务策略如何应用到方法上。事务属性包含了5个方面，尽管Spring提供了多种声明式事务的机制，但是所有的方式都依赖这五个参数来控制如何管理事务策略。声明式事务通过传播行为，隔离级别，只读提示，事务超时及回滚规则来进行定义。 Spring事务的传播行为： 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。 事务的传播行为可以由传播属性指定。Spring定义了7种传播行为： 传播行为 含义 PROPAGATION_MANDATORY 表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常 PROPAGATION_NESTED 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务 PROPAGATION_NEVER 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常 PROPAGATION_NOT_SUPPORTED 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager PROPAGATION_REQUIRED 表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务 PROPAGATION_REQUIRED_NEW 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager PROPAGATION_SUPPORTS 表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行 其中PROPAGATION_REQUIRED为默认的传播属性 Spring事务的隔离级别 隔离级别定义了一个事务可能受其他并发事务影响的程度。在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发，虽然是必须的，可是会导致下面的问题。 并发事务所导致的问题可以分为以下三类： ① 脏读(Dirty reads)：脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。 ② 不可重复读(Nonrepeatable read)：不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间更新了数据 ③ 幻读(Phantom read)：幻读与不可重复读类似。它发生在一个事务(T1)读取了几行数据，接着另一个并发事务(T2)插入了一些数据时。在随后的查询中，第一个事务(T1)就会发现多了一些原本不存在的记录 Spring事务的隔离级别 ISOLATION_DEFAULT： 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别. 另外四个与JDBC的隔离级别相对应 ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。 这种隔离级别会产生脏读，不可重复读和幻像读。 ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据 ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。 它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。 ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 除了防止脏读，不可重复读外，还避免了幻像读。 Spring事务的只读 “只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。“只读事务”仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可。 Spring事务的事务超时 为了使应用程序更好的运行，事务不能运行太长的时间。因此，声明式事务的第四个特性就是超时。 Spring事务的回滚规则 默认情况下，事务只有在遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚，但是也可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</summary></entry></feed>