<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.1.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2020-07-05T22:06:09+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JAVA 牛牛</title><subtitle>主要是想看下自己还能在多做些什么
</subtitle><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><entry><title type="html">降低Redis内存占用</title><link href="http://localhost:4000/mianshi/Redis/0705/04" rel="alternate" type="text/html" title="降低Redis内存占用" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/Redis/0705/%E9%99%8D%E4%BD%8ERedis%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8</id><content type="html" xml:base="http://localhost:4000/mianshi/Redis/0705/04">&lt;p&gt;&lt;strong&gt;1、降低redis内存占用的优点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　1、有助于减少创建快照和加载快照所用的时间&lt;/p&gt;

&lt;p&gt;　　2、提升载入AOF文件和重写AOF文件时的效率&lt;/p&gt;

&lt;p&gt;　　3、缩短从服务器进行同步所需的时间&lt;/p&gt;

&lt;p&gt;　　4、无需添加额外的硬件就可以让redis存贮更多的数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、短结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Redis为列表、集合、散列、有序集合提供了一组配置选项，这些选项可以让redis以更节约的方式存储较短的结构。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2.1、ziplist压缩列表（列表、散列、有续集和）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　通常情况下使用的存储方式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/1734531-20190723145231193-1166923194.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;p&gt;　　当列表、散列、有序集合的长度较短或者体积较小的时候，redis将会采用一种名为ziplist的紧凑存储方式来存储这些结构。&lt;/p&gt;

&lt;p&gt;　　ziplist是列表、散列、有序集合这三种不同类型的对象的一种非结构化表示，它会以序列化的方式存储数据，这些序列化的数据每次被读取的时候都需要进行解码，每次写入的时候也要进行编码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;双向列表与压缩列表的区别：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　  为了了解压缩列表比其他数据结构更加节约内存，我们以列表结构为例进行深入研究。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;典型的双向列表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　1、在典型双向列表里面，每个值都都会有一个节点表示。每个节点都会带有指向链表前一个节点和后一个节点的指针，以及一个指向节点包含的字符串值的指针。&lt;/p&gt;

&lt;p&gt;　　　　2、每个节点包含的字符串值都会分为三部分进行存储。包括字符串长度、字符串值中剩余可用字节数量、以空字符结尾的字符串本身。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;例子：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　假若一个某个节点存储了’abc’字符串，在32位的平台下保守估计需要21个字节的额外开销（三个指针+两个int+空字符即：3&lt;em&gt;4+2&lt;/em&gt;4+1=21）&lt;/p&gt;

&lt;p&gt;　　由例子可知存储一个3字节字符串就需要付出至少21个字节的额外开销。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;ziplist&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　压缩列表是由节点组成的序列，每个节点包含两个长度和一个字符串。第一个长度记录前一个节点的长度（用于对压缩列表从后向前遍历）；第二个长度是记录本当前点的长度；被存储的字符串。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;例子：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　存储字符串’abc’，两个长度都可以用1字节来存储，因此所带来的额外开销为2字节（两个长度即1+1=2）&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　压缩列表是通过避免存储额外的指针和元数据，从而达到降低额外的开销。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;配置：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 #list2 list-max-ziplist-entries 51
2 #表示允许包含的最大元素数量
3 list-max-ziplist-value 64    #表示压缩节点允许存储的最大体积
4 #hash                  #当超过任一限制后，将不会使用ziplist方式进行存储
5 hash-max-ziplist-entries 512
6 hash-max-ziplist-value 64
7 #zset
8 zset-max-ziplist-entries 128
9 zset-max-ziplist-value 64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;测试list:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;1、建立test.php文件&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 #test.php
2 &amp;lt;?php
3     $redis=new Redis();
4     $redis-&amp;gt;connect('192.168.95.11','6379');
5         for ($i=0; $i&amp;lt;512  ; $i++) 
6     { 
7         $redis-&amp;gt;lpush('test-list',$i.'-test-list');  #往test-list推入512条数据
8     }
9 ?&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/Users/minp/GitHub/javaniuniu.github.io/_posts/docs-mianshi/1734531-20190723145957416-1822584668.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　　　此时的test-list中含有512条数据，没有超除配置文件中的限制&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2、往test-list中再推入一条数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/1734531-20190723150126455-831466601.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　　　此时test-list含有513条数据，大于配置文件中限制的512条，索引将放弃ziplist存储方式，采用其原来的linkedlist存储方式,散列与有序集合同理。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;2.2、intset整数集合（集合）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　前提条件，集合中包含的所有member都可以被解析为十进制整数。&lt;/p&gt;

&lt;p&gt;　　　　以有序数组的方式存储集合不仅可以降低内存消耗，还可以提升集合操作的执行速度。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;配置：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 set-max-intset-entries  512   #限制集合中member个数，超出则不采取i那个tset存储
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　　&lt;strong&gt;测试：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　建立test.php文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1 #test.php
 2 &amp;lt;?php
 3     $redis=new Redis();
 4     $redis-&amp;gt;connect('192.168.95.11','6379');
 5         for ($i=0; $i&amp;lt;512  ; $i++) 
 6     { 
 7         $redis-&amp;gt;sadd('test-set',$i);   #给集合test-set插入512个member
 8     } 
 9 ?&amp;gt;           
10  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　　&lt;strong&gt;2.3、性能问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　不管列表、散列、有序集合、集合，当超出限制的条件后，就会转换为更为典型的底层结构类型。因为随着紧凑结构的体积不断变大，操作这些结构的速度将会变得越来越慢。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;测试：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　#将采用list进行代表性测试&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;测试思路：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;strong&gt;1、在默认配置下往test-list推入50000条数据，查看所需时间；接着在使用rpoplpush将test-list数据全部推入到新列表list-new中，查看所需时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;strong&gt;2、修改配置，list-max-ziplist-entries 100000，再执行上面的同样操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;strong&gt;3、对比时间，得出结论&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　&lt;strong&gt;默认配置下测试：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　&lt;strong&gt;1、插入数据，查看时间&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1 #test1.php 
 2 &amp;lt;?php 
 3     header(&quot;content-type: text/html;charset=utf8;&quot;); 
 4     $redis=new Redis(); 
 5     $redis-&amp;gt;connect('192.168.95.11','6379'); 
 6     $start=time(); 
 7         for ($i=0; $i&amp;lt;50000  ; $i++) 
 8     { 
 9         $redis-&amp;gt;lpush('test-list',$i.'-aaaassssssddddddkkk');
10     }
11     $end=time();
12 echo &quot;插入耗时为：&quot;.($end-$start).'s';
13 ?&amp;gt;                
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/1734531-20190723150824482-2109961153.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　结果耗时4秒&lt;/p&gt;

&lt;p&gt;　　　　　　　　&lt;strong&gt;2、执行相应命令，查看耗时&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1 #test2.php 
 2 &amp;lt;?php 
 3     header(&quot;content-type: text/html;charset=utf8;&quot;); 
 4     $redis=new Redis(); 
 5     $redis-&amp;gt;connect('192.168.95.11','6379'); 
 6     $start=time(); 
 7     $num=0;  
 8     while($redis-&amp;gt;rpoplpush('test-list','test-new')) 
 9     {
10         $num+=1;
11     }
12     echo '执行次数为：'.$num.&quot;&amp;lt;br/&amp;gt;&quot;;
13 $end=time();
14 echo &quot;耗时为：&quot;.($end-$start).'s';
15 ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　　　　　　　　&lt;strong&gt;更改配置文件下测试&lt;/strong&gt;　　&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　&lt;strong&gt;1、先修改配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　list-max-ziplist-entries 100000 #将这个值修改大一点，可以更好的凸显对性能的影响&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　list-max-ziplist-value 64  #此值可不做修改&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　&lt;strong&gt;2、插入数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　执行test1.php&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　结果为：耗时12s&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/1734531-20190723151326952-1965499675.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　&lt;strong&gt;3、执行相应命令，查看耗时&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　执行test2.php&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　结果为：执行次数：50000，耗时12s&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;strong&gt;在本机中执行测试50000条数据就相差8s，若在高并发下，长压缩列表和大整数集合将起不到任何的优化，反而使得性能降低。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、片结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　分片的本质就是基于简单的规则将数据划分为更小的部分，然后根据数据所属的部分来决定将数据发送到哪个位置上。很多数据库使用这种技术来扩展存储空间，并提高自己所能处理的负载量。&lt;/p&gt;

&lt;p&gt;　　结合前面讲到的，我们不难发现分片结构对于redis的重要意义。因此我们需要在配置文件中关于ziplist以及intset的相关配置做出适当的调整。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.1、分片式散列&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　#ShardHash.class.php&lt;/p&gt;

&lt;p&gt;　　散列分片主要是根据基础键以及散列包含的键计算出分片键ID，然后再与基础键拼接成一个完整的分片键。在执行hset与hget以及大部分hash命令时，都需要先将key（field）通过shardKey方法处理，得到分片键才能够进行下一步操作。&lt;/p&gt;

&lt;p&gt;回到顶部&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.2、分片式集合&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　如何构造分片式集合才能够让它更节省内存，性能更加强大呢？主要的思路就是，将集合里面的存储的数据尽量在不改变其原有功能的情况下转换成可以被解析为十进制的数据。根据前面所讲到的，当集合中的所有成员都能够被解析为十进制数据时，将会采用intset存储方式，这不仅能够节省内存，而且还可以提高响应的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、将信息打包转换成存储字节&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　结合前面所讲的分片技术，采用string分片结构为大量连续的ID用户存储信息。&lt;/p&gt;

&lt;p&gt;　　使用定长字符串，为每一个ID分配n个字节进行存储相应的信息。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">1、降低redis内存占用的优点 　　1、有助于减少创建快照和加载快照所用的时间 　　2、提升载入AOF文件和重写AOF文件时的效率 　　3、缩短从服务器进行同步所需的时间 　　4、无需添加额外的硬件就可以让redis存贮更多的数据 2、短结构 　　Redis为列表、集合、散列、有序集合提供了一组配置选项，这些选项可以让redis以更节约的方式存储较短的结构。 　　2.1、ziplist压缩列表（列表、散列、有续集和） 　　通常情况下使用的存储方式 　　 　　当列表、散列、有序集合的长度较短或者体积较小的时候，redis将会采用一种名为ziplist的紧凑存储方式来存储这些结构。 　　ziplist是列表、散列、有序集合这三种不同类型的对象的一种非结构化表示，它会以序列化的方式存储数据，这些序列化的数据每次被读取的时候都需要进行解码，每次写入的时候也要进行编码。 双向列表与压缩列表的区别： 　 为了了解压缩列表比其他数据结构更加节约内存，我们以列表结构为例进行深入研究。 　　典型的双向列表 　　　　1、在典型双向列表里面，每个值都都会有一个节点表示。每个节点都会带有指向链表前一个节点和后一个节点的指针，以及一个指向节点包含的字符串值的指针。 　　　　2、每个节点包含的字符串值都会分为三部分进行存储。包括字符串长度、字符串值中剩余可用字节数量、以空字符结尾的字符串本身。 　　例子： 　　假若一个某个节点存储了’abc’字符串，在32位的平台下保守估计需要21个字节的额外开销（三个指针+两个int+空字符即：34+24+1=21） 　　由例子可知存储一个3字节字符串就需要付出至少21个字节的额外开销。 　　ziplist 　　　　压缩列表是由节点组成的序列，每个节点包含两个长度和一个字符串。第一个长度记录前一个节点的长度（用于对压缩列表从后向前遍历）；第二个长度是记录本当前点的长度；被存储的字符串。 　　例子： 　　存储字符串’abc’，两个长度都可以用1字节来存储，因此所带来的额外开销为2字节（两个长度即1+1=2） 　　结论： 　　压缩列表是通过避免存储额外的指针和元数据，从而达到降低额外的开销。 　　配置： 1 #list2 list-max-ziplist-entries 51 2 #表示允许包含的最大元素数量 3 list-max-ziplist-value 64 #表示压缩节点允许存储的最大体积 4 #hash #当超过任一限制后，将不会使用ziplist方式进行存储 5 hash-max-ziplist-entries 512 6 hash-max-ziplist-value 64 7 #zset 8 zset-max-ziplist-entries 128 9 zset-max-ziplist-value 64 　　测试list: 　　1、建立test.php文件 1 #test.php 2 &amp;lt;?php 3 $redis=new Redis(); 4 $redis-&amp;gt;connect('192.168.95.11','6379'); 5 for ($i=0; $i&amp;lt;512 ; $i++) 6 { 7 $redis-&amp;gt;lpush('test-list',$i.'-test-list'); #往test-list推入512条数据 8 } 9 ?&amp;gt; 　　　　此时的test-list中含有512条数据，没有超除配置文件中的限制 　　2、往test-list中再推入一条数据 　　　　此时test-list含有513条数据，大于配置文件中限制的512条，索引将放弃ziplist存储方式，采用其原来的linkedlist存储方式,散列与有序集合同理。 　　　　2.2、intset整数集合（集合） 　　　　前提条件，集合中包含的所有member都可以被解析为十进制整数。 　　　　以有序数组的方式存储集合不仅可以降低内存消耗，还可以提升集合操作的执行速度。 　　　　配置： 1 set-max-intset-entries 512 #限制集合中member个数，超出则不采取i那个tset存储 　　　测试： 　　　　建立test.php文件 1 #test.php 2 &amp;lt;?php 3 $redis=new Redis(); 4 $redis-&amp;gt;connect('192.168.95.11','6379'); 5 for ($i=0; $i&amp;lt;512 ; $i++) 6 { 7 $redis-&amp;gt;sadd('test-set',$i); #给集合test-set插入512个member 8 } 9 ?&amp;gt; 10 　　　2.3、性能问题 　　　　不管列表、散列、有序集合、集合，当超出限制的条件后，就会转换为更为典型的底层结构类型。因为随着紧凑结构的体积不断变大，操作这些结构的速度将会变得越来越慢。 　　　　测试： 　　　　#将采用list进行代表性测试 　　　　测试思路： 　　　　　　1、在默认配置下往test-list推入50000条数据，查看所需时间；接着在使用rpoplpush将test-list数据全部推入到新列表list-new中，查看所需时间 　　　　　　2、修改配置，list-max-ziplist-entries 100000，再执行上面的同样操作 　　　　　　3、对比时间，得出结论 　　　　　　　　默认配置下测试： 　　　　　　　　1、插入数据，查看时间 1 #test1.php 2 &amp;lt;?php 3 header(&quot;content-type: text/html;charset=utf8;&quot;); 4 $redis=new Redis(); 5 $redis-&amp;gt;connect('192.168.95.11','6379'); 6 $start=time(); 7 for ($i=0; $i&amp;lt;50000 ; $i++) 8 { 9 $redis-&amp;gt;lpush('test-list',$i.'-aaaassssssddddddkkk'); 10 } 11 $end=time(); 12 echo &quot;插入耗时为：&quot;.($end-$start).'s'; 13 ?&amp;gt; 　　　　　　结果耗时4秒 　　　　　　　　2、执行相应命令，查看耗时 1 #test2.php 2 &amp;lt;?php 3 header(&quot;content-type: text/html;charset=utf8;&quot;); 4 $redis=new Redis(); 5 $redis-&amp;gt;connect('192.168.95.11','6379'); 6 $start=time(); 7 $num=0; 8 while($redis-&amp;gt;rpoplpush('test-list','test-new')) 9 { 10 $num+=1; 11 } 12 echo '执行次数为：'.$num.&quot;&amp;lt;br/&amp;gt;&quot;; 13 $end=time(); 14 echo &quot;耗时为：&quot;.($end-$start).'s'; 15 ?&amp;gt; 　　　　　　　　更改配置文件下测试　　 　　　　　　　　　　1、先修改配置文件 　　　　　　　　　　list-max-ziplist-entries 100000 #将这个值修改大一点，可以更好的凸显对性能的影响 　　　　　　　　　　list-max-ziplist-value 64 #此值可不做修改 　　　　　　　　　　2、插入数据 　　　　　　　　　　执行test1.php 　　　　　　　　　　结果为：耗时12s 　　　　　　　　　　3、执行相应命令，查看耗时 　　　　　　　　　　执行test2.php 　　　　　　　　　　结果为：执行次数：50000，耗时12s 　　　　　　结论： 　　　　　　在本机中执行测试50000条数据就相差8s，若在高并发下，长压缩列表和大整数集合将起不到任何的优化，反而使得性能降低。 3、片结构 　　分片的本质就是基于简单的规则将数据划分为更小的部分，然后根据数据所属的部分来决定将数据发送到哪个位置上。很多数据库使用这种技术来扩展存储空间，并提高自己所能处理的负载量。 　　结合前面讲到的，我们不难发现分片结构对于redis的重要意义。因此我们需要在配置文件中关于ziplist以及intset的相关配置做出适当的调整。 　　3.1、分片式散列 　　#ShardHash.class.php 　　散列分片主要是根据基础键以及散列包含的键计算出分片键ID，然后再与基础键拼接成一个完整的分片键。在执行hset与hget以及大部分hash命令时，都需要先将key（field）通过shardKey方法处理，得到分片键才能够进行下一步操作。 回到顶部 　　3.2、分片式集合 　　如何构造分片式集合才能够让它更节省内存，性能更加强大呢？主要的思路就是，将集合里面的存储的数据尽量在不改变其原有功能的情况下转换成可以被解析为十进制的数据。根据前面所讲到的，当集合中的所有成员都能够被解析为十进制数据时，将会采用intset存储方式，这不仅能够节省内存，而且还可以提高响应的性能。 4、将信息打包转换成存储字节 　　结合前面所讲的分片技术，采用string分片结构为大量连续的ID用户存储信息。 　　使用定长字符串，为每一个ID分配n个字节进行存储相应的信息。</summary></entry><entry><title type="html">redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？</title><link href="http://localhost:4000/mianshi/Redis/0705/03" rel="alternate" type="text/html" title="redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/Redis/0705/redis%20%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%3F%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%3F%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%85%B7%E4%BD%93%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84</id><content type="html" xml:base="http://localhost:4000/mianshi/Redis/0705/03">&lt;h4 id=&quot;redis-的持久化有哪几种方式&quot;&gt;redis 的持久化有哪几种方式？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。&lt;/li&gt;
  &lt;li&gt;AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。
通过 RDB 或 AOF，都可以将 redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。&lt;/p&gt;

&lt;p&gt;如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，&lt;strong&gt;因为 AOF 中的数据更加完整。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;不同的持久化机制都有什么优缺点&quot;&gt;不同的持久化机制都有什么优缺点？&lt;/h4&gt;

&lt;h5 id=&quot;rdb-优缺点&quot;&gt;RDB 优缺点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;aof-优缺点&quot;&gt;AOF 优缺点&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据。&lt;/li&gt;
  &lt;li&gt;AOF 日志文件以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。&lt;/li&gt;
  &lt;li&gt;AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。&lt;/li&gt;
  &lt;li&gt;AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。&lt;/li&gt;
  &lt;li&gt;对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。&lt;/li&gt;
  &lt;li&gt;AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）&lt;/li&gt;
  &lt;li&gt;以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;rdb-和-aof-到底该如何选择&quot;&gt;RDB 和 AOF 到底该如何选择&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;不要仅仅使用 RDB，因为那样会导致你丢失很多数据；&lt;/li&gt;
  &lt;li&gt;也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；&lt;/li&gt;
  &lt;li&gt;redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">redis 的持久化有哪几种方式？ RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。 AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。 通过 RDB 或 AOF，都可以将 redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。 如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。 如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。 不同的持久化机制都有什么优缺点？ RDB 优缺点 RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。 RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。 相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。 如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。 RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。 AOF 优缺点 AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据。 AOF 日志文件以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。 AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。 AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。 对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。 AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低） 以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。 RDB 和 AOF 到底该如何选择 不要仅仅使用 RDB，因为那样会导致你丢失很多数据； 也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug； redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</summary></entry><entry><title type="html">什么是IOC(控制反转)、DI(依赖注入)</title><link href="http://localhost:4000/mianshi/spring/0705/02" rel="alternate" type="text/html" title="什么是IOC(控制反转)、DI(依赖注入)" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/spring/0705/%E4%BB%80%E4%B9%88%E6%98%AFIOC(%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)%E3%80%81DI(%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)</id><content type="html" xml:base="http://localhost:4000/mianshi/spring/0705/02">&lt;p&gt;学习过Spring框架的人一定都会听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，总觉得IoC 、DI这两个概念是模糊不清的，是很难理解的，今天和大家分享网上的一些技术大牛们对Spring框架的IOC的理解以及谈谈我对Spring Ioc的理解。&lt;/p&gt;

&lt;h2 id=&quot;一分享iteye的开涛对ioc的精彩讲解&quot;&gt;一、分享Iteye的开涛对Ioc的精彩讲解&lt;/h2&gt;

&lt;p&gt;　　首先要分享的是Iteye的开涛这位技术牛人对Spring框架的IOC的理解，写得非常通俗易懂，以下内容全部来自原文，原文地址：http://jinnianshilongnian.iteye.com/blog/1413846&lt;/p&gt;

&lt;h3 id=&quot;11ioc是什么&quot;&gt;1.1、IoC是什么&lt;/h3&gt;

&lt;p&gt;　　&lt;strong&gt;Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。&lt;/strong&gt;在Java开发中，&lt;strong&gt;Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。&lt;/strong&gt;如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：&lt;/p&gt;

&lt;p&gt;　　●&lt;strong&gt;谁控制谁，控制什么：&lt;/strong&gt;传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；&lt;strong&gt;谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　●&lt;strong&gt;为何是反转，哪些方面反转了：&lt;/strong&gt;有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？&lt;strong&gt;因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvMjg5MjMzLzIwMTUwMS8yNjE0MjEzNzgzMTgyOTIuanBn.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图1-1 传统应用程序示意图&lt;/p&gt;

&lt;p&gt;　　当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/70.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图1-2有IoC/DI容器后程序结构示意图&lt;/p&gt;

&lt;h3 id=&quot;12ioc能做什么&quot;&gt;1.2、IoC能做什么&lt;/h3&gt;

&lt;p&gt;　　IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。&lt;/p&gt;

&lt;p&gt;　　其实&lt;strong&gt;IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;13ioc和di&quot;&gt;1.3、IoC和DI&lt;/h3&gt;

&lt;p&gt;　　&lt;strong&gt;DI—Dependency Injection，即“依赖注入”&lt;/strong&gt;：&lt;strong&gt;组件之间依赖关系&lt;/strong&gt;由容器在运行期决定，形象的说，即&lt;strong&gt;由容器动态的将某个依赖关系注入到组件之中&lt;/strong&gt;。&lt;strong&gt;依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。&lt;/strong&gt;通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。&lt;/p&gt;

&lt;p&gt;　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：&lt;/p&gt;

&lt;p&gt;　　●&lt;strong&gt;谁依赖于谁：&lt;/strong&gt;当然是&lt;strong&gt;应用程序依赖于IoC容器&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;　　●&lt;strong&gt;为什么需要依赖：&lt;/strong&gt;&lt;strong&gt;应用程序需要IoC容器来提供对象需要的外部资源&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;　　●&lt;strong&gt;谁注入谁：&lt;/strong&gt;很明显是&lt;strong&gt;IoC容器注入应用程序某个对象，应用程序依赖的对象&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;●注入了什么：&lt;/strong&gt;就是&lt;strong&gt;注入某个对象所需要的外部资源（包括对象、资源、常量数据）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;IoC和DI&lt;/strong&gt;由什么&lt;strong&gt;关系&lt;/strong&gt;呢？其实它们&lt;strong&gt;是同一个概念的不同角度描述&lt;/strong&gt;，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，&lt;strong&gt;“&lt;/strong&gt;&lt;strong&gt;依赖注入”&lt;/strong&gt;&lt;strong&gt;明确描述了“被注入对象依赖IoC&lt;/strong&gt;&lt;strong&gt;容器配置依赖对象”。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。&lt;/p&gt;

&lt;h2 id=&quot;二分享bromon的blog上对ioc与di浅显易懂的讲解&quot;&gt;二、分享Bromon的blog上对IoC与DI浅显易懂的讲解&lt;/h2&gt;

&lt;h3 id=&quot;21ioc控制反转&quot;&gt;2.1、IoC(控制反转)&lt;/h3&gt;

&lt;p&gt;　　首先想说说&lt;strong&gt;IoC（Inversion of Control，控制反转）&lt;/strong&gt;。这是&lt;strong&gt;spring的核心&lt;/strong&gt;，贯穿始终。&lt;strong&gt;所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。&lt;/strong&gt;这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。&lt;/p&gt;

&lt;p&gt;　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。&lt;strong&gt;Spring所倡导的开发方式&lt;/strong&gt;就是如此，&lt;strong&gt;所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;22di依赖注入&quot;&gt;2.2、DI(依赖注入)&lt;/h3&gt;

&lt;p&gt;　　&lt;strong&gt;IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的&lt;/strong&gt;。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。&lt;/p&gt;

&lt;p&gt;　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">学习过Spring框架的人一定都会听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，总觉得IoC 、DI这两个概念是模糊不清的，是很难理解的，今天和大家分享网上的一些技术大牛们对Spring框架的IOC的理解以及谈谈我对Spring Ioc的理解。 一、分享Iteye的开涛对Ioc的精彩讲解 　　首先要分享的是Iteye的开涛这位技术牛人对Spring框架的IOC的理解，写得非常通俗易懂，以下内容全部来自原文，原文地址：http://jinnianshilongnian.iteye.com/blog/1413846 1.1、IoC是什么 　　Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： 　　●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 　　●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 　　用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来： 图1-1 传统应用程序示意图 　　当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示: 图1-2有IoC/DI容器后程序结构示意图 1.2、IoC能做什么 　　IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 　　其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。 　　IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 1.3、IoC和DI 　　DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： 　　●谁依赖于谁：当然是应用程序依赖于IoC容器； 　　●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； 　　●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； 　　●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 　　IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 　　看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。 二、分享Bromon的blog上对IoC与DI浅显易懂的讲解 2.1、IoC(控制反转) 　　首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 2.2、DI(依赖注入) 　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。</summary></entry><entry><title type="html">单进程单线程的Redis如何能够高并发</title><link href="http://localhost:4000/mianshi/Redis/0705/02" rel="alternate" type="text/html" title="单进程单线程的Redis如何能够高并发" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/Redis/0705/%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84Redis%E5%A6%82%E4%BD%95%E8%83%BD%E5%A4%9F%E9%AB%98%E5%B9%B6%E5%8F%91</id><content type="html" xml:base="http://localhost:4000/mianshi/Redis/0705/02">&lt;h4 id=&quot;1基本原理&quot;&gt;1、基本原理&lt;/h4&gt;

&lt;p&gt;采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）&lt;/p&gt;

&lt;h5 id=&quot;1为什么不采用多进程或多线程处理&quot;&gt;（1）为什么不采用多进程或多线程处理？&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;多线程处理可能涉及到锁 
多线程处理会涉及到线程切换而消耗CPU
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2单线程处理的缺点&quot;&gt;（2）单线程处理的缺点？&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2redis不存在线程安全问题&quot;&gt;2、Redis不存在线程安全问题？&lt;/h4&gt;

&lt;p&gt;Redis采用了线程封闭的方式，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁&lt;/p&gt;

&lt;h4 id=&quot;3什么是多路io复用epoll&quot;&gt;3、什么是多路I/O复用（Epoll）&lt;/h4&gt;

&lt;p&gt;（1） 网络IO都是通过Socket实现，Server在某一个端口持续监听，客户端通过Socket（IP+Port）与服务器建立连接（ServerSocket.accept），成功建立连接之后，就可以使用Socket中封装的InputStream和OutputStream进行IO交互了。针对每个客户端，Server都会创建一个新线程专门用于处理 
（2） 默认情况下，网络IO是阻塞模式，即服务器线程在数据到来之前处于【阻塞】状态，等到数据到达，会自动唤醒服务器线程，着手进行处理。阻塞模式下，一个线程只能处理一个流的IO事件 
（3） 为了提升服务器线程处理效率，有以下三种思路&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;（1）非阻塞【忙轮询】：采用死循环方式轮询每一个流，如果有IO事件就处理，这样可以使得一个线程可以处理多个流，但是效率不高，容易导致CPU空转

（2）Select代理（无差别轮询）：可以观察多个流的IO事件，如果所有流都没有IO事件，则将线程进入阻塞状态，如果有一个或多个发生了IO事件，则唤醒线程去处理。但是还是得遍历所有的流，才能找出哪些流需要处理。如果流个数为N，则时间复杂度为O（N）

（3）Epoll代理：Select代理有一个缺点，线程在被唤醒后轮询所有的Stream，还是存在无效操作。 Epoll会哪个流发生了怎样的I/O事件通知处理线程，因此对这些流的操作都是有意义的，复杂度降低到了O(1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4其它开源软件采用的模型&quot;&gt;4、其它开源软件采用的模型&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Nginx：多进程单线程模型 
Memcached：单进程多线程模型
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;redis为什么是单线程的&quot;&gt;Redis为什么是单线程的？&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽&lt;/strong&gt;。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求，参见：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//redis.io/topics/benchmarks&quot;&gt;How fast is Redis?&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;如果万一cpu成为你的redis瓶颈了或者你就是不想让服务器其他核闲置那怎么办&quot;&gt;如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？&lt;/h5&gt;

&lt;p&gt;那也很简单，&lt;strong&gt;你多起几个Redis进程就好了&lt;/strong&gt;。Redis是keyvalue数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好。&lt;/p&gt;

&lt;h5 id=&quot;单线程可以处理高并发请求吗&quot;&gt;单线程可以处理高并发请求吗？&lt;/h5&gt;

&lt;p&gt;当然可以了，Redis都实现了。&lt;/p&gt;

&lt;p&gt;有一点概念需要澄清，并发并不是并行。&lt;/p&gt;

&lt;p&gt;（相关概念：并发性I/O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。并行性，意味着服务器能够同时执行几个事情，具有多个计算单元）&lt;/p&gt;

&lt;h5 id=&quot;redis总体快速的原因&quot;&gt;Redis总体快速的原因：&lt;/h5&gt;

&lt;p&gt;采用队列模式将并发访问变为串行访问（？）&lt;/p&gt;

&lt;p&gt;单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），其他模块仍用了多个线程。&lt;/p&gt;

&lt;h4 id=&quot;总体来说快速的原因如下&quot;&gt;总体来说快速的原因如下：&lt;/h4&gt;

&lt;p&gt;1）绝大部分请求是纯粹的内存操作（非常快速）&lt;/p&gt;

&lt;p&gt;2）采用单线程,避免了不必要的上下文切换和竞争条件&lt;/p&gt;

&lt;p&gt;3）非阻塞IO&lt;/p&gt;

&lt;p&gt;内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间&lt;/p&gt;

&lt;p&gt;这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Redis服务端是个单线程的架构，不同的Client虽然看似可以同时保持连接，但发出去的命令是序列化执行的，这在通常的数据库理论下是最高级别的隔离（serialize）&lt;/li&gt;
  &lt;li&gt;用MULTI/EXEC 来把多个命令组装成一次发送，达到原子性&lt;/li&gt;
  &lt;li&gt;用WATCH提供的乐观锁功能，在你EXEC的那一刻，如果被WATCH的键发生过改动，则MULTI到EXEC之间的指令全部不执行，不需要rollback&lt;/li&gt;
  &lt;li&gt;其他回答中提到的DISCARD指令只是用来撤销EXEC之前被暂存的指令，并不是回滚&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;多线程对同一个Key操作时，Redis服务是根据先到先作的原则，其他排队（可设置为直接丢弃），因为是单线程。&lt;/p&gt;

&lt;p&gt;修改默认的超时时间，默认2秒。但是大部份的操作都在30ms以内。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;使用redis有哪些好处&quot;&gt;使用&lt;a href=&quot;http://lib.csdn.net/base/redis&quot;&gt;Redis&lt;/a&gt;有哪些好处？&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)&lt;/p&gt;

&lt;p&gt;(2) 支持丰富数据类型，支持string，list，set，sorted set，hash&lt;/p&gt;

&lt;p&gt;(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行&lt;/p&gt;

&lt;p&gt;(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;redis相比memcached有哪些优势&quot;&gt;&lt;a href=&quot;http://lib.csdn.net/base/redis&quot;&gt;Redis&lt;/a&gt;相比memcached有哪些优势？&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(1) memcached所有的值均是简单的字符串，&lt;a href=&quot;http://lib.csdn.net/base/redis&quot;&gt;redis&lt;/a&gt;作为其替代者，支持更为丰富的数据类型&lt;/p&gt;

&lt;p&gt;(2) redis的速度比memcached快很多&lt;/p&gt;

&lt;p&gt;(3) redis可以持久化其数据&lt;/p&gt;

&lt;p&gt;(4)Redis支持数据的备份，即master-slave模式的数据备份。&lt;/p&gt;

&lt;p&gt;(5)、使用底层模型不同&lt;/p&gt;

&lt;p&gt;它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。&lt;/p&gt;

&lt;p&gt;Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。&lt;/p&gt;

&lt;p&gt;(6）value大小：redis最大可以达到1GB，而memcache只有1MB&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;redis常见性能问题和解决方案&quot;&gt;redis常见性能问题和解决方案：&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件&lt;/p&gt;

&lt;p&gt;(Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照;AOF文件过大会影响Master重启的恢复速度)&lt;/p&gt;

&lt;p&gt;(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次&lt;/p&gt;

&lt;p&gt;(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内&lt;/p&gt;

&lt;p&gt;(4) 尽量避免在压力很大的主库上增加从库&lt;/p&gt;

&lt;p&gt;(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &amp;lt;- Slave1 &amp;lt;- Slave2 &amp;lt;- Slave3…&lt;/p&gt;

&lt;p&gt;这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。&lt;/p&gt;

&lt;h4 id=&quot;redis的一些其他特点&quot;&gt;redis的一些其他特点：&lt;/h4&gt;

&lt;h5 id=&quot;1redis是单进程单线程的&quot;&gt;（1）Redis是单进程单线程的&lt;/h5&gt;

&lt;p&gt;redis利用队列技术将并发访问变为串行访问，消除了传统&lt;a href=&quot;http://lib.csdn.net/base/mysql&quot;&gt;数据库&lt;/a&gt;串行控制的开销&lt;/p&gt;

&lt;h5 id=&quot;2读写分离模型&quot;&gt;（2）读写分离模型&lt;/h5&gt;

&lt;p&gt;通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。
读写分离&lt;a href=&quot;http://lib.csdn.net/base/architecture&quot;&gt;架构&lt;/a&gt;的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离&lt;a href=&quot;http://lib.csdn.net/base/architecture&quot;&gt;架构&lt;/a&gt;并不适合。&lt;/p&gt;

&lt;h5 id=&quot;3数据分片模型&quot;&gt;（3）数据分片模型&lt;/h5&gt;

&lt;p&gt;为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。&lt;/p&gt;

&lt;p&gt;可以将每个节点看成都是独立的master，然后通过业务实现数据分片。&lt;/p&gt;

&lt;p&gt;结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。&lt;/p&gt;

&lt;h5 id=&quot;4redis的回收策略&quot;&gt;（4）Redis的回收策略&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;no-enviction（驱逐）：禁止驱逐数据&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。&lt;/p&gt;

    &lt;p&gt;　　使用策略规则：&lt;/p&gt;

    &lt;p&gt;　　1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru&lt;/p&gt;

    &lt;p&gt;　　2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">1、基本原理 采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗） （1）为什么不采用多进程或多线程处理？ 多线程处理可能涉及到锁 多线程处理会涉及到线程切换而消耗CPU （2）单线程处理的缺点？ 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善 2、Redis不存在线程安全问题？ Redis采用了线程封闭的方式，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁 3、什么是多路I/O复用（Epoll） （1） 网络IO都是通过Socket实现，Server在某一个端口持续监听，客户端通过Socket（IP+Port）与服务器建立连接（ServerSocket.accept），成功建立连接之后，就可以使用Socket中封装的InputStream和OutputStream进行IO交互了。针对每个客户端，Server都会创建一个新线程专门用于处理 （2） 默认情况下，网络IO是阻塞模式，即服务器线程在数据到来之前处于【阻塞】状态，等到数据到达，会自动唤醒服务器线程，着手进行处理。阻塞模式下，一个线程只能处理一个流的IO事件 （3） 为了提升服务器线程处理效率，有以下三种思路 （1）非阻塞【忙轮询】：采用死循环方式轮询每一个流，如果有IO事件就处理，这样可以使得一个线程可以处理多个流，但是效率不高，容易导致CPU空转 （2）Select代理（无差别轮询）：可以观察多个流的IO事件，如果所有流都没有IO事件，则将线程进入阻塞状态，如果有一个或多个发生了IO事件，则唤醒线程去处理。但是还是得遍历所有的流，才能找出哪些流需要处理。如果流个数为N，则时间复杂度为O（N） （3）Epoll代理：Select代理有一个缺点，线程在被唤醒后轮询所有的Stream，还是存在无效操作。 Epoll会哪个流发生了怎样的I/O事件通知处理线程，因此对这些流的操作都是有意义的，复杂度降低到了O(1) 4、其它开源软件采用的模型 Nginx：多进程单线程模型 Memcached：单进程多线程模型 Redis为什么是单线程的？ 因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求，参见：How fast is Redis? 如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？ 那也很简单，你多起几个Redis进程就好了。Redis是keyvalue数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好。 单线程可以处理高并发请求吗？ 当然可以了，Redis都实现了。 有一点概念需要澄清，并发并不是并行。 （相关概念：并发性I/O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。并行性，意味着服务器能够同时执行几个事情，具有多个计算单元） Redis总体快速的原因： 采用队列模式将并发访问变为串行访问（？） 单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），其他模块仍用了多个线程。 总体来说快速的原因如下： 1）绝大部分请求是纯粹的内存操作（非常快速） 2）采用单线程,避免了不必要的上下文切换和竞争条件 3）非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。 Redis服务端是个单线程的架构，不同的Client虽然看似可以同时保持连接，但发出去的命令是序列化执行的，这在通常的数据库理论下是最高级别的隔离（serialize） 用MULTI/EXEC 来把多个命令组装成一次发送，达到原子性 用WATCH提供的乐观锁功能，在你EXEC的那一刻，如果被WATCH的键发生过改动，则MULTI到EXEC之间的指令全部不执行，不需要rollback 其他回答中提到的DISCARD指令只是用来撤销EXEC之前被暂存的指令，并不是回滚 多线程对同一个Key操作时，Redis服务是根据先到先作的原则，其他排队（可设置为直接丢弃），因为是单线程。 修改默认的超时时间，默认2秒。但是大部份的操作都在30ms以内。 使用Redis有哪些好处？ (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) (2) 支持丰富数据类型，支持string，list，set，sorted set，hash (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 Redis相比memcached有哪些优势？ (1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 (2) redis的速度比memcached快很多 (3) redis可以持久化其数据 (4)Redis支持数据的备份，即master-slave模式的数据备份。 (5)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 (6）value大小：redis最大可以达到1GB，而memcache只有1MB redis常见性能问题和解决方案： (1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件 (Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照;AOF文件过大会影响Master重启的恢复速度) (2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次 (3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内 (4) 尽量避免在压力很大的主库上增加从库 (5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &amp;lt;- Slave1 &amp;lt;- Slave2 &amp;lt;- Slave3… 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。 redis的一些其他特点： （1）Redis是单进程单线程的 redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销 （2）读写分离模型 通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。 读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。 （3）数据分片模型 为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。 可以将每个节点看成都是独立的master，然后通过业务实现数据分片。 结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。 （4）Redis的回收策略 volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据 注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。 　　使用策略规则： 　　1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru 　　2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</summary></entry><entry><title type="html">BeanFactory和ApplicationContext的区别（Bean工厂和应用上下文）</title><link href="http://localhost:4000/mianshi/spring/0705/03" rel="alternate" type="text/html" title="BeanFactory和ApplicationContext的区别（Bean工厂和应用上下文）" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/spring/0705/BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB(Bean%E5%B7%A5%E5%8E%82%E5%92%8C%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87)</id><content type="html" xml:base="http://localhost:4000/mianshi/spring/0705/03">&lt;p&gt;&lt;strong&gt;BeanFactory和ApplicationContext 接口及其子类图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0705/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNzU3NDg5,size_16,color_FFFFFF,t_70.jpeg&quot; alt=&quot;applicationcontext和beanfactory&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;beanfactory&quot;&gt;BeanFactory&lt;/h2&gt;

&lt;p&gt;BeanFactory是spring的原始接口，针对原始结构的实现类功能比较单一，BeanFactory接口实现的容器，特点是在每次获取对象时才会创建对象。&lt;/p&gt;

&lt;h2 id=&quot;applicationcontext&quot;&gt;ApplicationContext&lt;/h2&gt;

&lt;p&gt;继承了BeanFactory接口，拥有BeanFactory的全部功能，并且扩展了很多高级特性，每次容器启动时就会创建所有的对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建ApplicationContext的方法：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;丛类路径下加载配置文件:ClassPathXmlApplicationContext (“applicationContext.xml”);&lt;/li&gt;
  &lt;li&gt;从硬盘绝对路径下加载配置文件: FileSystemXmlApplicationContext(“d:/xxx/yyy/xxx”);&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;结论&quot;&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/h2&gt;

  &lt;p&gt;早期的电脑性能低，内存小，所以spring容器的容量不足，不能讲所以的对象全部创建好放入容器，所以使用的是BeanFactory，需要某个对象时，再进行创建，随着电脑硬件的发展，内存越来越大，所以spring框架引入了ApplicationContext，将所有的对象都创建好，放入容器，使用哪个对象，从容器中取得即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以，web开发中,使用applicationContext. 在资源匮乏的环境可以使用BeanFactory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BeanFactory 和ApplicationContext&lt;/strong&gt; (详细说明)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Bean 工厂&lt;/strong&gt;（com.springframework.beans.factory.BeanFactory）是Spring 框架最核心的接口，它提供了高级IoC 的配置机制。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;应用上下文&lt;/strong&gt;（com.springframework.context.ApplicationContext）建立在BeanFactory 基础之上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;几乎所有的应用场合我们都直接使用ApplicationContext 而非底层的BeanFactory。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1 BeanFactory 的类体系结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BeanFactory:&lt;/strong&gt; 接口位于类结构树的顶端， 它最主要的方法就是getBean(StringbeanName)，该方法从容器中返回特定名称的Bean，BeanFactory 的功能通过其他的接口得到不断扩展。
&lt;strong&gt;ListableBeanFactory&lt;/strong&gt;：该接口定义了访问容器中Bean 基本信息的若干方法，如查看Bean 的个数、获取某一类型Bean 的配置名、查看容器中是否包括某一Bean 等方法；
&lt;strong&gt;HierarchicalBeanFactory：&lt;/strong&gt;父子级联IoC 容器的接口，子容器可以通过接口方法访问父容器；
&lt;strong&gt;ConfigurableBeanFactory&lt;/strong&gt;：是一个重要的接口，增强了IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始&lt;strong&gt;化后置处理器等方法；
AutowireCapableBeanFactory：&lt;/strong&gt;定义了将容器中的Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；
&lt;strong&gt;SingletonBeanRegistry：&lt;/strong&gt;定义了允许在运行期间向容器注册单实例Bean 的方法；
&lt;strong&gt;BeanDefinitionRegistry：&lt;/strong&gt;Spring 配置文件中每一个&lt;bean&gt;节点元素在Spring 容器里都通过一个BeanDefinition 对象表示，它描述了Bean 的配置信息。而BeanDefinitionRegistry 接口提供了向容器手工注册BeanDefinition 对象的方法。&lt;/bean&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2&lt;/strong&gt; &lt;strong&gt;ApplicationContext&lt;/strong&gt; &lt;strong&gt;的类体系结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ApplicationContext&lt;/strong&gt; 由BeanFactory 派生而来，提供了更多面向实际应用的功能。在BeanFactory 中，很多功能需要以编程的方式实现，而在ApplicationContext 中则可以通过配置的方式实现。
ApplicationContext 的主要实现类是ClassPathXmlApplicationContext 和FileSystemXmlApplicationContext，前者默认从类路径加载配置文件，后者默认从文件系统中装载配置文件。&lt;/p&gt;

&lt;p&gt;核心接口包括：
&lt;strong&gt;ApplicationEventPublisher：&lt;/strong&gt;让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了ApplicationListener 事件监听接口的Bean 可以接收到容器事件， 并对事件进行响应处理。在ApplicationContext 抽象实现类AbstractApplicationContext 中，我们可以发现存在一个ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听 者。
&lt;strong&gt;MessageSource：&lt;/strong&gt;为应用提供i18n 国际化消息访问的功能；
&lt;strong&gt;ResourcePatternResolver ：&lt;/strong&gt; 所有ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的Ant 风格的资源文件路径装载Spring 的配置文件。
&lt;strong&gt;LifeCycle：&lt;/strong&gt;该接口是Spring 2.0 加入的，该接口提供了start()和stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体Bean 实现，ApplicationContext 会将start/stop 的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度等目的。
&lt;strong&gt;ConfigurableApplicationContext&lt;/strong&gt; 扩展于ApplicationContext，它新增加了两个主要的方法：refresh()和close()，让ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码示例：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com/baobaotao/context/beans.xml&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FileSystemXmlApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com/baobaotao/context/beans.xml&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;conf/beans1.xml&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;conf/beans2.xml&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ApplicationContext 的初始化和BeanFactory 有一个重大的区别：BeanFactory在初始化容器时，并未实例化Bean，直到第一次访问某个Bean 时才实例目标Bean；而ApplicationContext 则在初始化应用上下文时就实例化所有单实例的Bean 。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">BeanFactory和ApplicationContext 接口及其子类图 BeanFactory BeanFactory是spring的原始接口，针对原始结构的实现类功能比较单一，BeanFactory接口实现的容器，特点是在每次获取对象时才会创建对象。 ApplicationContext 继承了BeanFactory接口，拥有BeanFactory的全部功能，并且扩展了很多高级特性，每次容器启动时就会创建所有的对象。 创建ApplicationContext的方法： 丛类路径下加载配置文件:ClassPathXmlApplicationContext (“applicationContext.xml”); 从硬盘绝对路径下加载配置文件: FileSystemXmlApplicationContext(“d:/xxx/yyy/xxx”); 结论 早期的电脑性能低，内存小，所以spring容器的容量不足，不能讲所以的对象全部创建好放入容器，所以使用的是BeanFactory，需要某个对象时，再进行创建，随着电脑硬件的发展，内存越来越大，所以spring框架引入了ApplicationContext，将所有的对象都创建好，放入容器，使用哪个对象，从容器中取得即可。 所以，web开发中,使用applicationContext. 在资源匮乏的环境可以使用BeanFactory. BeanFactory 和ApplicationContext (详细说明) Bean 工厂（com.springframework.beans.factory.BeanFactory）是Spring 框架最核心的接口，它提供了高级IoC 的配置机制。 应用上下文（com.springframework.context.ApplicationContext）建立在BeanFactory 基础之上。 几乎所有的应用场合我们都直接使用ApplicationContext 而非底层的BeanFactory。 1.1 BeanFactory 的类体系结构 BeanFactory: 接口位于类结构树的顶端， 它最主要的方法就是getBean(StringbeanName)，该方法从容器中返回特定名称的Bean，BeanFactory 的功能通过其他的接口得到不断扩展。 ListableBeanFactory：该接口定义了访问容器中Bean 基本信息的若干方法，如查看Bean 的个数、获取某一类型Bean 的配置名、查看容器中是否包括某一Bean 等方法； HierarchicalBeanFactory：父子级联IoC 容器的接口，子容器可以通过接口方法访问父容器； ConfigurableBeanFactory：是一个重要的接口，增强了IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法； AutowireCapableBeanFactory：定义了将容器中的Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法； SingletonBeanRegistry：定义了允许在运行期间向容器注册单实例Bean 的方法； BeanDefinitionRegistry：Spring 配置文件中每一个节点元素在Spring 容器里都通过一个BeanDefinition 对象表示，它描述了Bean 的配置信息。而BeanDefinitionRegistry 接口提供了向容器手工注册BeanDefinition 对象的方法。 1.2 ApplicationContext 的类体系结构 ApplicationContext 由BeanFactory 派生而来，提供了更多面向实际应用的功能。在BeanFactory 中，很多功能需要以编程的方式实现，而在ApplicationContext 中则可以通过配置的方式实现。 ApplicationContext 的主要实现类是ClassPathXmlApplicationContext 和FileSystemXmlApplicationContext，前者默认从类路径加载配置文件，后者默认从文件系统中装载配置文件。 核心接口包括： ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了ApplicationListener 事件监听接口的Bean 可以接收到容器事件， 并对事件进行响应处理。在ApplicationContext 抽象实现类AbstractApplicationContext 中，我们可以发现存在一个ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听 者。 MessageSource：为应用提供i18n 国际化消息访问的功能； ResourcePatternResolver ： 所有ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的Ant 风格的资源文件路径装载Spring 的配置文件。 LifeCycle：该接口是Spring 2.0 加入的，该接口提供了start()和stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体Bean 实现，ApplicationContext 会将start/stop 的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度等目的。 ConfigurableApplicationContext 扩展于ApplicationContext，它新增加了两个主要的方法：refresh()和close()，让ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利. 代码示例： ApplicationContext ctx =new ClassPathXmlApplicationContext(&quot;com/baobaotao/context/beans.xml&quot;); ApplicationContext ctx =new FileSystemXmlApplicationContext(&quot;com/baobaotao/context/beans.xml&quot;); ApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;conf/beans1.xml&quot;,&quot;conf/beans2.xml&quot;}); ApplicationContext 的初始化和BeanFactory 有一个重大的区别：BeanFactory在初始化容器时，并未实例化Bean，直到第一次访问某个Bean 时才实例目标Bean；而ApplicationContext 则在初始化应用上下文时就实例化所有单实例的Bean 。</summary></entry><entry><title type="html">Redis常见性能问题和解决办法</title><link href="http://localhost:4000/mianshi/Redis/0705/01" rel="alternate" type="text/html" title="Redis常见性能问题和解决办法" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/Redis/0705/Redis%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/mianshi/Redis/0705/01">&lt;p&gt;1.Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。&lt;/p&gt;

&lt;p&gt;2.Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。&lt;/p&gt;

&lt;p&gt;3.Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。&lt;/p&gt;

&lt;p&gt;下面是我的一个实际项目的情况，大概情况是这样的：一个Master，4个Slave，没有Sharding机制，仅是读写分离，Master负责写入操作和AOF日志备份，AOF文件大概5G，Slave负责读操作，当Master调用BGREWRITEAOF时，Master和Slave负载会突然陡增，Master的写入请求基本上都不响应了，持续了大概5分钟，Slave的读请求过半也无法及时响应，上面的情况本来不会也不应该发生的，是因为以前Master的这个机器是Slave，在上面有一个shell定时任务在每天的上午10点调用BGREWRITEAOF重写AOF文件，后来由于Master机器down了，就把备份的这个Slave切成Master了，但是这个定时任务忘记删除了，就导致了上面悲剧情况的发生，原因还是找了几天才找到的。&lt;/p&gt;

&lt;p&gt;将no-appendfsync-on-rewrite的配置设为yes可以缓解这个问题，设置为yes表示rewrite期间对新写操作不fsync，暂时存在内存中，等rewrite完成后再写入。最好是不开启Master的AOF备份功能。&lt;/p&gt;

&lt;p&gt;4.Redis主从复制的性能问题，第一次Slave向Master同步的实现是：Slave向Master发出同步请求，Master先dump出rdb文件，然后将rdb文件全量传输给slave，然后Master把缓存的命令转发给Slave，初次同步完成。第二次以及以后的同步实现是：Master将变量的快照直接实时依次发送给各个Slave。不管什么原因导致Slave和Master断开重连都会重复以上过程。Redis的主从复制是建立在内存快照的持久化基础上，只要有Slave就一定会有内存快照发生。虽然Redis宣称主从复制无阻塞，但由于磁盘io的限制，如果Master快照文件比较大，那么dump会耗费比较长的时间，这个过程中Master可能无法响应请求，也就是说服务会中断，对于关键服务，这个后果也是很可怕的。&lt;/p&gt;

&lt;p&gt;以上1.2.3.4根本问题的原因都离不开系统io瓶颈问题，也就是硬盘读写速度不够快，主进程 fsync()/write() 操作被阻塞。&lt;/p&gt;

&lt;p&gt;5.单点故障问题，由于目前Redis的主从复制还不够成熟，所以存在明显的单点故障问题，这个目前只能自己做方案解决，如：主动复制，Proxy实现Slave对Master的替换等，这个也是Redis作者目前比较优先的任务之一，作者的解决方案思路简单优雅，详情可见 Redis Sentinel design draft http://redis.io/topics/sentinel-spec。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;1.Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。&lt;/p&gt;

&lt;p&gt;2.如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。&lt;/p&gt;

&lt;p&gt;3.为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。&lt;/p&gt;

&lt;p&gt;4.尽量避免在压力较大的主库上增加从库&lt;/p&gt;

&lt;p&gt;5.为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&amp;lt;–Slave1&amp;lt;–Slave2&amp;lt;–Slave3…….，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">1.Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。 2.Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。 3.Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。 下面是我的一个实际项目的情况，大概情况是这样的：一个Master，4个Slave，没有Sharding机制，仅是读写分离，Master负责写入操作和AOF日志备份，AOF文件大概5G，Slave负责读操作，当Master调用BGREWRITEAOF时，Master和Slave负载会突然陡增，Master的写入请求基本上都不响应了，持续了大概5分钟，Slave的读请求过半也无法及时响应，上面的情况本来不会也不应该发生的，是因为以前Master的这个机器是Slave，在上面有一个shell定时任务在每天的上午10点调用BGREWRITEAOF重写AOF文件，后来由于Master机器down了，就把备份的这个Slave切成Master了，但是这个定时任务忘记删除了，就导致了上面悲剧情况的发生，原因还是找了几天才找到的。 将no-appendfsync-on-rewrite的配置设为yes可以缓解这个问题，设置为yes表示rewrite期间对新写操作不fsync，暂时存在内存中，等rewrite完成后再写入。最好是不开启Master的AOF备份功能。 4.Redis主从复制的性能问题，第一次Slave向Master同步的实现是：Slave向Master发出同步请求，Master先dump出rdb文件，然后将rdb文件全量传输给slave，然后Master把缓存的命令转发给Slave，初次同步完成。第二次以及以后的同步实现是：Master将变量的快照直接实时依次发送给各个Slave。不管什么原因导致Slave和Master断开重连都会重复以上过程。Redis的主从复制是建立在内存快照的持久化基础上，只要有Slave就一定会有内存快照发生。虽然Redis宣称主从复制无阻塞，但由于磁盘io的限制，如果Master快照文件比较大，那么dump会耗费比较长的时间，这个过程中Master可能无法响应请求，也就是说服务会中断，对于关键服务，这个后果也是很可怕的。 以上1.2.3.4根本问题的原因都离不开系统io瓶颈问题，也就是硬盘读写速度不够快，主进程 fsync()/write() 操作被阻塞。 5.单点故障问题，由于目前Redis的主从复制还不够成熟，所以存在明显的单点故障问题，这个目前只能自己做方案解决，如：主动复制，Proxy实现Slave对Master的替换等，这个也是Redis作者目前比较优先的任务之一，作者的解决方案思路简单优雅，详情可见 Redis Sentinel design draft http://redis.io/topics/sentinel-spec。 总结： 1.Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。 2.如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。 3.为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。 4.尽量避免在压力较大的主库上增加从库 5.为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&amp;lt;–Slave1&amp;lt;–Slave2&amp;lt;–Slave3…….，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</summary></entry><entry><title type="html">SpringBoot打成war包，部署到Tomcat服务器</title><link href="http://localhost:4000/mianshi/SpringBoot/0704-03" rel="alternate" type="text/html" title="SpringBoot打成war包，部署到Tomcat服务器" /><published>2020-07-04T00:00:00+08:00</published><updated>2020-07-04T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/SpringBoot/SpringBoot%E6%89%93%E6%88%90war%E5%8C%85,%E9%83%A8%E7%BD%B2%E5%88%B0Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/mianshi/SpringBoot/0704-03">&lt;p&gt;SpringBoot默认达成jar包，使用SpringBoot构想web应用，默认使用内置的Tomcat。但考虑到项目需要集群部署或者进行优化时，就需要打成war包部署到外部的Tomcat服务器中。&lt;/p&gt;

&lt;p&gt;==本文所使用SpringBoot版本为：2.0.3.RELEASE==&lt;/p&gt;

&lt;h4 id=&quot;一修改pomxml文件将默认的jar方式改为war&quot;&gt;一、修改pom.xml文件将默认的jar方式改为war：&lt;/h4&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.example&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;application&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!--默认为jar方式--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!--&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!--改为war方式--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;war&lt;span class=&quot;nt&quot;&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;二排除内置的tomcat容器两种方式都可&quot;&gt;二、排除内置的Tomcat容器（两种方式都可）：&lt;/h4&gt;

&lt;p&gt;1.排除spring-boot-starter-web中的Tomcat&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;exclusions&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;exclusion&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-tomcat&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/exclusion&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/exclusions&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.添加依赖&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-tomcat&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。
        相当于compile，但是打包阶段做了exclude操作--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;provided&lt;span class=&quot;nt&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;三继承orgspringframeworkbootwebservletsupportspringbootservletinitializer实现configure方法&quot;&gt;三、继承org.springframework.boot.web.servlet.support.SpringBootServletInitializer，实现configure方法：&lt;/h4&gt;

&lt;p&gt;为什么继承该类，SpringBootServletInitializer源码注释：&lt;/p&gt;

&lt;p&gt;Note that a WebApplicationInitializer is only needed if you are building a war file and deploying it.&lt;/p&gt;

&lt;p&gt;If you prefer to run an embedded web server then you won’t need this at all.&lt;/p&gt;

&lt;p&gt;注意，如果您正在构建WAR文件并部署它，则需要WebApplicationInitializer。&lt;/p&gt;

&lt;p&gt;如果你喜欢运行一个嵌入式Web服务器，那么你根本不需要这个。&lt;/p&gt;

&lt;p&gt;启动类代码：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;SpringApplication&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;1.方式一，启动类继承SpringBootServletInitializer实现configure：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SpringBootServletInitializer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;SpringApplication&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SpringApplicationBuilder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SpringApplicationBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.方式二，新增加一个类继承SpringBootServletInitializer实现configure：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServletInitializer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SpringBootServletInitializer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SpringApplicationBuilder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SpringApplicationBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//此处的Application.class为带有@SpringBootApplication注解的启动类&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意事项：&lt;/p&gt;

&lt;p&gt;使用外部Tomcat部署访问的时候，application.properties(或者application.yml)中配置的&lt;/p&gt;

&lt;p&gt;server.port=&lt;/p&gt;

&lt;p&gt;server.servlet.context-path=&lt;/p&gt;

&lt;p&gt;将失效，请使用tomcat的端口，tomcat，webapps下项目名进行访问。&lt;/p&gt;

&lt;p&gt;为了防止应用上下文所导致的项目访问资源加载不到的问题，&lt;/p&gt;

&lt;p&gt;建议pom.xml文件中&lt;build&gt;&lt;/build&gt;标签下添加&lt;finalName&gt;&lt;/finalName&gt;标签：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 应与application.properties(或application.yml)中context-path保持一致 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;finalName&amp;gt;&lt;/span&gt;war包名称&lt;span class=&quot;nt&quot;&gt;&amp;lt;/finalName&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用mvn命令行打包，运行：&lt;/p&gt;

&lt;p&gt;clean是清除之前的包，-Dmaven.test.skip=true是忽略测试代码&lt;/p&gt;

&lt;p&gt;jar 方式打包，使用内置Tomcat：mvn clean install -Dmaven.test.skip=true&lt;/p&gt;

&lt;p&gt;运行：java -jar 包名.jar&lt;/p&gt;

&lt;p&gt;war方式打包，使用外置Tomcat：mvn clean package -Dmaven.test.skip=true&lt;/p&gt;

&lt;p&gt;运行：${Tomcat_home}/bin/目录下执行startup.bat(windows)或者startup.sh(linux)&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">SpringBoot默认达成jar包，使用SpringBoot构想web应用，默认使用内置的Tomcat。但考虑到项目需要集群部署或者进行优化时，就需要打成war包部署到外部的Tomcat服务器中。 ==本文所使用SpringBoot版本为：2.0.3.RELEASE== 一、修改pom.xml文件将默认的jar方式改为war： &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;application&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;!--默认为jar方式--&amp;gt; &amp;lt;!--&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;--&amp;gt; &amp;lt;!--改为war方式--&amp;gt; &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; 二、排除内置的Tomcat容器（两种方式都可）： 1.排除spring-boot-starter-web中的Tomcat &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; 2.添加依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt; &amp;lt;!--打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。 相当于compile，但是打包阶段做了exclude操作--&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 三、继承org.springframework.boot.web.servlet.support.SpringBootServletInitializer，实现configure方法： 为什么继承该类，SpringBootServletInitializer源码注释： Note that a WebApplicationInitializer is only needed if you are building a war file and deploying it. If you prefer to run an embedded web server then you won’t need this at all. 注意，如果您正在构建WAR文件并部署它，则需要WebApplicationInitializer。 如果你喜欢运行一个嵌入式Web服务器，那么你根本不需要这个。 启动类代码： @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 1.方式一，启动类继承SpringBootServletInitializer实现configure： @SpringBootApplication public class Application extends SpringBootServletInitializer { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(Application.class); } } 2.方式二，新增加一个类继承SpringBootServletInitializer实现configure： public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { //此处的Application.class为带有@SpringBootApplication注解的启动类 return builder.sources(Application.class); } } 注意事项： 使用外部Tomcat部署访问的时候，application.properties(或者application.yml)中配置的 server.port= server.servlet.context-path= 将失效，请使用tomcat的端口，tomcat，webapps下项目名进行访问。 为了防止应用上下文所导致的项目访问资源加载不到的问题， 建议pom.xml文件中标签下添加标签： &amp;lt;build&amp;gt; &amp;lt;!-- 应与application.properties(或application.yml)中context-path保持一致 --&amp;gt; &amp;lt;finalName&amp;gt;war包名称&amp;lt;/finalName&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 使用mvn命令行打包，运行： clean是清除之前的包，-Dmaven.test.skip=true是忽略测试代码 jar 方式打包，使用内置Tomcat：mvn clean install -Dmaven.test.skip=true 运行：java -jar 包名.jar war方式打包，使用外置Tomcat：mvn clean package -Dmaven.test.skip=true 运行：${Tomcat_home}/bin/目录下执行startup.bat(windows)或者startup.sh(linux)</summary></entry><entry><title type="html">同步类容器和并发类容器</title><link href="http://localhost:4000/mianshi/concurrent/0704" rel="alternate" type="text/html" title="同步类容器和并发类容器" /><published>2020-07-04T00:00:00+08:00</published><updated>2020-07-04T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/concurrent/%E5%90%8C%E6%AD%A5%E7%B1%BB%E5%AE%B9%E5%99%A8%E5%92%8C%E5%B9%B6%E5%8F%91%E7%B1%BB%E5%AE%B9%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/mianshi/concurrent/0704">&lt;h3 id=&quot;一集合容器框架&quot;&gt;一、集合容器框架&lt;/h3&gt;

&lt;p&gt;在Java的集合容器框架中，主要有四大类别：List、Set、Queue、Map。&lt;/p&gt;

&lt;p&gt;注意Collection和Map是顶层接口，而List、Set、Queue接口则分别继承了Collection接口，分别代表数组、集合和队列这三大类容器。&lt;/p&gt;

&lt;p&gt;像ArrayList、LinkedList都是实现了List接口，HashSet实现了Set接口，而Deque（双向队列，允许在队首、队尾进行入队和出队操作）继承了Queue接口，PriorityQueue实现了Queue接口。另外LinkedList（实际上是双向链表）同时也实现了Deque接口。&lt;/p&gt;

&lt;p&gt;但以上容器都是非线程安全的。如果有多个线程并发地访问这些容器时，就会出现问题。因此，在编写程序时，必须要求程序员手动地在访问到这些容器的地方进行同步处理，这样导致在使用这些容器的时候非常地不方便。所以，Java提供了同步容器供用户使用。&lt;/p&gt;

&lt;h3 id=&quot;二java中的同步类容器&quot;&gt;二、Java中的同步类容器&lt;/h3&gt;

&lt;p&gt;在Java中，同步容器主要包括2类：&lt;/p&gt;

&lt;p&gt;　　1）Vector、Stack、HashTable&lt;/p&gt;

&lt;p&gt;　　2）Collections类中提供的静态工厂方法创建的类&lt;/p&gt;

&lt;p&gt;Vector实现了List接口，Vector实际上就是一个数组，和ArrayList类似，但是Vector中的方法都是synchronized方法，即进行了同步措施；Stack也是一个同步容器，它的方法也用synchronized进行了同步，它实际上是继承于Vector类；HashTable实现了Map接口，它和HashMap很相似，但是HashTable进行了同步处理，而HashMap没有。&lt;/p&gt;

&lt;p&gt;Collections类是一个工具提供类，注意，它和Collection不同，Collection是一个顶层的接口。在Collections类中提供了大量的方法，比如对集合或者容器进行排序、查找等操作。最重要的是，在它里面提供了几个静态工厂方法来创建同步容器类，如下图所示：&lt;/p&gt;

&lt;p&gt;这些同步容器都是通过synchronized进行同步来实现线程安全的，那么很显然，这必然会影响到执行性能。&lt;/p&gt;

&lt;p&gt;而且虽然他们都是线程安全的，但这并不说明在任何情况下都可以线程安全，看你怎么用了，例如下面的这个例子：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;activeCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行结果是在执行过程中会出现数组下标越界的运行时异常。也许有朋友会问：Vector是线程安全的，为什么还会报这个错？很简单，对于Vector，虽然能保证每一个时刻只能有一个线程访问它，但是不排除这种可能，当某个线程在某个时刻执行这句时：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; for(int i=0;i&amp;lt;vector.size();i++)
 vector.get(i);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;假若此时vector的size方法返回的是10，i的值为9，在他要获取下标为9的元素时，有另外一个线程先执行了这句：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; for(int i=0;i&amp;lt;vector.size();i++)
 	vector.remove(i);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将下标为9的元素删除了，在删除过程中因为有锁，所以之前的那个线程无法执行vector.get(i);处于阻塞状态，等这个线程把下标为9的元素删除了之后获取到锁再执行。那么通过get方法访问下标为9的元素肯定就会出问题了。说明这是程序逻辑本身存在线程安全问题，因此为了保证线程安全，必须在方法调用端做额外的同步措施，如下面所示：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//进行额外的同步&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;activeCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;三java中的并发类容器&quot;&gt;三、Java中的并发类容器&lt;/h3&gt;

&lt;p&gt;为了解决同步类容器的性能问题，在Java 1.5之后提供了并发容器，位于java.util.concurrent目录下，这个目录俗称并发包。&lt;/p&gt;

&lt;h4 id=&quot;31concurrentmap&quot;&gt;3.1、ConcurrentMap&lt;/h4&gt;

&lt;p&gt;ConcurrentMap接口下有两个重要的实现：ConcurrentHashMap、ConcurrentSkipListMap。ConcurrentHashMap把整个哈希表分成多个segment，每个segment一把锁，主要通过锁分段技术减小了锁的粒度，降低了冲突，从而提高了并发性。在实际的应用中，散列表一般是读多写少。ConcurrentHashMap 就针对读操作做了大量的优化，运用了很多并发技巧，如不可变对象和使用volatile保证内存可见性，这样，在大多数情况下读操作甚至无需加锁也能获得正确的值。ConcurrentHashMap的concurrencyLevel（默认值为16）表示并发级别，这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。该值设置过高会照成空间的浪费，设置过低会降低并发性。这种对调优的把握是要通过对底层实现的深刻理解和不断的实践积累才能获取的。&lt;/p&gt;

&lt;h4 id=&quot;32copyonwirte容器&quot;&gt;3.2、CopyOnWirte容器&lt;/h4&gt;

&lt;p&gt;Cope-On-Write简称COW，是一种用于程序设计中的优化策略，称为写时复制，理解起来很简单，就是执行修改操作时进行底层数组复制，使得修改操作在新的数组上进行，不妨碍原数组的并发读操作，复制修改完成后把原数组引用指向新数组。这样做的好处是可以并发的读而不需要加锁，因为当前容器不会添加任何元素，所以也是一种读写分离的思想。但正是因为写时复制，所以不能保证数据的实时性，而只能保证最终一致性。&lt;/p&gt;

&lt;p&gt;在concurrent包下实现CopyOnWrite机制的容器有两种，CopyOnWriteArrayList和CopyOnWriteArraySet。&lt;/p&gt;

&lt;p&gt;CopyOnWriteArrayList中有一个Object数组array用来存放数据，对于set()、add()、remove()等修改数据的操作会加上重入锁ReentrantLock，等修改操作完成替换掉array的引用之后才释放锁，从而保证写操作的线程安全，而针对读操作没有任何锁。&lt;/p&gt;

&lt;p&gt;CopyOnWriteArraySet其实就是一个CopyOnWriteArrayList，不过就是在方法中避免重复数据而已，甚至这些避免重复数据的函数也是在CopyOnWriteArrayList中定义的，CopyOnWriteArraySet中只是包含一个CopyOnWriteArrayList的属性，然后在方法上做个包装，除了equals方法外，其他当前类中的所有函数都是调用的CopyOnWriteArrayList的方法，所以严格来讲可以使用一个CopyOnWriteArrayList作为具有Set特性的写时复制数组（不过就是没有继承AbstractSet）。&lt;/p&gt;

&lt;p&gt;根据CopyOnWirte容器的实现原理可知，CopyOnWirte容器保证读写分离，十分适合读多写少的场景，但不适合写多的场景。&lt;/p&gt;

&lt;h4 id=&quot;33线程安全队列&quot;&gt;3.3、线程安全队列&lt;/h4&gt;

&lt;p&gt;在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现。java.util.concurrent.atomic包相关类就是CAS的实现。&lt;/p&gt;

&lt;p&gt;ConcurrentLinkedQueue是一个适用于高并发场景下的非阻塞的队列，通过无锁的方式(采用CAS操作)，实现了高并发状态下的高性能，通常ConcurrentLinkedQueue的性能优于BlockingQueue。ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素，该队列不允许NULL元素。&lt;/p&gt;

&lt;p&gt;阻塞队列当队列是空的时候，再想获取元素就会阻塞进入等待状态，所以非常适合生产者-消费者模式。阻塞队列BlockingQueue接口JDK提供了7种实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。&lt;/li&gt;
  &lt;li&gt;LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。&lt;/li&gt;
  &lt;li&gt;PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。&lt;/li&gt;
  &lt;li&gt;DelayQueue：一个使用优先级队列实现的无界阻塞队列。&lt;/li&gt;
  &lt;li&gt;SynchronousQueue：一个不存储元素的阻塞队列。&lt;/li&gt;
  &lt;li&gt;LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。&lt;/li&gt;
  &lt;li&gt;LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">一、集合容器框架 在Java的集合容器框架中，主要有四大类别：List、Set、Queue、Map。 注意Collection和Map是顶层接口，而List、Set、Queue接口则分别继承了Collection接口，分别代表数组、集合和队列这三大类容器。 像ArrayList、LinkedList都是实现了List接口，HashSet实现了Set接口，而Deque（双向队列，允许在队首、队尾进行入队和出队操作）继承了Queue接口，PriorityQueue实现了Queue接口。另外LinkedList（实际上是双向链表）同时也实现了Deque接口。 但以上容器都是非线程安全的。如果有多个线程并发地访问这些容器时，就会出现问题。因此，在编写程序时，必须要求程序员手动地在访问到这些容器的地方进行同步处理，这样导致在使用这些容器的时候非常地不方便。所以，Java提供了同步容器供用户使用。 二、Java中的同步类容器 在Java中，同步容器主要包括2类： 　　1）Vector、Stack、HashTable 　　2）Collections类中提供的静态工厂方法创建的类 Vector实现了List接口，Vector实际上就是一个数组，和ArrayList类似，但是Vector中的方法都是synchronized方法，即进行了同步措施；Stack也是一个同步容器，它的方法也用synchronized进行了同步，它实际上是继承于Vector类；HashTable实现了Map接口，它和HashMap很相似，但是HashTable进行了同步处理，而HashMap没有。 Collections类是一个工具提供类，注意，它和Collection不同，Collection是一个顶层的接口。在Collections类中提供了大量的方法，比如对集合或者容器进行排序、查找等操作。最重要的是，在它里面提供了几个静态工厂方法来创建同步容器类，如下图所示： 这些同步容器都是通过synchronized进行同步来实现线程安全的，那么很显然，这必然会影响到执行性能。 而且虽然他们都是线程安全的，但这并不说明在任何情况下都可以线程安全，看你怎么用了，例如下面的这个例子： public class Test { static Vector&amp;lt;Integer&amp;gt; vector = new Vector&amp;lt;Integer&amp;gt;(); public static void main(String[] args) throws InterruptedException { while(true) { for(int i=0;i&amp;lt;10;i++) vector.add(i); Thread thread1 = new Thread(){ public void run() { for(int i=0;i&amp;lt;vector.size();i++) vector.remove(i); }; }; Thread thread2 = new Thread(){ public void run() { for(int i=0;i&amp;lt;vector.size();i++) vector.get(i); }; }; thread1.start(); thread2.start(); while(Thread.activeCount()&amp;gt;10) { } } } } 运行结果是在执行过程中会出现数组下标越界的运行时异常。也许有朋友会问：Vector是线程安全的，为什么还会报这个错？很简单，对于Vector，虽然能保证每一个时刻只能有一个线程访问它，但是不排除这种可能，当某个线程在某个时刻执行这句时： for(int i=0;i&amp;lt;vector.size();i++) vector.get(i); 假若此时vector的size方法返回的是10，i的值为9，在他要获取下标为9的元素时，有另外一个线程先执行了这句： for(int i=0;i&amp;lt;vector.size();i++) vector.remove(i); 将下标为9的元素删除了，在删除过程中因为有锁，所以之前的那个线程无法执行vector.get(i);处于阻塞状态，等这个线程把下标为9的元素删除了之后获取到锁再执行。那么通过get方法访问下标为9的元素肯定就会出问题了。说明这是程序逻辑本身存在线程安全问题，因此为了保证线程安全，必须在方法调用端做额外的同步措施，如下面所示： public class Test { static Vector&amp;lt;Integer&amp;gt; vector = new Vector&amp;lt;Integer&amp;gt;(); public static void main(String[] args) throws InterruptedException { while(true) { for(int i=0;i&amp;lt;10;i++) vector.add(i); Thread thread1 = new Thread(){ public void run() { synchronized (Test.class) { //进行额外的同步 for(int i=0;i&amp;lt;vector.size();i++) vector.remove(i); } }; }; Thread thread2 = new Thread(){ public void run() { synchronized (Test.class) { for(int i=0;i&amp;lt;vector.size();i++) vector.get(i); } }; }; thread1.start(); thread2.start(); while(Thread.activeCount()&amp;gt;10) { } } } } 三、Java中的并发类容器 为了解决同步类容器的性能问题，在Java 1.5之后提供了并发容器，位于java.util.concurrent目录下，这个目录俗称并发包。 3.1、ConcurrentMap ConcurrentMap接口下有两个重要的实现：ConcurrentHashMap、ConcurrentSkipListMap。ConcurrentHashMap把整个哈希表分成多个segment，每个segment一把锁，主要通过锁分段技术减小了锁的粒度，降低了冲突，从而提高了并发性。在实际的应用中，散列表一般是读多写少。ConcurrentHashMap 就针对读操作做了大量的优化，运用了很多并发技巧，如不可变对象和使用volatile保证内存可见性，这样，在大多数情况下读操作甚至无需加锁也能获得正确的值。ConcurrentHashMap的concurrencyLevel（默认值为16）表示并发级别，这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。该值设置过高会照成空间的浪费，设置过低会降低并发性。这种对调优的把握是要通过对底层实现的深刻理解和不断的实践积累才能获取的。 3.2、CopyOnWirte容器 Cope-On-Write简称COW，是一种用于程序设计中的优化策略，称为写时复制，理解起来很简单，就是执行修改操作时进行底层数组复制，使得修改操作在新的数组上进行，不妨碍原数组的并发读操作，复制修改完成后把原数组引用指向新数组。这样做的好处是可以并发的读而不需要加锁，因为当前容器不会添加任何元素，所以也是一种读写分离的思想。但正是因为写时复制，所以不能保证数据的实时性，而只能保证最终一致性。 在concurrent包下实现CopyOnWrite机制的容器有两种，CopyOnWriteArrayList和CopyOnWriteArraySet。 CopyOnWriteArrayList中有一个Object数组array用来存放数据，对于set()、add()、remove()等修改数据的操作会加上重入锁ReentrantLock，等修改操作完成替换掉array的引用之后才释放锁，从而保证写操作的线程安全，而针对读操作没有任何锁。 CopyOnWriteArraySet其实就是一个CopyOnWriteArrayList，不过就是在方法中避免重复数据而已，甚至这些避免重复数据的函数也是在CopyOnWriteArrayList中定义的，CopyOnWriteArraySet中只是包含一个CopyOnWriteArrayList的属性，然后在方法上做个包装，除了equals方法外，其他当前类中的所有函数都是调用的CopyOnWriteArrayList的方法，所以严格来讲可以使用一个CopyOnWriteArrayList作为具有Set特性的写时复制数组（不过就是没有继承AbstractSet）。 根据CopyOnWirte容器的实现原理可知，CopyOnWirte容器保证读写分离，十分适合读多写少的场景，但不适合写多的场景。 3.3、线程安全队列 在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现。java.util.concurrent.atomic包相关类就是CAS的实现。 ConcurrentLinkedQueue是一个适用于高并发场景下的非阻塞的队列，通过无锁的方式(采用CAS操作)，实现了高并发状态下的高性能，通常ConcurrentLinkedQueue的性能优于BlockingQueue。ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素，该队列不允许NULL元素。 阻塞队列当队列是空的时候，再想获取元素就会阻塞进入等待状态，所以非常适合生产者-消费者模式。阻塞队列BlockingQueue接口JDK提供了7种实现： ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue：一个不存储元素的阻塞队列。 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</summary></entry><entry><title type="html">只读事务（@Transactional(readOnly = true)）的一些概念</title><link href="http://localhost:4000/mianshi/Transactional/0704/05" rel="alternate" type="text/html" title="只读事务（@Transactional(readOnly = true)）的一些概念" /><published>2020-07-04T00:00:00+08:00</published><updated>2020-07-04T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/Transactional/0704/%E5%8F%AA%E8%AF%BB%E4%BA%8B%E5%8A%A1(@Transactional(readOnly%20=%20true))%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5</id><content type="html" xml:base="http://localhost:4000/mianshi/Transactional/0704/05">&lt;p&gt;念：从这一点设置的时间点开始（时间点a）到这个事务结束的过程中，其他事务所提交的数据，该事务将看不见！（查询中不会出现别人在时间点a之后提交的数据）&lt;/p&gt;

&lt;p&gt;应用场合：&lt;/p&gt;

&lt;p&gt;如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持SQL执行期间的读一致性；
如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询SQL必须保证整体的读一致性，否则，在前条SQL查询之后，后条SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。
【注意是一次执行多次查询来统计某些信息，这时为了保证数据整体的一致性，要用只读事务】&lt;/p&gt;

&lt;p&gt;怎样设置：&lt;/p&gt;

&lt;p&gt;对于只读查询，可以指定事务类型为readonly，即只读事务。
由于只读事务不存在数据的修改，因此数据库将会为只读事务提供一些优化手段，例如Oracle对于只读事务，不启动回滚段，不记录回滚log。&lt;/p&gt;

&lt;p&gt;（1）在JDBC中，指定只读事务的办法为： connection.setReadOnly(true);&lt;/p&gt;

&lt;p&gt;（2）在Hibernate中，指定只读事务的办法为： session.setFlushMode(FlushMode.NEVER);
此时，Hibernate也会为只读事务提供Session方面的一些优化手段&lt;/p&gt;

&lt;p&gt;（3）在Spring的Hibernate封装中，指定只读事务的办法为： bean配置文件中，prop属性增加“readOnly”
或者用注解方式@Transactional(readOnly=true)
【 if the transaction is marked as read-only, Spring will set the Hibernate Session’s flush mode to FLUSH_NEVER,
and will set the JDBC transaction to read-only】也就是说在Spring中设置只读事务是利用上面两种方式&lt;/p&gt;

&lt;p&gt;在将事务设置成只读后，相当于将数据库设置成只读数据库，此时若要进行写的操作，会出现错误&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">念：从这一点设置的时间点开始（时间点a）到这个事务结束的过程中，其他事务所提交的数据，该事务将看不见！（查询中不会出现别人在时间点a之后提交的数据） 应用场合： 如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持SQL执行期间的读一致性； 如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询SQL必须保证整体的读一致性，否则，在前条SQL查询之后，后条SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。 【注意是一次执行多次查询来统计某些信息，这时为了保证数据整体的一致性，要用只读事务】 怎样设置： 对于只读查询，可以指定事务类型为readonly，即只读事务。 由于只读事务不存在数据的修改，因此数据库将会为只读事务提供一些优化手段，例如Oracle对于只读事务，不启动回滚段，不记录回滚log。 （1）在JDBC中，指定只读事务的办法为： connection.setReadOnly(true); （2）在Hibernate中，指定只读事务的办法为： session.setFlushMode(FlushMode.NEVER); 此时，Hibernate也会为只读事务提供Session方面的一些优化手段 （3）在Spring的Hibernate封装中，指定只读事务的办法为： bean配置文件中，prop属性增加“readOnly” 或者用注解方式@Transactional(readOnly=true) 【 if the transaction is marked as read-only, Spring will set the Hibernate Session’s flush mode to FLUSH_NEVER, and will set the JDBC transaction to read-only】也就是说在Spring中设置只读事务是利用上面两种方式 在将事务设置成只读后，相当于将数据库设置成只读数据库，此时若要进行写的操作，会出现错误</summary></entry><entry><title type="html">什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</title><link href="http://localhost:4000/mianshi/queue/0704" rel="alternate" type="text/html" title="什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？" /><published>2020-07-04T00:00:00+08:00</published><updated>2020-07-04T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/queue/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%3F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B</id><content type="html" xml:base="http://localhost:4000/mianshi/queue/0704">&lt;h2 id=&quot;什么是阻塞队列&quot;&gt;什么是阻塞队列？&lt;/h2&gt;

&lt;p&gt;阻塞队列是一个在队列基础上又支持了两个附加操作的队列。&lt;/p&gt;

&lt;p&gt;2个附加操作：&lt;/p&gt;

&lt;p&gt;支持阻塞的&lt;strong&gt;插入&lt;/strong&gt;方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。&lt;/p&gt;

&lt;p&gt;支持阻塞的&lt;strong&gt;移除&lt;/strong&gt;方法：队列空时，获取元素的线程会等待队列变为非空。&lt;/p&gt;

&lt;h2 id=&quot;阻塞队列的应用场景&quot;&gt;阻塞队列的应用场景&lt;/h2&gt;

&lt;p&gt;阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。简而言之，阻塞队列是生产者用来存放元素、消费者获取元素的容器。&lt;/p&gt;

&lt;h2 id=&quot;几个方法&quot;&gt;几个方法&lt;/h2&gt;

&lt;p&gt;在阻塞队列不可用的时候，上述2个附加操作提供了四种处理方法&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;方法处理方式&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;抛出异常&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;返回特殊值&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;一直阻塞&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;超时退出&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;插入方法&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;add(e)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;offer(e)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;put(e)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;offer(e,time,unit)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;移除方法&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;remove()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;poll()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;take()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;poll(time,unit)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;检查方法&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;element()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;peek()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不可用&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不可用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;java里的阻塞队列&quot;&gt;JAVA里的阻塞队列&lt;/h2&gt;

&lt;p&gt;JDK 7 提供了7个阻塞队列，如下&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt; 数组结构组成的有界阻塞队列。&lt;/p&gt;

&lt;p&gt;此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。&lt;/p&gt;

&lt;p&gt;2、&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;一个由链表结构组成的有界阻塞队列&lt;/p&gt;

&lt;p&gt;此队列按照先出先进的原则对元素进行排序&lt;/p&gt;

&lt;p&gt;3、&lt;strong&gt;PriorityBlockingQueue&lt;/strong&gt; 支持优先级的无界阻塞队列&lt;/p&gt;

&lt;p&gt;4、&lt;strong&gt;DelayQueue&lt;/strong&gt; 支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素&lt;/p&gt;

&lt;p&gt;5、&lt;strong&gt;SynchronousQueue&lt;/strong&gt;不存储元素的阻塞队列，每一个put必须等待一个take操作，否则不能继续添加元素。并且他支持公平访问队列。&lt;/p&gt;

&lt;p&gt;6、&lt;strong&gt;LinkedTransferQueue&lt;/strong&gt;由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了tryTransfer和transfer方法&lt;/p&gt;

&lt;p&gt;transfer方法&lt;/p&gt;

&lt;p&gt;如果当前有消费者正在等待接收元素（take或者待时间限制的poll方法），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。&lt;/p&gt;

&lt;p&gt;tryTransfer方法&lt;/p&gt;

&lt;p&gt;用来试探生产者传入的元素能否直接传给消费者。，如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。&lt;/p&gt;

&lt;p&gt;7、LinkedBlockingDeque链表结构的双向阻塞队列，优势在于多线程入队时，减少一半的竞争。&lt;/p&gt;

&lt;h2 id=&quot;如何使用阻塞队列来实现生产者-消费者模型&quot;&gt;如何使用阻塞队列来实现生产者-消费者模型？&lt;/h2&gt;

&lt;p&gt;通知模式实现：所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。&lt;/p&gt;

&lt;h2 id=&quot;使用blockingqueue解决生产者消费者问题&quot;&gt;使用BlockingQueue解决生产者消费者问题&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;为什么BlockingQueue适合解决生产者消费者问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;任何有效的生产者-消费者问题解决方案都是通过控制生产者put()方法（生产资源）和消费者take()方法（消费资源）的调用来实现的，一旦你实现了对方法的阻塞控制，那么你将解决该问题。&lt;/p&gt;

&lt;p&gt;Java通过BlockingQueue提供了开箱即用的支持来控制这些方法的调用（一个线程创建资源，另一个消费资源）。java.util.concurrent包下的BlockingQueue接口是一个线程安全的可用于存取对象的队列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BlockingQueue是一种数据结构，支持一个线程往里存资源，另一个线程从里取资源。这正是解决生产者消费者问题所需要的，那么让我们开始解决该问题吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生产者&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下代码用于生产者线程&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;io.ymq.example.thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;cm&quot;&gt;/**
 * 描述:生产者
 *
 * @author yanpenglei
 * @create 2018-03-14 15:52
 **/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Producer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;nc&quot;&gt;Producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;theQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;theQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;justProduced&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getResource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;justProduced&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;生产者资源队列大小= &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;生产者 中断&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getResource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;生产者 读 中断&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;消费者&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下代码用于消费者线程&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;io.ymq.example.thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;cm&quot;&gt;/**
 * 描述: 消费者
 *
 * @author yanpenglei
 * @create 2018-03-14 15:54
 **/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;theQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;theQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;消费者 资源 队列大小 &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;消费者 中断&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// simulate time passing&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;消费者 读 中断&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;消费对象 &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试该解决方案是否运行正常&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;io.ymq.example.thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;cm&quot;&gt;/**
 * 描述: 测试
 *
 * @author yanpenglei
 * @create 2018-03-14 15:58
 **/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ProducerConsumerExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numProducers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numConsumers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 
        &lt;span class=&quot;nc&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myQueue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numProducers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numConsumers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;生产者资源队列大小= 1
生产者资源队列大小= 1
消费者 资源 队列大小 1
生产者资源队列大小= 1
消费者 资源 队列大小 1
消费者 资源 队列大小 1
生产者资源队列大小= 1
生产者资源队列大小= 3
消费对象 java.lang.Object@1e1aa52b
生产者资源队列大小= 2
生产者资源队列大小= 5
消费对象 java.lang.Object@6e740a76
消费对象 java.lang.Object@697853f6
 
......
 
消费对象 java.lang.Object@41a10cbc
消费对象 java.lang.Object@4963c8d1
消费者 资源 队列大小 5
生产者资源队列大小= 5
生产者资源队列大小= 5
消费者 资源 队列大小 4
消费对象 java.lang.Object@3e49c35d
消费者 资源 队列大小 4
生产者资源队列大小= 5


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;从输出结果中,我们可以发现队列大小永远不会超过5，消费者线程消费了生产者生产的资源&lt;/strong&gt;&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">什么是阻塞队列？ 阻塞队列是一个在队列基础上又支持了两个附加操作的队列。 2个附加操作： 支持阻塞的插入方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。 支持阻塞的移除方法：队列空时，获取元素的线程会等待队列变为非空。 阻塞队列的应用场景 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。简而言之，阻塞队列是生产者用来存放元素、消费者获取元素的容器。 几个方法 在阻塞队列不可用的时候，上述2个附加操作提供了四种处理方法 方法处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove() poll() take() poll(time,unit) 检查方法 element() peek() 不可用 不可用 JAVA里的阻塞队列 JDK 7 提供了7个阻塞队列，如下 1、ArrayBlockingQueue 数组结构组成的有界阻塞队列。 此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。 2、LinkedBlockingQueue一个由链表结构组成的有界阻塞队列 此队列按照先出先进的原则对元素进行排序 3、PriorityBlockingQueue 支持优先级的无界阻塞队列 4、DelayQueue 支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素 5、SynchronousQueue不存储元素的阻塞队列，每一个put必须等待一个take操作，否则不能继续添加元素。并且他支持公平访问队列。 6、LinkedTransferQueue由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了tryTransfer和transfer方法 transfer方法 如果当前有消费者正在等待接收元素（take或者待时间限制的poll方法），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。 tryTransfer方法 用来试探生产者传入的元素能否直接传给消费者。，如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。 7、LinkedBlockingDeque链表结构的双向阻塞队列，优势在于多线程入队时，减少一半的竞争。 如何使用阻塞队列来实现生产者-消费者模型？ 通知模式实现：所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。 使用BlockingQueue解决生产者消费者问题 为什么BlockingQueue适合解决生产者消费者问题 任何有效的生产者-消费者问题解决方案都是通过控制生产者put()方法（生产资源）和消费者take()方法（消费资源）的调用来实现的，一旦你实现了对方法的阻塞控制，那么你将解决该问题。 Java通过BlockingQueue提供了开箱即用的支持来控制这些方法的调用（一个线程创建资源，另一个消费资源）。java.util.concurrent包下的BlockingQueue接口是一个线程安全的可用于存取对象的队列。 BlockingQueue是一种数据结构，支持一个线程往里存资源，另一个线程从里取资源。这正是解决生产者消费者问题所需要的，那么让我们开始解决该问题吧。 生产者 以下代码用于生产者线程 package io.ymq.example.thread; import java.util.concurrent.BlockingQueue; /** * 描述:生产者 * * @author yanpenglei * @create 2018-03-14 15:52 **/ class Producer implements Runnable { protected BlockingQueue&amp;lt;Object&amp;gt; queue; Producer(BlockingQueue&amp;lt;Object&amp;gt; theQueue) { this.queue = theQueue; } public void run() { try { while (true) { Object justProduced = getResource(); queue.put(justProduced); System.out.println(&quot;生产者资源队列大小= &quot; + queue.size()); } } catch (InterruptedException ex) { System.out.println(&quot;生产者 中断&quot;); } } Object getResource() { try { Thread.sleep(100); } catch (InterruptedException ex) { System.out.println(&quot;生产者 读 中断&quot;); } return new Object(); } } 消费者 以下代码用于消费者线程 package io.ymq.example.thread; import java.util.concurrent.BlockingQueue; /** * 描述: 消费者 * * @author yanpenglei * @create 2018-03-14 15:54 **/ class Consumer implements Runnable { protected BlockingQueue&amp;lt;Object&amp;gt; queue; Consumer(BlockingQueue&amp;lt;Object&amp;gt; theQueue) { this.queue = theQueue; } public void run() { try { while (true) { Object obj = queue.take(); System.out.println(&quot;消费者 资源 队列大小 &quot; + queue.size()); take(obj); } } catch (InterruptedException ex) { System.out.println(&quot;消费者 中断&quot;); } } void take(Object obj) { try { Thread.sleep(100); // simulate time passing } catch (InterruptedException ex) { System.out.println(&quot;消费者 读 中断&quot;); } System.out.println(&quot;消费对象 &quot; + obj); } } 测试该解决方案是否运行正常 package io.ymq.example.thread; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; /** * 描述: 测试 * * @author yanpenglei * @create 2018-03-14 15:58 **/ public class ProducerConsumerExample { public static void main(String[] args) throws InterruptedException { int numProducers = 4; int numConsumers = 3; BlockingQueue&amp;lt;Object&amp;gt; myQueue = new LinkedBlockingQueue&amp;lt;Object&amp;gt;(5); for (int i = 0; i &amp;lt; numProducers; i++) { new Thread(new Producer(myQueue)).start(); } for (int i = 0; i &amp;lt; numConsumers; i++) { new Thread(new Consumer(myQueue)).start(); } Thread.sleep(1000); System.exit(0); } } 运行结果 生产者资源队列大小= 1 生产者资源队列大小= 1 消费者 资源 队列大小 1 生产者资源队列大小= 1 消费者 资源 队列大小 1 消费者 资源 队列大小 1 生产者资源队列大小= 1 生产者资源队列大小= 3 消费对象 java.lang.Object@1e1aa52b 生产者资源队列大小= 2 生产者资源队列大小= 5 消费对象 java.lang.Object@6e740a76 消费对象 java.lang.Object@697853f6 ...... 消费对象 java.lang.Object@41a10cbc 消费对象 java.lang.Object@4963c8d1 消费者 资源 队列大小 5 生产者资源队列大小= 5 生产者资源队列大小= 5 消费者 资源 队列大小 4 消费对象 java.lang.Object@3e49c35d 消费者 资源 队列大小 4 生产者资源队列大小= 5 从输出结果中,我们可以发现队列大小永远不会超过5，消费者线程消费了生产者生产的资源</summary></entry></feed>