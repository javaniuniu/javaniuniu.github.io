<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2020-10-01T23:21:42+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JAVA 牛牛</title><subtitle>主要是想看下自己还能在多做些什么
</subtitle><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><entry><title type="html">Nacos基本信息</title><link href="http://localhost:4000/post/2020/10/01/nacos%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF.html" rel="alternate" type="text/html" title="Nacos基本信息" /><published>2020-10-01T00:00:00+08:00</published><updated>2020-10-01T00:00:00+08:00</updated><id>http://localhost:4000/post/2020/10/01/nacos%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF</id><content type="html" xml:base="http://localhost:4000/post/2020/10/01/nacos%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF.html">&lt;p&gt;nacos 基本信息&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><summary type="html">nacos 基本信息</summary></entry><entry><title type="html">分布式事务</title><link href="http://localhost:4000/SpringCloud/sop/transaction" rel="alternate" type="text/html" title="分布式事务" /><published>2020-09-15T00:00:00+08:00</published><updated>2020-09-15T00:00:00+08:00</updated><id>http://localhost:4000/SpringCloud/sop/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1</id><content type="html" xml:base="http://localhost:4000/SpringCloud/sop/transaction">&lt;h4 id=&quot;分布式事务&quot;&gt;分布式事务&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;分布式事务一般都是柔性事务
    &lt;ul&gt;
      &lt;li&gt;事务种类
        &lt;ul&gt;
          &lt;li&gt;刚性事务 acid  可以理解为实时一致性&lt;/li&gt;
          &lt;li&gt;柔性事务 base 可以理解为最终一致性&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当一个服务链路上要经过两个系统，就需要分布式事务&lt;/li&gt;
  &lt;li&gt;数据库的本地事务是怎么保证的
    &lt;ul&gt;
      &lt;li&gt;锁，redo，undo
        &lt;ul&gt;
          &lt;li&gt;ACID， AD（日志文件） CI（锁）&lt;/li&gt;
          &lt;li&gt;数据库在插入数据之前会先写日志文件，日志文件写之后操作写数据文件，如果事务提交了，而数据库没有插入，会执行 redo 操作，如果事务没有提交那么执行 undo 操作&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="SpringCloud" /><category term="transaction" /><summary type="html">分布式事务 分布式事务一般都是柔性事务 事务种类 刚性事务 acid 可以理解为实时一致性 柔性事务 base 可以理解为最终一致性 当一个服务链路上要经过两个系统，就需要分布式事务 数据库的本地事务是怎么保证的 锁，redo，undo ACID， AD（日志文件） CI（锁） 数据库在插入数据之前会先写日志文件，日志文件写之后操作写数据文件，如果事务提交了，而数据库没有插入，会执行 redo 操作，如果事务没有提交那么执行 undo 操作</summary></entry><entry><title type="html">zuul-server</title><link href="http://localhost:4000/SpringCloud/sop/zuul-server" rel="alternate" type="text/html" title="zuul-server" /><published>2020-09-14T00:00:00+08:00</published><updated>2020-09-14T00:00:00+08:00</updated><id>http://localhost:4000/SpringCloud/sop/zuul</id><content type="html" xml:base="http://localhost:4000/SpringCloud/sop/zuul-server">&lt;h3 id=&quot;zuul-基本使用&quot;&gt;zuul 基本使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;zuul（网关可以做什么）
    &lt;ul&gt;
      &lt;li&gt;分发服务&lt;/li&gt;
      &lt;li&gt;身份认证&lt;/li&gt;
      &lt;li&gt;过滤请求&lt;/li&gt;
      &lt;li&gt;监控&lt;/li&gt;
      &lt;li&gt;路由&lt;/li&gt;
      &lt;li&gt;限流&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;过滤器的执行顺序，节省计算的资源&lt;/li&gt;
  &lt;li&gt;网关接口容错
    &lt;ul&gt;
      &lt;li&gt;创建一个对象实现 FallbackProvider&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;生产中小技巧
    &lt;ul&gt;
      &lt;li&gt;db中存储：过滤器开关
        &lt;ul&gt;
          &lt;li&gt;配合 spring-boot-starter-actuator 更清爽&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;项目中遇到的问题&quot;&gt;项目中遇到的问题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用zuul cookie 和token 不能向后传递的问题&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;通过在yml里面配置下 ，把敏感信息制成空&lt;/p&gt;

        &lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;zuul&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#    以下配置，表示忽略下面的值向微服务传播，以下配置为空表示：所有请求头都透传到后面微服务。&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#  sensitive-headers:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;routes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 此处名字随便取&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;custom-zuul-name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/zuul-custom-name/**&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;service-id&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;service-sms&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;老项目改造中路由问题&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;方式一 yml配置&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;RibbonXXXFilter 路由到其他服务&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;SimpleHostRoultFilter 路由到其他url&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;SendForewordFilter 路由到自己的路径&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;zuul&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;routes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;xxx&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/forword1/**&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;forward:/myController&lt;/span&gt;
  
  
&lt;span class=&quot;c1&quot;&gt;#    # 配合 风雨冷人&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#    xxxx: /zuul-api-driver/**&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;##     此处名字随便取&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#    custom-zuul-name:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#      path: /zuul-api-driver/**&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#      url: http://localhost:8003/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;方式二，使用zuul的Filter&lt;/p&gt;

        &lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;1.过滤器 route&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;2.获取请求过来的url（请求）&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;3.url（请求） = url（目的地）映射&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;4.设置RequestContext中的 serviceid url&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;====&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;开发之前，想清楚步骤&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;技术和业务做选择和取舍。（100种方法，你去其中一种，出问题自己扛）&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动态路由（根据不同的用户路由到不同的服务）&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;路由到服务&lt;/li&gt;
      &lt;li&gt;路由到具体地址&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;微服务404的原因&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;url是从哪里拿到的
        &lt;ul&gt;
          &lt;li&gt;从eureka中拿到&lt;/li&gt;
          &lt;li&gt;从配置文件中拿到&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="SpringCloud" /><category term="zuul" /><summary type="html">zuul 基本使用 zuul（网关可以做什么） 分发服务 身份认证 过滤请求 监控 路由 限流 过滤器的执行顺序，节省计算的资源 网关接口容错 创建一个对象实现 FallbackProvider 生产中小技巧 db中存储：过滤器开关 配合 spring-boot-starter-actuator 更清爽 项目中遇到的问题 使用zuul cookie 和token 不能向后传递的问题 通过在yml里面配置下 ，把敏感信息制成空 zuul: # 以下配置，表示忽略下面的值向微服务传播，以下配置为空表示：所有请求头都透传到后面微服务。 # sensitive-headers: routes: # 此处名字随便取 custom-zuul-name: path: /zuul-custom-name/** service-id: service-sms 老项目改造中路由问题 方式一 yml配置 RibbonXXXFilter 路由到其他服务 SimpleHostRoultFilter 路由到其他url SendForewordFilter 路由到自己的路径 zuul: routes: xxx: path: /forword1/** url: forward:/myController # # 配合 风雨冷人 # xxxx: /zuul-api-driver/** ## 此处名字随便取 # custom-zuul-name: # path: /zuul-api-driver/** # url: http://localhost:8003/ 方式二，使用zuul的Filter 1.过滤器 route 2.获取请求过来的url（请求） 3.url（请求） = url（目的地）映射 4.设置RequestContext中的 serviceid url ==== 开发之前，想清楚步骤 技术和业务做选择和取舍。（100种方法，你去其中一种，出问题自己扛） 动态路由（根据不同的用户路由到不同的服务） 路由到服务 路由到具体地址 微服务404的原因 url是从哪里拿到的 从eureka中拿到 从配置文件中拿到</summary></entry><entry><title type="html">接口设计规范</title><link href="http://localhost:4000/SpringCloud/api/design" rel="alternate" type="text/html" title="接口设计规范" /><published>2020-09-12T00:00:00+08:00</published><updated>2020-09-12T00:00:00+08:00</updated><id>http://localhost:4000/SpringCloud/api/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1</id><content type="html" xml:base="http://localhost:4000/SpringCloud/api/design">&lt;h4 id=&quot;接口设计规范&quot;&gt;接口设计规范&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;协议：https:ios只能用https&lt;/li&gt;
  &lt;li&gt;域名： /api.yuming.com/&lt;/li&gt;
  &lt;li&gt;版本：v1&lt;/li&gt;
  &lt;li&gt;路径：/ooxx/xxoo&lt;/li&gt;
  &lt;li&gt;动作：&lt;/li&gt;
  &lt;li&gt;post：新建&lt;/li&gt;
  &lt;li&gt;put：修改（修改后的全量数据）&lt;/li&gt;
  &lt;li&gt;patch：修改（修改哪个传哪个）&lt;/li&gt;
  &lt;li&gt;delete：删除&lt;/li&gt;
  &lt;li&gt;get：查询&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;接口安全&quot;&gt;接口安全&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CIA：保密性，完整性，可用性&lt;/li&gt;
  &lt;li&gt;手机号，身份证号等要脱敏&lt;/li&gt;
  &lt;li&gt;数据层面
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;sql注入，（id，sql）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;select * form table where name=(变量；delete table)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;过滤 jsoup框架&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;xss: spring-htmlUtils&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;在正常用户请求中执行了黑客提供的恶意代码， &lt;strong&gt;用户数据没有过滤，转义&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;csrf（跨站伪装请求）:人机交互，token&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;冒充别人的登录信息，问题出在：&lt;strong&gt;没有防范不信任的调用&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Java对html标签的过滤和清洗
  https://www.cnblogs.com/qizhelongdeyang/p/9884716.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;referer：防盗链&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;数据权限控制&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;link1链接&lt;/li&gt;
          &lt;li&gt;A用户请求，删除 order/a1&lt;/li&gt;
          &lt;li&gt;B用户请求，删除 order/a1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;项目中优化的点&quot;&gt;项目中优化的点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;开发时用快照版本 生产环境不能用快照版本&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;通过将数据从堆移到栈中提升效率&lt;/li&gt;
  &lt;li&gt;常用不变的用缓存，不要用db（&lt;strong&gt;把内存用起来减少io&lt;/strong&gt; ，io是瓶颈，比如网络io，磁盘io）&lt;/li&gt;
  &lt;li&gt;提高QPS
    &lt;ul&gt;
      &lt;li&gt;提高并发数
        &lt;ul&gt;
          &lt;li&gt;能用多线程就使用多线程&lt;/li&gt;
          &lt;li&gt;增加各种连接数，tomcat，mysql，redis等等&lt;/li&gt;
          &lt;li&gt;服务无状态：便于横向扩展，扩机器&lt;/li&gt;
          &lt;li&gt;让服务能力怼等（serviceUrl，打乱顺序）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;减少相应时间
        &lt;ul&gt;
          &lt;li&gt;异步（最终一致性）&lt;/li&gt;
          &lt;li&gt;缓存&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="SpringCloud" /><summary type="html">接口设计规范 协议：https:ios只能用https 域名： /api.yuming.com/ 版本：v1 路径：/ooxx/xxoo 动作： post：新建 put：修改（修改后的全量数据） patch：修改（修改哪个传哪个） delete：删除 get：查询 接口安全 CIA：保密性，完整性，可用性 手机号，身份证号等要脱敏 数据层面 sql注入，（id，sql） select * form table where name=(变量；delete table) 过滤 jsoup框架 xss: spring-htmlUtils 在正常用户请求中执行了黑客提供的恶意代码， 用户数据没有过滤，转义 csrf（跨站伪装请求）:人机交互，token 冒充别人的登录信息，问题出在：没有防范不信任的调用 Java对html标签的过滤和清洗 https://www.cnblogs.com/qizhelongdeyang/p/9884716.html referer：防盗链 数据权限控制 link1链接 A用户请求，删除 order/a1 B用户请求，删除 order/a1 项目中优化的点 开发时用快照版本 生产环境不能用快照版本 通过将数据从堆移到栈中提升效率 常用不变的用缓存，不要用db（把内存用起来减少io ，io是瓶颈，比如网络io，磁盘io） 提高QPS 提高并发数 能用多线程就使用多线程 增加各种连接数，tomcat，mysql，redis等等 服务无状态：便于横向扩展，扩机器 让服务能力怼等（serviceUrl，打乱顺序） 减少相应时间 异步（最终一致性） 缓存</summary></entry><entry><title type="html">eureka-server</title><link href="http://localhost:4000/SpringCloud/sop/eureka-server" rel="alternate" type="text/html" title="eureka-server" /><published>2020-09-12T00:00:00+08:00</published><updated>2020-09-12T00:00:00+08:00</updated><id>http://localhost:4000/SpringCloud/sop/eureka</id><content type="html" xml:base="http://localhost:4000/SpringCloud/sop/eureka-server">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring-cloud-netflix/docs/2.2.5.RELEASE/reference/html/#refreshing-eureka-clients&quot;&gt;eureka集群配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/aaron911/p/11282364.html&quot;&gt;通过spring.factory文件来加载第三方的bean&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;eureka-server知识点&quot;&gt;eureka-server知识点&lt;/h4&gt;

&lt;p&gt;注册，下线，心跳，剔除，拉取注册表，集群同步&lt;/p&gt;

&lt;h4 id=&quot;生产环境相应优化&quot;&gt;生产环境相应优化&lt;/h4&gt;

&lt;h5 id=&quot;eureka-server-优化指导&quot;&gt;eureka-server 优化指导&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优化目的：减少服务上下线的延时&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自我保护的选择：看网络和服务情况&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务更新：停止，在发送线下请求&lt;/p&gt;

    &lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#    enable-replicated-request-compression: false #关闭自我保护&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;renewal-percent-threshold&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.85&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 在开启的情况下，设置自我保护阀值&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;eviction-interval-timer-in-ms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 踢除服务毫秒数，如果其他服务在1秒内拉取服务，还是能拉取的，包括不可用的服务&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;use-read-only-response-cache&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 关闭eureka 三级缓存 在高并发下可以更快速的读取数据&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;response-cache-update-interval-ms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 开启的情况下，提高服务被发现的速度&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;client配置总结&quot;&gt;client配置总结&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;刷新注册（拉取注册表）间隔&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;心跳间隔&lt;/p&gt;

    &lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;# 针对新服务上线, Eureka client获取不及时的问题，在测试环境，可以适当提高Client端拉取Server注册信息的频率，默认：30秒&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;registry-fetch-interval-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;
  
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;lease-renewal-interval-in-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 再续约时间&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实际工作中service-ul：打乱配置，不要所有的服务都写一样顺序的配置&lt;/p&gt;

    &lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;某一台连接eureka的客户端：defaultZone&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http://localhost:7900/eureka/,http://localhost:7901/eureka/,http://localhost:7902/eureka/&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;另一台连接eureka的客户端：defaultZone&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http://localhost:7901/eureka/,http://localhost:7900/eureka/,http://localhost:7902/eureka/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多个eureka之间要互相注册,才能互相通信同步信息&lt;/p&gt;

    &lt;p&gt;```yml
spring:
  application:
    name: cloud-eureka
eureka:
  instance:
  #    prefer-ip-address: true
  #    ip-address: 127.0.0.1&lt;/p&gt;

    &lt;p&gt;client:
    register-with-eureka: true # false 禁止自己当做服务注册
    fetch-registry: true # false #屏蔽注册信息
    service-url:
      # 5 24
      defaultZone: http://eureka-7900:7900/eureka/,http://eureka-7901:7901/eureka/,http://eureka-7902:7902/eureka/
      #,
  server:
    # 自我保护看自己情况
    enable-self-preservation: true
    # 续约阈值，和自我保护相关
    renewal-percent-threshold: 0.85
    # server剔除过期服务的时间间隔
    eviction-interval-timer-in-ms: 1000
    # 是否开启readOnly读缓存
    use-read-only-response-cache: true
    # 关闭 readOnly
    response-cache-update-interval-ms: 1000&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;spring:
    profiles: 7900
  server:
    port: 7900
  eureka:
    instance:
      hostname: eureka-7900
    client:
      register-with-eureka: true
      fetch-registry: true
      service-url:
        # 5 24 互相注册
        defaultZone: http://eureka-7900:7901/eureka/,http://eureka-7900:7902/eureka/&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;spring:
    profiles: 7901
  server:
    port: 7901
  eureka:
    instance:
      hostname: eureka-7901
    client:
      register-with-eureka: true
      fetch-registry: true
      service-url:
        # 5 24 互相注册
        defaultZone: http://eureka-7900:7900/eureka/,http://eureka-7900:7902/eureka/
  —
  spring:
    profiles: 7902
  server:
    port: 7902
  eureka:
    instance:
      hostname: eureka-7902
    client:
      register-with-eureka: true
      fetch-registry: true
      service-url:
        # 5 24 互相注册
        defaultZone: http://eureka-7900:7900/eureka/,http://eureka-7900:7901/eureka/&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
  

### eureka

#### cap

 - 三级缓存

   ```xml
   use-read-only-response-cache: false  # 关闭eureka 三级缓存 在高并发下可以更快速的读取数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从其他peer拉取注册表，peer&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;p：网络不好的情况下，还是可以拉取到注册表进行调用的，服务还可以调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;自我保护剔除eureka优化&quot;&gt;自我保护剔除(*eureka优化)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;eureka会定期的将没有心跳的服务剔除&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eviction-interval-timer-in-ms: 1000 # 踢除服务毫秒数，如果其他服务在1秒内拉取服务，还是能拉取的，包括不可用的服务
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开关&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enable-replicated-request-compression: false #关闭自我保护
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阀值&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;renewal-percent-threshold: 0.85 # 在开启的情况下，设置自我保护阀值
eviction-interval-timer-in-ms: 1000 # 踢除服务毫秒数，如果其他服务在1秒内拉取服务，还是能拉取的，包括不可用的服务
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;推荐: &lt;strong&gt;服务少不开自我保护，服务多开自我保护&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;当服务少时，开了自我保护，当其中一个服务不能使用，请求依然会指向不可用的服务&lt;/li&gt;
      &lt;li&gt;当服务多时，开启自我保护，因为服务集群够多，请求到不能使用的服务将会被路由的其他可用的服务，所以可以里面重启会在让不可以服务变为空用即可，比如网络抖动不用了，就没必要提出&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;服务即时感知
    &lt;ul&gt;
      &lt;li&gt;上线感知&lt;/li&gt;
      &lt;li&gt;下线感知&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓存问题&lt;/li&gt;
  &lt;li&gt;写度&lt;/li&gt;
  &lt;li&gt;滥用缓存&lt;/li&gt;
  &lt;li&gt;服务滞后时间&lt;/li&gt;
  &lt;li&gt;分布式事务&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;服务注册
    &lt;ul&gt;
      &lt;li&gt;服务向eureka注册，发送心跳，下线，服务向eureka拉取注册表&lt;/li&gt;
      &lt;li&gt;集群同步&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;服务发现
    &lt;ul&gt;
      &lt;li&gt;另一个服务也向eureka拉去注册表，拉去完之后，两个服务之间就可以互相调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cap 在eureka中为什么只有ap
    &lt;ul&gt;
      &lt;li&gt;C表示强一致性，而eureka 做不到&lt;/li&gt;
      &lt;li&gt;当新的eureka启动的时候，会触发拉取久的eureka的注册表，在在这个时候如果有新的服务向久的eureka发起注册，新的eureka时获取不到新的服务的信息的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;服务测算
    &lt;ul&gt;
      &lt;li&gt;20个服务，每个服务部署5个，则eureka lient 连接100个&lt;/li&gt;
      &lt;li&gt;默认30发起一次 renewal 再续时间，即1分钟200次心跳&lt;/li&gt;
      &lt;li&gt;一天差不多几十万次心跳，即 eureka每天能承受多大的访问量&lt;/li&gt;
      &lt;li&gt;
        &lt;h2 id=&quot;相应的可以选择对应能承受该心跳次数的硬件&quot;&gt;相应的可以选择对应能承受该心跳次数的硬件&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;eureka 使用guava 做缓存&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实际应用中可通过 guava 做一些 集合+时间 的一些业务，比如做限流&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;验证参数可以通过 validata实现，可以减少if else 的使用&lt;/li&gt;
  &lt;li&gt;CAP原则
    &lt;ul&gt;
      &lt;li&gt;一致性、可用性和分区容错性，其中最多只能同时满是两个，而大多数情况下时满是AP，可用性（集群解决单点故障），容错性（），一致性都是通过最终一致性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;序号&lt;/th&gt;
      &lt;th&gt;被抛弃的谁&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;放弃P，满足AC&lt;/td&gt;
      &lt;td&gt;将数据和服务都放在一个节点上，避免因网络引起的负面影响， 充分保证系统的可用性和一致性。但放弃P意味着放弃了系统的可扩展性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;放弃A，满足PC&lt;/td&gt;
      &lt;td&gt;当节点故障或者网络故障时，受到影响的服务需要等待一定的世 界，因此在等待时间里，系统无法对外提供正常服务，因此是不可用的&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;放弃C，满足AP&lt;/td&gt;
      &lt;td&gt;系统无法保证数据的实时一致性，但是承诺数据最终会保证一致 性。因此存在数据不一致的窗口期，至于窗口期的长短取决于系统的设计&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;面试题&quot;&gt;面试题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;生产环境中，服务重启时，先停服，在手动出发下线&lt;/li&gt;
&lt;/ul&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="SpringCloud" /><category term="eureka" /><summary type="html">eureka集群配置 通过spring.factory文件来加载第三方的bean eureka-server知识点 注册，下线，心跳，剔除，拉取注册表，集群同步 生产环境相应优化 eureka-server 优化指导 优化目的：减少服务上下线的延时 自我保护的选择：看网络和服务情况 服务更新：停止，在发送线下请求 server: # enable-replicated-request-compression: false #关闭自我保护 renewal-percent-threshold: 0.85 # 在开启的情况下，设置自我保护阀值 eviction-interval-timer-in-ms: 1000 # 踢除服务毫秒数，如果其他服务在1秒内拉取服务，还是能拉取的，包括不可用的服务 use-read-only-response-cache: true # 关闭eureka 三级缓存 在高并发下可以更快速的读取数据 response-cache-update-interval-ms: 1000 # 开启的情况下，提高服务被发现的速度 client配置总结 刷新注册（拉取注册表）间隔 心跳间隔 client: # 针对新服务上线, Eureka client获取不及时的问题，在测试环境，可以适当提高Client端拉取Server注册信息的频率，默认：30秒 registry-fetch-interval-seconds: 30 instance: lease-renewal-interval-in-seconds: 30 # 再续约时间 实际工作中service-ul：打乱配置，不要所有的服务都写一样顺序的配置 某一台连接eureka的客户端：defaultZone: http://localhost:7900/eureka/,http://localhost:7901/eureka/,http://localhost:7902/eureka/ 另一台连接eureka的客户端：defaultZone: http://localhost:7901/eureka/,http://localhost:7900/eureka/,http://localhost:7902/eureka/ 多个eureka之间要互相注册,才能互相通信同步信息 ```yml spring: application: name: cloud-eureka eureka: instance: # prefer-ip-address: true # ip-address: 127.0.0.1 client: register-with-eureka: true # false 禁止自己当做服务注册 fetch-registry: true # false #屏蔽注册信息 service-url: # 5 24 defaultZone: http://eureka-7900:7900/eureka/,http://eureka-7901:7901/eureka/,http://eureka-7902:7902/eureka/ #, server: # 自我保护看自己情况 enable-self-preservation: true # 续约阈值，和自我保护相关 renewal-percent-threshold: 0.85 # server剔除过期服务的时间间隔 eviction-interval-timer-in-ms: 1000 # 是否开启readOnly读缓存 use-read-only-response-cache: true # 关闭 readOnly response-cache-update-interval-ms: 1000 spring: profiles: 7900 server: port: 7900 eureka: instance: hostname: eureka-7900 client: register-with-eureka: true fetch-registry: true service-url: # 5 24 互相注册 defaultZone: http://eureka-7900:7901/eureka/,http://eureka-7900:7902/eureka/ spring: profiles: 7901 server: port: 7901 eureka: instance: hostname: eureka-7901 client: register-with-eureka: true fetch-registry: true service-url: # 5 24 互相注册 defaultZone: http://eureka-7900:7900/eureka/,http://eureka-7900:7902/eureka/ — spring: profiles: 7902 server: port: 7902 eureka: instance: hostname: eureka-7902 client: register-with-eureka: true fetch-registry: true service-url: # 5 24 互相注册 defaultZone: http://eureka-7900:7900/eureka/,http://eureka-7900:7901/eureka/ ### eureka #### cap - 三级缓存 ```xml use-read-only-response-cache: false # 关闭eureka 三级缓存 在高并发下可以更快速的读取数据 从其他peer拉取注册表，peer p：网络不好的情况下，还是可以拉取到注册表进行调用的，服务还可以调用 自我保护剔除(*eureka优化) eureka会定期的将没有心跳的服务剔除 eviction-interval-timer-in-ms: 1000 # 踢除服务毫秒数，如果其他服务在1秒内拉取服务，还是能拉取的，包括不可用的服务 开关 enable-replicated-request-compression: false #关闭自我保护 阀值 renewal-percent-threshold: 0.85 # 在开启的情况下，设置自我保护阀值 eviction-interval-timer-in-ms: 1000 # 踢除服务毫秒数，如果其他服务在1秒内拉取服务，还是能拉取的，包括不可用的服务 推荐: 服务少不开自我保护，服务多开自我保护 当服务少时，开了自我保护，当其中一个服务不能使用，请求依然会指向不可用的服务 当服务多时，开启自我保护，因为服务集群够多，请求到不能使用的服务将会被路由的其他可用的服务，所以可以里面重启会在让不可以服务变为空用即可，比如网络抖动不用了，就没必要提出 服务即时感知 上线感知 下线感知 缓存问题 写度 滥用缓存 服务滞后时间 分布式事务 服务注册 服务向eureka注册，发送心跳，下线，服务向eureka拉取注册表 集群同步 服务发现 另一个服务也向eureka拉去注册表，拉去完之后，两个服务之间就可以互相调用 Cap 在eureka中为什么只有ap C表示强一致性，而eureka 做不到 当新的eureka启动的时候，会触发拉取久的eureka的注册表，在在这个时候如果有新的服务向久的eureka发起注册，新的eureka时获取不到新的服务的信息的 服务测算 20个服务，每个服务部署5个，则eureka lient 连接100个 默认30发起一次 renewal 再续时间，即1分钟200次心跳 一天差不多几十万次心跳，即 eureka每天能承受多大的访问量 相应的可以选择对应能承受该心跳次数的硬件 eureka 使用guava 做缓存 实际应用中可通过 guava 做一些 集合+时间 的一些业务，比如做限流 验证参数可以通过 validata实现，可以减少if else 的使用 CAP原则 一致性、可用性和分区容错性，其中最多只能同时满是两个，而大多数情况下时满是AP，可用性（集群解决单点故障），容错性（），一致性都是通过最终一致性 序号 被抛弃的谁 说明 1 放弃P，满足AC 将数据和服务都放在一个节点上，避免因网络引起的负面影响， 充分保证系统的可用性和一致性。但放弃P意味着放弃了系统的可扩展性 2 放弃A，满足PC 当节点故障或者网络故障时，受到影响的服务需要等待一定的世 界，因此在等待时间里，系统无法对外提供正常服务，因此是不可用的 3 放弃C，满足AP 系统无法保证数据的实时一致性，但是承诺数据最终会保证一致 性。因此存在数据不一致的窗口期，至于窗口期的长短取决于系统的设计 面试题 生产环境中，服务重启时，先停服，在手动出发下线</summary></entry><entry><title type="html">微服务项目结构</title><link href="http://localhost:4000/SpringCloud/sop/design" rel="alternate" type="text/html" title="微服务项目结构" /><published>2020-09-12T00:00:00+08:00</published><updated>2020-09-12T00:00:00+08:00</updated><id>http://localhost:4000/SpringCloud/sop/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84</id><content type="html" xml:base="http://localhost:4000/SpringCloud/sop/design">&lt;p&gt;项目在独立的仓库&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;—online-taxi-tree&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— 项目A&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— 项目B&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;单独项目&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;— pom&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;— src&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— controller&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— service&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;​			impl&lt;/p&gt;

&lt;p&gt;​			接口&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— dao&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;​			entity&lt;/p&gt;

&lt;p&gt;​			mapper&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— manager&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— constant 常量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— request 接受的参数bean&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— response 返回的参数bean&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;—  resource&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— mapper&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;​&lt;/td&gt;
      &lt;td&gt;— xxxmapper.xml&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;​	yml&lt;/p&gt;

&lt;h3 id=&quot;异常&quot;&gt;异常&lt;/h3&gt;

&lt;p&gt;dao层的一次：必用打日志，catch，抛出去&lt;/p&gt;

&lt;p&gt;service：打日志，详细形象，时间，参数&lt;/p&gt;

&lt;p&gt;controller：异常包装成 状态码&lt;/p&gt;

&lt;h4 id=&quot;公司maven私服&quot;&gt;公司maven私服&lt;/h4&gt;

&lt;p&gt;userBean&lt;/p&gt;

&lt;p&gt;dto：common 二方库&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="SpringCloud" /><summary type="html">项目在独立的仓库 —online-taxi-tree ​ — 项目A ​ — 项目B 单独项目 — pom — src ​ — controller ​ — service ​ impl ​ 接口 ​ — dao ​ entity ​ mapper ​ — manager ​ — constant 常量 ​ — request 接受的参数bean ​ — response 返回的参数bean — resource ​ — mapper ​ — xxxmapper.xml ​ yml 异常 dao层的一次：必用打日志，catch，抛出去 service：打日志，详细形象，时间，参数 controller：异常包装成 状态码 公司maven私服 userBean dto：common 二方库</summary></entry><entry><title type="html">eureka中的核心参数</title><link href="http://localhost:4000/SpringCloud/sop/eureka/core" rel="alternate" type="text/html" title="eureka中的核心参数" /><published>2020-09-12T00:00:00+08:00</published><updated>2020-09-12T00:00:00+08:00</updated><id>http://localhost:4000/SpringCloud/sop/eureka/eureka%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0</id><content type="html" xml:base="http://localhost:4000/SpringCloud/sop/eureka/core">&lt;h1 id=&quot;eureka中的核心参数&quot;&gt;eureka中的核心参数：&lt;/h1&gt;

&lt;h2 id=&quot;client端核心参数&quot;&gt;client端核心参数：&lt;/h2&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;eureka&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;##=========&amp;gt;基本参数&amp;lt;============&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#告知Client有哪些region和availability-zones，支持配置修改运行时生效&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;availability-zones&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;null&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#是否过滤出注册到eureka中所有InstanceStatus为UP的实例，默认为true&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;filter-only-up-instances&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#是否将该实例注册到 eureka server，eureka注册中心配置为false，不把自身注册到eureka&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;register-with-eureka&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#是否优先使用与该实例处于相同zone的Eureka server ,默认为true，&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#即默认会使用与实力处于相同zone的server，如果找不到，才会默认使用defaultZone中配置的&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;prefer-same-zone-eureka&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#是否将本地实例状态通过ApplicationInfoManager实时同步到到Eureka Server中，默认是true，一般情况下不要改，默认就行&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;on-demand-update-status-change&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;##=========&amp;gt;定时任务参数&amp;lt;============&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#指定用于刷新缓存的CacheRefreshThread的线程池大小，默认是2个&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;cache-refresh-executor-thread-pool-size&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#调度任务执行超时时，下次再次执行的延时时间&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;cache-refresh-executor-exponential-back-off-bound&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;12&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#发送心跳线程的线程池大小&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;heartbeat-executor-thread-pool-size&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#CacherefreshThread线程的调度频率，eureka默认30秒刷新一次缓存&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;registry-fetch-interval-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#刷新Eureka Server地址的时间间隔&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;eureka-service-url-poll-interval-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;300&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#instanceInfoReplication将实例信息变更同步到Eureka Server的初始延时时间，默认40秒&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;initial-instance-info-replication-interval-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;40&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#InstanceInfoReplication将实例信息变更同步到Eureka Server的时间间隔&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;instance-info-replication-interval-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;



    &lt;span class=&quot;c1&quot;&gt;##=========&amp;gt;http参数&amp;lt;============&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#连接server的超时时间 默认5秒&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;eureka-server-connect-timeout-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#client 从server读取数据超时时间，默认8秒&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;eureka-server-read-timeout-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#连接池最大的活动链接数 最大默认200个连接数&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;eureka-server-total-connections&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#每个host能使用的最大连接数 ，默认每个主机最多只能使用50个练级&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;eureka-server-total-connections-per-host&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;50&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#连接池中连接的空闲时间&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;eureka-connection-idle-timeout-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;##=========&amp;gt;基本参数&amp;lt;============&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#指定该应用实例的元数据信息&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata-map&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#是否优先使用IP地址来代替host name作为市里的hostname字段值，默认是false&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;prefer-ip-address&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#指定Eureka Client间隔多久向Eureka Server发送心跳来告知Eureka Server该实例还存活，默认是90秒&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;lease-expiration-duration-in-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;


    &lt;span class=&quot;c1&quot;&gt;##=========&amp;gt;定时任务参数&amp;lt;============&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#Eureka Client向Server发送心跳的时间间隔，默认CLient隔30秒就会向Server发送一次心跳&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;lease-renewal-interval-in-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;server端参数&quot;&gt;Server端参数&lt;/h2&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;eureka&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;##=========&amp;gt;基本参数&amp;lt;============&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#是否开启自我保护模式，默认是开启的&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;enable-self-preservation&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#每分钟需要收到的续约次数的阈值 server会根据某个应用注册时实例数，计算每分钟应收到的续约次数&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#若收到的次数少于该阈值，server会关闭该租约，并禁止定时任务剔除失效的实例，保护注册信息&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;renewal-percent-threshold&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.85&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#指定updateRenewalThreshold定时任务的调度频率，来动态更新expectedNumberOfRenewsPerMin和numberOfRenewsPerMinThreshold值&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;renewal-threshold-update-interval-ms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;15&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#指定EvictionTask定时任务的调度频率，用于剔除过期的实例，默认是60秒执行一次&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;eviction-interval-timer-in-ms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;60000&lt;/span&gt;


    &lt;span class=&quot;c1&quot;&gt;##=========&amp;gt;response cache参数&amp;lt;============&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#是否使用只读的response-cache，默认是使用&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;use-read-only-response-cache&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#设置CacheUpdateTask的调度时间间隔，用于从readWriteCacheMap更新数据到readOnlyCacheMap&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#仅在use-read-only-response-cache设置为true是才生效&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;response-cache-update-interval-ms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30000&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#设置readWriteCacheMap的expireAfterWrite参数，指定写入多长时间后，cache过期&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;response-cache-auto-expiration-in-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;180&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;##=========&amp;gt;peer参数 eureka server节点间同步数据的配置&amp;lt;============&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#指定peerUpdateTask调度的时间间隔，&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#用于从配置文件刷新peerEurekaNodes节点之间的配置信息（eureka.client.serviceUrl相关的zone的配置）&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#默认10分钟&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;peer-eureka-nodes-update-interval-ms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#指定更新peer node状态的时间间隔，默认30秒更新各node间的状态信息&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;peer-eureka-status-refresh-time-interval-ms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30000&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;##=========&amp;gt;http参数&amp;lt;============&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#server各node间连接超时时长，默认200毫秒，200毫秒没连接上server的其他节点，就会认为该node不可用&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;peer-node-connect-timeout-ms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#从其他节点读取数据超时时间 ，默认200毫秒&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;peer-node-read-timeout-ms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#server的单个node连接池最大的活动连接数&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;peer-node-total-connections&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#server的单个node每个hot能使用的最大连接数&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;peer-node-total-connections-per-host&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#server的node连接池连接的空闲时间&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;peer-node-connection-idle-timeout-seconds&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;registry&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;##=========&amp;gt;基本参数&amp;lt;============&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;#指定每分钟需要收到的续约次数值，实际该值被写死为实例值*2&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;expected-number-of-clients-sending-renews&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;参数调优&quot;&gt;参数调优&lt;/h1&gt;

&lt;p&gt;一般最简单常见的问题有这几个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务下线了，为什么还能调通接口&lt;/li&gt;
  &lt;li&gt;服务注册了，Client不能及时获取到&lt;/li&gt;
  &lt;li&gt;自我保护机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;因为Eureka不是强一致性的，因此registry中会有过期的实例信息，实例过期有以下原因
    &lt;ul&gt;
      &lt;li&gt;应用实例异常挂掉，在挂掉之前没来得及通知Eureka Server要下线掉自己这个实例。这个要Eureka的 EvicitionTask去剔除了
        &lt;ul&gt;
          &lt;li&gt;剔除可以人工手动请求剔除&lt;/li&gt;
          &lt;li&gt;在yml配置文件中，可以配置剔除时间间隔，可以调小一些&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;应用实例下线时有通知Server下线自己这个实例，但是由于Server 的API有启用readOnlyCache，所以需要等 待缓存过期才能更新
        &lt;ul&gt;
          &lt;li&gt;缓存可以开启和关闭，关闭久不存在这个问题&lt;/li&gt;
          &lt;li&gt;在开启情况下，也可以设置更新缓存的时间&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;由于Server开启了自我保护机制，导致registry不能因过期而剔除
针对Client下线，没来得及通知server，可以调整EvictionTask的调度频率，加快剔除过期实例的频率&lt;/li&gt;
      &lt;li&gt;针对responseCache问题，可以根据实际情况关机readOnlyCacheMap，或者调整readWriteCacheMap的过期时间，缩短点cache过期时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;针对自我保护机制&lt;/strong&gt;，测试环境可以适当选择关闭自我保护机制。但是有时候，由于网络问题，Client的续约未能如期保持，但是服务本身是健康的，这个时候按照租约机制剔除的话，会造成误判。可以选择适当的调低触发自我保护机制的阈值，或者调低client向Server发送心跳的时间间隔&lt;/p&gt;

&lt;p&gt;针对服务上线了，Client不能及时获取到，可以适当提高Client获取Server注册信息的频率，如将30秒改为5秒&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="SpringCloud" /><category term="eureka" /><summary type="html">eureka中的核心参数： client端核心参数： eureka: client: ##=========&amp;gt;基本参数&amp;lt;============ #告知Client有哪些region和availability-zones，支持配置修改运行时生效 availability-zones: null #是否过滤出注册到eureka中所有InstanceStatus为UP的实例，默认为true filter-only-up-instances: true #是否将该实例注册到 eureka server，eureka注册中心配置为false，不把自身注册到eureka register-with-eureka: true #是否优先使用与该实例处于相同zone的Eureka server ,默认为true， #即默认会使用与实力处于相同zone的server，如果找不到，才会默认使用defaultZone中配置的 prefer-same-zone-eureka: true #是否将本地实例状态通过ApplicationInfoManager实时同步到到Eureka Server中，默认是true，一般情况下不要改，默认就行 on-demand-update-status-change: true ##=========&amp;gt;定时任务参数&amp;lt;============ #指定用于刷新缓存的CacheRefreshThread的线程池大小，默认是2个 cache-refresh-executor-thread-pool-size: 2 #调度任务执行超时时，下次再次执行的延时时间 cache-refresh-executor-exponential-back-off-bound: 12 #发送心跳线程的线程池大小 heartbeat-executor-thread-pool-size: 3 #CacherefreshThread线程的调度频率，eureka默认30秒刷新一次缓存 registry-fetch-interval-seconds: 30 #刷新Eureka Server地址的时间间隔 eureka-service-url-poll-interval-seconds: 300 #instanceInfoReplication将实例信息变更同步到Eureka Server的初始延时时间，默认40秒 initial-instance-info-replication-interval-seconds: 40 #InstanceInfoReplication将实例信息变更同步到Eureka Server的时间间隔 instance-info-replication-interval-seconds: 30 ##=========&amp;gt;http参数&amp;lt;============ #连接server的超时时间 默认5秒 eureka-server-connect-timeout-seconds: 5 #client 从server读取数据超时时间，默认8秒 eureka-server-read-timeout-seconds: 8 #连接池最大的活动链接数 最大默认200个连接数 eureka-server-total-connections: 200 #每个host能使用的最大连接数 ，默认每个主机最多只能使用50个练级 eureka-server-total-connections-per-host: 50 #连接池中连接的空闲时间 eureka-connection-idle-timeout-seconds: 30 instance: ##=========&amp;gt;基本参数&amp;lt;============ #指定该应用实例的元数据信息 metadata-map: #是否优先使用IP地址来代替host name作为市里的hostname字段值，默认是false prefer-ip-address: false #指定Eureka Client间隔多久向Eureka Server发送心跳来告知Eureka Server该实例还存活，默认是90秒 lease-expiration-duration-in-seconds: 30 ##=========&amp;gt;定时任务参数&amp;lt;============ #Eureka Client向Server发送心跳的时间间隔，默认CLient隔30秒就会向Server发送一次心跳 lease-renewal-interval-in-seconds: 30 Server端参数 eureka: server: ##=========&amp;gt;基本参数&amp;lt;============ #是否开启自我保护模式，默认是开启的 enable-self-preservation: true #每分钟需要收到的续约次数的阈值 server会根据某个应用注册时实例数，计算每分钟应收到的续约次数 #若收到的次数少于该阈值，server会关闭该租约，并禁止定时任务剔除失效的实例，保护注册信息 renewal-percent-threshold: 0.85 #指定updateRenewalThreshold定时任务的调度频率，来动态更新expectedNumberOfRenewsPerMin和numberOfRenewsPerMinThreshold值 renewal-threshold-update-interval-ms: 15 #指定EvictionTask定时任务的调度频率，用于剔除过期的实例，默认是60秒执行一次 eviction-interval-timer-in-ms: 60000 ##=========&amp;gt;response cache参数&amp;lt;============ #是否使用只读的response-cache，默认是使用 use-read-only-response-cache: true #设置CacheUpdateTask的调度时间间隔，用于从readWriteCacheMap更新数据到readOnlyCacheMap #仅在use-read-only-response-cache设置为true是才生效 response-cache-update-interval-ms: 30000 #设置readWriteCacheMap的expireAfterWrite参数，指定写入多长时间后，cache过期 response-cache-auto-expiration-in-seconds: 180 ##=========&amp;gt;peer参数 eureka server节点间同步数据的配置&amp;lt;============ #指定peerUpdateTask调度的时间间隔， #用于从配置文件刷新peerEurekaNodes节点之间的配置信息（eureka.client.serviceUrl相关的zone的配置） #默认10分钟 peer-eureka-nodes-update-interval-ms: 10 #指定更新peer node状态的时间间隔，默认30秒更新各node间的状态信息 peer-eureka-status-refresh-time-interval-ms: 30000 ##=========&amp;gt;http参数&amp;lt;============ #server各node间连接超时时长，默认200毫秒，200毫秒没连接上server的其他节点，就会认为该node不可用 peer-node-connect-timeout-ms: 200 #从其他节点读取数据超时时间 ，默认200毫秒 peer-node-read-timeout-ms: 200 #server的单个node连接池最大的活动连接数 peer-node-total-connections: 1000 #server的单个node每个hot能使用的最大连接数 peer-node-total-connections-per-host: 500 #server的node连接池连接的空闲时间 peer-node-connection-idle-timeout-seconds: 30 instance: registry: ##=========&amp;gt;基本参数&amp;lt;============ #指定每分钟需要收到的续约次数值，实际该值被写死为实例值*2 expected-number-of-clients-sending-renews: 1 参数调优 一般最简单常见的问题有这几个： 服务下线了，为什么还能调通接口 服务注册了，Client不能及时获取到 自我保护机制。 解决办法 因为Eureka不是强一致性的，因此registry中会有过期的实例信息，实例过期有以下原因 应用实例异常挂掉，在挂掉之前没来得及通知Eureka Server要下线掉自己这个实例。这个要Eureka的 EvicitionTask去剔除了 剔除可以人工手动请求剔除 在yml配置文件中，可以配置剔除时间间隔，可以调小一些 应用实例下线时有通知Server下线自己这个实例，但是由于Server 的API有启用readOnlyCache，所以需要等 待缓存过期才能更新 缓存可以开启和关闭，关闭久不存在这个问题 在开启情况下，也可以设置更新缓存的时间 由于Server开启了自我保护机制，导致registry不能因过期而剔除 针对Client下线，没来得及通知server，可以调整EvictionTask的调度频率，加快剔除过期实例的频率 针对responseCache问题，可以根据实际情况关机readOnlyCacheMap，或者调整readWriteCacheMap的过期时间，缩短点cache过期时间 针对自我保护机制，测试环境可以适当选择关闭自我保护机制。但是有时候，由于网络问题，Client的续约未能如期保持，但是服务本身是健康的，这个时候按照租约机制剔除的话，会造成误判。可以选择适当的调低触发自我保护机制的阈值，或者调低client向Server发送心跳的时间间隔 针对服务上线了，Client不能及时获取到，可以适当提高Client获取Server注册信息的频率，如将30秒改为5秒</summary></entry><entry><title type="html">设计模式</title><link href="http://localhost:4000/docs-util/design" rel="alternate" type="text/html" title="设计模式" /><published>2020-09-04T00:00:00+08:00</published><updated>2020-09-04T00:00:00+08:00</updated><id>http://localhost:4000/docs-util/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/docs-util/design">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;设计模式&lt;/th&gt;
      &lt;th&gt;典型应用&lt;/th&gt;
      &lt;th&gt;框架中的应用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;工厂方法&lt;/td&gt;
      &lt;td&gt;适合在单个产品上做纬度扩展&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;抽象工厂&lt;/td&gt;
      &lt;td&gt;适合在产品族的纬度上扩展&lt;/td&gt;
      &lt;td&gt;bean工厂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mediator 调节模式&lt;/td&gt;
      &lt;td&gt;消息中间件（内部之间调和）（居委会大妈）&lt;/td&gt;
      &lt;td&gt;mq&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Facade 门面模式&lt;/td&gt;
      &lt;td&gt;将复杂的服务整合，当用户访问后，可以通过简单的方式访问到复杂的服务（包工头）&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;责任链模式&lt;/td&gt;
      &lt;td&gt;需要用状态来确定责任是否完成，通常需要用boolean来确定&lt;/td&gt;
      &lt;td&gt;Filter Interceptor，Filter中FilterChain负责调用的顺序，里面是一个递归的方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Observer观察者&lt;/td&gt;
      &lt;td&gt;事件处理模型&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Decorator装饰器&lt;/td&gt;
      &lt;td&gt;顾名思义，就是在原来的基础上在加一层装饰，装饰的类和被装饰的类都可以横向扩展（在开发的时候，就是类在继承，而方法在嵌套）&lt;/td&gt;
      &lt;td&gt;在IO流中，比如Reader 包含InputStream&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*观察者模式Observer&lt;/td&gt;
      &lt;td&gt;观察者很少和事件源打交道，主要是和事件打交道，和Listener，hook function，callback function 都是观察者&lt;/td&gt;
      &lt;td&gt;很多系统中，Observer模式往往和负责责任链共同负责对于事件的处理，其中某一个observer负责是否将事件进一步传递&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;组合Composite&lt;/td&gt;
      &lt;td&gt;树状结构专用模式&lt;/td&gt;
      &lt;td&gt;可用于导航栏&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;享元Flyweight&lt;/td&gt;
      &lt;td&gt;重复利用对象，共享元数据，有池化的概念&lt;/td&gt;
      &lt;td&gt;String 就是这个模式，使用的时候 可以和组合模式一起使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;代理模式&lt;/td&gt;
      &lt;td&gt;静态代理，动态代理，springAop，代理也实现被代理类的接口，并在代理类中将接口类作为成员变量&lt;/td&gt;
      &lt;td&gt;有点类似 Decorator&lt;br /&gt;jdk实现的动态代理需要 实体类实现了接口&lt;br /&gt;cglib可以对任何类进行动态代理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*Iteratror迭代器&lt;/td&gt;
      &lt;td&gt;容器，容器遍历&lt;/td&gt;
      &lt;td&gt;其实就是多态的一个应用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Visitor访问者&lt;/td&gt;
      &lt;td&gt;在结构不变的情况下动态改变对于内部元素的动作&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ASM&lt;/td&gt;
      &lt;td&gt;Iteratror+Visitor+chainfresposibility&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;builder&lt;/td&gt;
      &lt;td&gt;构建复杂的对象&lt;/td&gt;
      &lt;td&gt;链式编程（在类的众多参数中，你只需要其中的一些时候，使用该模式，看代码）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Adapter（Wrapper）&lt;/td&gt;
      &lt;td&gt;接口转换器&lt;/td&gt;
      &lt;td&gt;相当于插线板的转接头一样，加一层&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bridge&lt;/td&gt;
      &lt;td&gt;双纬度扩展&lt;/td&gt;
      &lt;td&gt;分离抽象和具体&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Command&lt;/td&gt;
      &lt;td&gt;封装命令（doit和undo方法）&lt;/td&gt;
      &lt;td&gt;别名：Action/Transaction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Prototype原型模式/克隆模式&lt;/td&gt;
      &lt;td&gt;Object.clone() Object 自带clone模式&lt;/td&gt;
      &lt;td&gt;有浅克隆和深克隆区分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Memento备忘录&lt;/td&gt;
      &lt;td&gt;记录状态便于回滚&lt;/td&gt;
      &lt;td&gt;记录快照（瞬时状态），存盘，使用File做序列化时，使用transient 表示透明的，不需要存盘，需要存盘的都需要实现序列化接口，或者父类实现序列化接口，在网络传输中序列化通常使用google的ProtoBuf&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TemplateMethod模版方法（钩子函数）&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;State状态模式&lt;/td&gt;
      &lt;td&gt;根据状态决定行为&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Intepreter解析器&lt;/td&gt;
      &lt;td&gt;动态脚本解析&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;记住典型的用法和类图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/util/0906/Jietu20200905-002623@2x.jpg&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/util/0906/Jietu20200905-003109@2x.jpg&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/util/0906/Jietu20200905-142642@2x.jpg&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/util/0906/Jietu20200906-015254@2x.jpg&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/util/0906/Jietu20200906-094229@2x.jpg&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;静态代理&quot;&gt;静态代理&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 问题：我想记录坦克的移动时间
 * 最简单的办法：修改代码，记录时间
 * 问题2：如果无法改变方法源码呢？
 * 用继承？
 * v05:使用代理
 * v06:代理有各种类型
 * 问题：如何实现代理的各种组合？继承？Decorator?
 * v07:代理的对象改成Movable类型-越来越像decorator了
 *
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tank&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * 模拟坦克移动了一段儿时间
     */&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Tank moving claclacla...&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;Tank&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;TankTimeProxy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ttp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TankTimeProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;TankLogProxy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tlp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TankLogProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ttp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tlp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//        new TankLogProxy(&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                new TankTimeProxy(&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                        new Tank()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                )&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        ).move();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TankTimeProxy&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TankTimeProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TankLogProxy&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TankLogProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;start moving...&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stopped!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;动态代理&quot;&gt;动态代理&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 问题：我想记录坦克的移动时间
 * 最简单的办法：修改代码，记录时间
 * 问题2：如果无法改变方法源码呢？
 * 用继承？
 * v05:使用代理
 * v06:代理有各种类型
 * 问题：如何实现代理的各种组合？继承？Decorator?
 * v07:代理的对象改成Movable类型-越来越像decorator了
 * v08:如果有stop方法需要代理...
 * 如果想让LogProxy可以重用，不仅可以代理Tank，还可以代理任何其他可以代理的类型
 * （毕竟日志记录，时间计算是很多方法都需要的东西），这时该怎么做呢？
 * 分离代理行为与被代理对象
 * 使用jdk的动态代理
 *
 * v09: 横切代码与业务逻辑代码分离 AOP
 * v10: 通过反射观察生成的代理对象
 * jdk反射生成代理必须面向接口，这是由Proxy的内部实现决定的
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tank&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * 模拟坦克移动了一段儿时间
     */&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Tank moving claclacla...&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Tank&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProperties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newProxyInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Tank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]{&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//tank.class.getInterfaces()&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TimeProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimeProxy&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InvocationHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TimeProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;method start..&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;method stop..&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//Arrays.stream(proxy.getClass().getMethods()).map(Method::getName).forEach(System.out::println);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;链式编程-builder模式&quot;&gt;链式编程 builder模式&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PersonBuilder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PersonBuilder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;basicInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PersonBuilder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PersonBuilder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;score&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PersonBuilder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;street&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roomNo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;street&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roomNo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PersonBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;basicInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//.score(20)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//.loc(&quot;bj&quot;, &quot;23&quot;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;street&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roomNo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;street&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roomNo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;street&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;street&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;roomNo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roomNo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="设计模式" /><summary type="html">设计模式 典型应用 框架中的应用 工厂方法 适合在单个产品上做纬度扩展   抽象工厂 适合在产品族的纬度上扩展 bean工厂 Mediator 调节模式 消息中间件（内部之间调和）（居委会大妈） mq Facade 门面模式 将复杂的服务整合，当用户访问后，可以通过简单的方式访问到复杂的服务（包工头）   责任链模式 需要用状态来确定责任是否完成，通常需要用boolean来确定 Filter Interceptor，Filter中FilterChain负责调用的顺序，里面是一个递归的方法 Observer观察者 事件处理模型   Decorator装饰器 顾名思义，就是在原来的基础上在加一层装饰，装饰的类和被装饰的类都可以横向扩展（在开发的时候，就是类在继承，而方法在嵌套） 在IO流中，比如Reader 包含InputStream *观察者模式Observer 观察者很少和事件源打交道，主要是和事件打交道，和Listener，hook function，callback function 都是观察者 很多系统中，Observer模式往往和负责责任链共同负责对于事件的处理，其中某一个observer负责是否将事件进一步传递 组合Composite 树状结构专用模式 可用于导航栏 享元Flyweight 重复利用对象，共享元数据，有池化的概念 String 就是这个模式，使用的时候 可以和组合模式一起使用 代理模式 静态代理，动态代理，springAop，代理也实现被代理类的接口，并在代理类中将接口类作为成员变量 有点类似 Decoratorjdk实现的动态代理需要 实体类实现了接口cglib可以对任何类进行动态代理 *Iteratror迭代器 容器，容器遍历 其实就是多态的一个应用 Visitor访问者 在结构不变的情况下动态改变对于内部元素的动作   ASM Iteratror+Visitor+chainfresposibility   builder 构建复杂的对象 链式编程（在类的众多参数中，你只需要其中的一些时候，使用该模式，看代码） Adapter（Wrapper） 接口转换器 相当于插线板的转接头一样，加一层 Bridge 双纬度扩展 分离抽象和具体 Command 封装命令（doit和undo方法） 别名：Action/Transaction Prototype原型模式/克隆模式 Object.clone() Object 自带clone模式 有浅克隆和深克隆区分 Memento备忘录 记录状态便于回滚 记录快照（瞬时状态），存盘，使用File做序列化时，使用transient 表示透明的，不需要存盘，需要存盘的都需要实现序列化接口，或者父类实现序列化接口，在网络传输中序列化通常使用google的ProtoBuf TemplateMethod模版方法（钩子函数）     State状态模式 根据状态决定行为   Intepreter解析器 动态脚本解析   记住典型的用法和类图 静态代理 /** * 问题：我想记录坦克的移动时间 * 最简单的办法：修改代码，记录时间 * 问题2：如果无法改变方法源码呢？ * 用继承？ * v05:使用代理 * v06:代理有各种类型 * 问题：如何实现代理的各种组合？继承？Decorator? * v07:代理的对象改成Movable类型-越来越像decorator了 * */ public class Tank implements Movable { /** * 模拟坦克移动了一段儿时间 */ @Override public void move() { System.out.println(&quot;Tank moving claclacla...&quot;); try { Thread.sleep(new Random().nextInt(10000)); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) { Tank t = new Tank(); TankTimeProxy ttp = new TankTimeProxy(t); TankLogProxy tlp = new TankLogProxy(ttp); tlp.move(); // new TankLogProxy( // new TankTimeProxy( // new Tank() // ) // ).move(); } } class TankTimeProxy implements Movable { Movable m; public TankTimeProxy(Movable m) { this.m = m; } @Override public void move() { long start = System.currentTimeMillis(); m.move(); long end = System.currentTimeMillis(); System.out.println(end - start); } } class TankLogProxy implements Movable { Movable m; public TankLogProxy(Movable m) { this.m = m; } @Override public void move() { System.out.println(&quot;start moving...&quot;); m.move(); long end = System.currentTimeMillis(); System.out.println(&quot;stopped!&quot;); } } interface Movable { void move(); } 动态代理 /** * 问题：我想记录坦克的移动时间 * 最简单的办法：修改代码，记录时间 * 问题2：如果无法改变方法源码呢？ * 用继承？ * v05:使用代理 * v06:代理有各种类型 * 问题：如何实现代理的各种组合？继承？Decorator? * v07:代理的对象改成Movable类型-越来越像decorator了 * v08:如果有stop方法需要代理... * 如果想让LogProxy可以重用，不仅可以代理Tank，还可以代理任何其他可以代理的类型 * （毕竟日志记录，时间计算是很多方法都需要的东西），这时该怎么做呢？ * 分离代理行为与被代理对象 * 使用jdk的动态代理 * * v09: 横切代码与业务逻辑代码分离 AOP * v10: 通过反射观察生成的代理对象 * jdk反射生成代理必须面向接口，这是由Proxy的内部实现决定的 */ public class Tank implements Movable { /** * 模拟坦克移动了一段儿时间 */ @Override public void move() { System.out.println(&quot;Tank moving claclacla...&quot;); try { Thread.sleep(new Random().nextInt(10000)); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) { Tank tank = new Tank(); System.getProperties().put(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;); Movable m = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader(), new Class[]{Movable.class}, //tank.class.getInterfaces() new TimeProxy(tank) ); m.move(); } } class TimeProxy implements InvocationHandler { Movable m; public TimeProxy(Movable m) { this.m = m; } public void before() { System.out.println(&quot;method start..&quot;); } public void after() { System.out.println(&quot;method stop..&quot;); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //Arrays.stream(proxy.getClass().getMethods()).map(Method::getName).forEach(System.out::println); before(); Object o = method.invoke(m, args); after(); return o; } } interface Movable { void move(); } 链式编程 builder模式 public class Person { int id; String name; int age; double weight; int score; Location loc; private Person() {} public static class PersonBuilder { Person p = new Person(); public PersonBuilder basicInfo(int id, String name, int age) { p.id = id; p.name = name; p.age = age; return this; } public PersonBuilder weight(double weight) { p.weight = weight; return this; } public PersonBuilder score(int score) { p.score = score; return this; } public PersonBuilder loc(String street, String roomNo) { p.loc = new Location(street, roomNo); return this; } public Person build() { return p; } } public static void main(String[] args) { Person p = new Person.PersonBuilder() .basicInfo(1, &quot;zhangsan&quot;, 18) //.score(20) .weight(200) //.loc(&quot;bj&quot;, &quot;23&quot;) .build(); } } class Location { String street; String roomNo; public Location(String street, String roomNo) { this.street = street; this.roomNo = roomNo; } }</summary></entry><entry><title type="html">ThreadPoolExecutor源码解析</title><link href="http://localhost:4000/java/ThreadPoolExecutor/01" rel="alternate" type="text/html" title="ThreadPoolExecutor源码解析" /><published>2020-09-02T00:00:00+08:00</published><updated>2020-09-02T00:00:00+08:00</updated><id>http://localhost:4000/java/ThreadPoolExecutor/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/java/ThreadPoolExecutor/01">&lt;p&gt;#&lt;/p&gt;

&lt;h3 id=&quot;1常用变量的解释&quot;&gt;1、常用变量的解释&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AtomicInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AtomicInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctlOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RUNNING&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;COUNT_BITS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;CAPACITY&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;COUNT_BITS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// runState is stored in the high-order bits&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 4. 线程池有5种状态，按大小排序如下：RUNNING &amp;lt; SHUTDOWN &amp;lt; STOP &amp;lt; TIDYING &amp;lt; TERMINATED&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;RUNNING&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;COUNT_BITS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SHUTDOWN&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;COUNT_BITS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;STOP&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;COUNT_BITS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TIDYING&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;COUNT_BITS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TERMINATED&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;COUNT_BITS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Packing and unpacking ctl&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runStateOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;workerCountOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ctlOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * Bit field accessors that don't require unpacking ctl.
 * These depend on the bit layout and on workerCount being never negative.
 */&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 8. `runStateLessThan()`，线程池状态小于xx&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runStateLessThan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 9. `runStateAtLeast()`，线程池状态大于等于xx&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runStateAtLeast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2构造方法&quot;&gt;2、构造方法&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;nc&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;nc&quot;&gt;ThreadFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;nc&quot;&gt;RejectedExecutionHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 基本类型参数校验&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 空指针校验&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workQueue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NullPointerException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;corePoolSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;maximumPoolSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;workQueue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;keepAliveTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toNanos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;threadFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3提交执行task的过程&quot;&gt;3、提交执行task的过程&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NullPointerException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*
     * Proceed in 3 steps:
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// worker数量比核心线程数小，直接创建worker执行任务&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workerCountOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addWorker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// worker数量超过核心线程数，任务直接进入队列&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recheck&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workerCountOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;addWorker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 这儿有3点需要注意：&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 1. 线程池不是运行状态时，addWorker内部会判断线程池状态&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 2. addWorker第2个参数表示是否创建核心线程&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 3. addWorker返回false，则说明任务执行失败，需要执行reject操作&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addWorker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4addworker源码解析&quot;&gt;4、addworker源码解析&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addWorker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;retry:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 外层自旋&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runStateOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// (rs &amp;gt; SHUTDOWN) ||&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask != null) ||&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// (rs == SHUTDOWN &amp;amp;&amp;amp; workQueue.isEmpty())&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 1. 线程池状态大于SHUTDOWN时，直接返回false&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Check if queue empty only if necessary.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SHUTDOWN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SHUTDOWN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;firstTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
               &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 内层自旋&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workerCountOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// worker数量超过容量，直接返回false&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 使用CAS的方式增加worker数量。&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 若增加成功，则直接跳出外层循环进入到第二部分&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compareAndIncrementWorkerCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Re-read ctl&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 线程池状态发生变化，对外层循环进行自旋&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runStateOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 其他情况，直接内层循环进行自旋即可&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// else CAS failed due to workerCount change; retry inner loop&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workerStarted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workerAdded&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Worker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Worker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ReentrantLock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mainLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mainLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// worker的添加必须是串行的，因此需要加锁&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mainLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Recheck while holding lock.&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Back out on ThreadFactory failure or if&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// shut down before lock acquired.&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 这儿需要重新检查线程池状态&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runStateOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SHUTDOWN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SHUTDOWN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// worker已经调用过了start()方法，则不再创建worker&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isAlive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// precheck that t is startable&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalThreadStateException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// worker创建并添加到workers成功&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;workers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 更新`largestPoolSize`变量&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;largestPoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;largestPoolSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;workerAdded&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;mainLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 启动worker线程&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workerAdded&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;workerStarted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workerStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;addWorkerFailed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workerStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5线程池worker任务单元&quot;&gt;5、线程池worker任务单元&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Worker&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractQueuedSynchronizer&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialVersionUID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6138294804551838833L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** Thread this worker is running in.  Null if factory fails. */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/** Initial task to run.  Possibly null. */&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/** Per-thread task counter */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completedTasks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * Creates with given first task and thread from ThreadFactory.
     * @param firstTask the first task (null if none)
     */&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Worker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// inhibit interrupts until runWorker&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;firstTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getThreadFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** Delegates main run loop to outer runWorker  */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;runWorker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 省略代码...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6核心线程执行逻辑-runworker&quot;&gt;6、核心线程执行逻辑-runworker&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runWorker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Worker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;firstTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;firstTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 调用unlock()是为了让外部可以中断&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// allow interrupts&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 这个变量用于判断是否进入过自旋（while循环）&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completedAbruptly&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 这儿是自旋&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 1. 如果firstTask不为null，则执行firstTask；&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 2. 如果firstTask为null，则调用getTask()从队列获取任务。&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 这儿对worker进行加锁，是为了达到下面的目的&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 1. 降低锁范围，提升性能&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 2. 保证每个worker执行的任务是串行的&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// If pool is stopping, ensure thread is interrupted;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// if not, ensure thread is not interrupted.  This&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// requires a recheck in second case to deal with&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// shutdownNow race while clearing interrupt&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 如果线程池正在停止，则对当前线程进行中断操作&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runStateAtLeast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;STOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;runStateAtLeast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;STOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;wt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 这两个方法在当前类里面为空实现。&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;beforeExecute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thrown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RuntimeException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;thrown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;thrown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;thrown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;afterExecute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thrown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 帮助gc&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 已完成任务数加一&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;completedTasks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;completedAbruptly&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 自旋操作被退出，说明线程池正在结束&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;processWorkerExit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completedAbruptly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="多线程" /><summary type="html"># 1、常用变量的解释 // 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29 private static final int COUNT_BITS = Integer.SIZE - 3; // 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1 private static final int CAPACITY = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1; // runState is stored in the high-order bits // 4. 线程池有5种状态，按大小排序如下：RUNNING &amp;lt; SHUTDOWN &amp;lt; STOP &amp;lt; TIDYING &amp;lt; TERMINATED private static final int RUNNING = -1 &amp;lt;&amp;lt; COUNT_BITS; private static final int SHUTDOWN = 0 &amp;lt;&amp;lt; COUNT_BITS; private static final int STOP = 1 &amp;lt;&amp;lt; COUNT_BITS; private static final int TIDYING = 2 &amp;lt;&amp;lt; COUNT_BITS; private static final int TERMINATED = 3 &amp;lt;&amp;lt; COUNT_BITS; // Packing and unpacking ctl // 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0 private static int runStateOf(int c) { return c &amp;amp; ~CAPACITY; } // 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0 private static int workerCountOf(int c) { return c &amp;amp; CAPACITY; } // 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值 private static int ctlOf(int rs, int wc) { return rs | wc; } /* * Bit field accessors that don't require unpacking ctl. * These depend on the bit layout and on workerCount being never negative. */ // 8. `runStateLessThan()`，线程池状态小于xx private static boolean runStateLessThan(int c, int s) { return c &amp;lt; s; } // 9. `runStateAtLeast()`，线程池状态大于等于xx private static boolean runStateAtLeast(int c, int s) { return c &amp;gt;= s; } 2、构造方法 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { // 基本类型参数校验 if (corePoolSize &amp;lt; 0 || maximumPoolSize &amp;lt;= 0 || maximumPoolSize &amp;lt; corePoolSize || keepAliveTime &amp;lt; 0) throw new IllegalArgumentException(); // 空指针校验 if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; // 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中 this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 3、提交执行task的过程 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); // worker数量比核心线程数小，直接创建worker执行任务 if (workerCountOf(c) &amp;lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } // worker数量超过核心线程数，任务直接进入队列 if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) { int recheck = ctl.get(); // 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。 // 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。 if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command)) reject(command); // 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。 // 这儿有3点需要注意： // 1. 线程池不是运行状态时，addWorker内部会判断线程池状态 // 2. addWorker第2个参数表示是否创建核心线程 // 3. addWorker返回false，则说明任务执行失败，需要执行reject操作 else if (!addWorker(command, false)) reject(command); } 4、addworker源码解析 private boolean addWorker(Runnable firstTask, boolean core) { retry: // 外层自旋 for (;;) { int c = ctl.get(); int rs = runStateOf(c); // 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价 // (rs &amp;gt; SHUTDOWN) || // (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask != null) || // (rs == SHUTDOWN &amp;amp;&amp;amp; workQueue.isEmpty()) // 1. 线程池状态大于SHUTDOWN时，直接返回false // 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false // 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false // Check if queue empty only if necessary. if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; ! (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null &amp;amp;&amp;amp; ! workQueue.isEmpty())) return false; // 内层自旋 for (;;) { int wc = workerCountOf(c); // worker数量超过容量，直接返回false if (wc &amp;gt;= CAPACITY || wc &amp;gt;= (core ? corePoolSize : maximumPoolSize)) return false; // 使用CAS的方式增加worker数量。 // 若增加成功，则直接跳出外层循环进入到第二部分 if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl // 线程池状态发生变化，对外层循环进行自旋 if (runStateOf(c) != rs) continue retry; // 其他情况，直接内层循环进行自旋即可 // else CAS failed due to workerCount change; retry inner loop } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { w = new Worker(firstTask); final Thread t = w.thread; if (t != null) { final ReentrantLock mainLock = this.mainLock; // worker的添加必须是串行的，因此需要加锁 mainLock.lock(); try { // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. // 这儿需要重新检查线程池状态 int rs = runStateOf(ctl.get()); if (rs &amp;lt; SHUTDOWN || (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) { // worker已经调用过了start()方法，则不再创建worker if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // worker创建并添加到workers成功 workers.add(w); // 更新`largestPoolSize`变量 int s = workers.size(); if (s &amp;gt; largestPoolSize) largestPoolSize = s; workerAdded = true; } } finally { mainLock.unlock(); } // 启动worker线程 if (workerAdded) { t.start(); workerStarted = true; } } } finally { // worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作 if (! workerStarted) addWorkerFailed(w); } return workerStarted; } 5、线程池worker任务单元 private final class Worker extends AbstractQueuedSynchronizer implements Runnable { /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; // 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker this.thread = getThreadFactory().newThread(this); } /** Delegates main run loop to outer runWorker */ public void run() { runWorker(this); } // 省略代码... } 6、核心线程执行逻辑-runworker final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; // 调用unlock()是为了让外部可以中断 w.unlock(); // allow interrupts // 这个变量用于判断是否进入过自旋（while循环） boolean completedAbruptly = true; try { // 这儿是自旋 // 1. 如果firstTask不为null，则执行firstTask； // 2. 如果firstTask为null，则调用getTask()从队列获取任务。 // 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待 while (task != null || (task = getTask()) != null) { // 这儿对worker进行加锁，是为了达到下面的目的 // 1. 降低锁范围，提升性能 // 2. 保证每个worker执行的任务是串行的 w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt // 如果线程池正在停止，则对当前线程进行中断操作 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;amp;&amp;amp; runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp; !wt.isInterrupted()) wt.interrupt(); // 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。 // 这两个方法在当前类里面为空实现。 try { beforeExecute(wt, task); Throwable thrown = null; try { task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); } } finally { // 帮助gc task = null; // 已完成任务数加一 w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { // 自旋操作被退出，说明线程池正在结束 processWorkerExit(w, completedAbruptly); } }</summary></entry><entry><title type="html">Servlet的多线程 和 Servlet线程安全</title><link href="http://localhost:4000/java/juc/02" rel="alternate" type="text/html" title="Servlet的多线程 和 Servlet线程安全" /><published>2020-09-01T00:00:00+08:00</published><updated>2020-09-01T00:00:00+08:00</updated><id>http://localhost:4000/java/juc/Servlet%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%20%E5%92%8C%20Servlet%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8</id><content type="html" xml:base="http://localhost:4000/java/juc/02">&lt;p&gt;&lt;strong&gt;JSP/Servlet的多线程原理:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.servelet就是一个CGI,但比传统的CGI要快得过&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传统CGI是多进程的,servlet是多线程的
以多线程方式执行可大大降低对系统的资源需求,提高 系统的并发量及响应时间.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JSP/Servlet容器默认是采用&lt;strong&gt;单实例多线程(这是造成线程安全的主因)&lt;/strong&gt;方式处理多个请求的：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当客户端第一次请求某一个JSP文件时(有的servlet是随容器启动就startup)：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;服务端把该JSP编译成一个CLASS文件&lt;/li&gt;
  &lt;li&gt;并创建一个该类的实例&lt;/li&gt;
  &lt;li&gt;然后&lt;strong&gt;创建一个线程&lt;/strong&gt;处理CLIENT端的请求。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;多请求，多线程：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果有多个客户端同时请求该JSP文件，则服务端会创建多个线程。每个客户端请求对应一个线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;servlet 的线程安全&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;servlet里的 实例变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;servlet里的实例变量，是&lt;strong&gt;被所有线程共享&lt;/strong&gt;的,所以不是线程安全的.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;servlet方法里的局部变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为每个线程都有它自己的堆栈空间,方法内局部变量存储在这个线程堆栈空间内,
且参数传入方法是按传值volue copy的方式
所以是线程安全的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Application对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在container运行期间,被整个系统内所有用户共同使用,所以不是线程安全 的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ServletContext对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ServletContext是可以多线程同时读/写属性的,线程是不安全的&lt;/strong&gt;。
&lt;strong&gt;struts2 的ServletContext采用的是TreadLocal模式,是线程安全的&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HttpServletRequest对象和HttpServletResponse对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一个请求，由一个工作线程来执行，都会&lt;strong&gt;创建&lt;/strong&gt;有一对新的ServletRequest对象和ServletResponse,然后传入service()方法内
&lt;strong&gt;所以每个ServletRequest对象对应每个线程，而不是多线程共享，是线程安全的&lt;/strong&gt;。所以不用担心request参数和属性的线程安全性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HttpSession&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Session对象在用户session期间存在，&lt;strong&gt;只能在属于同一个SessionID的请求的线程中被访问&lt;/strong&gt;，因此Session对象的理论上是线程安全的。
(当用户打开多个同属于一个进程的浏览器窗口（常见的弹出窗口），在这些窗口的访问属于同一个Session，会出现多次请求，需要多个工作线程来处理请求,这时就有可能的出现线程安全问题)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;servlet 尽量用方法内变量,就一定线程安全么? 局部变量的数据也来自request对象或session对象啊,它们线程安全么?&lt;/strong&gt;
servletRequest 线程是安全的
因为:每个 request 都会创建一个新线程,每个新线程,容器又都会创建一对servletRequest和servletResponse对象(这是servlet基本原理)
所以servletRequest对象和servletResponse对象只在一个线程内被创建,存在,被访问&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常见的线程安全的解决办法:&lt;/strong&gt;
1.使用方法内局部变量&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是因为各线程有自己堆栈空间,存储局部变量&lt;/li&gt;
  &lt;li&gt;方法参数传入,多采用传值（volue copy)传入方法内&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.对&lt;strong&gt;操作共享资源&lt;/strong&gt;的语句,方法,对象, 使用同步
比如&lt;strong&gt;写入磁盘文件&lt;/strong&gt;,采用同步锁，但建议尽量用同步代码块，不要用同步方法&lt;/p&gt;

&lt;p&gt;3.使用同步的集合类
使用Vector代替ArrayList
使用Hashtable代替HashMap。&lt;/p&gt;

&lt;p&gt;4.不要在 Servlet中再创建自己的线程来完成某个功能。
Servlet本身就是多线程的，在Servlet中再创建线程，将导致执行情况复杂化&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="多线程" /><summary type="html">JSP/Servlet的多线程原理: 1.servelet就是一个CGI,但比传统的CGI要快得过 传统CGI是多进程的,servlet是多线程的 以多线程方式执行可大大降低对系统的资源需求,提高 系统的并发量及响应时间. JSP/Servlet容器默认是采用单实例多线程(这是造成线程安全的主因)方式处理多个请求的： 当客户端第一次请求某一个JSP文件时(有的servlet是随容器启动就startup)： 服务端把该JSP编译成一个CLASS文件 并创建一个该类的实例 然后创建一个线程处理CLIENT端的请求。 多请求，多线程： 如果有多个客户端同时请求该JSP文件，则服务端会创建多个线程。每个客户端请求对应一个线程。 servlet 的线程安全 servlet里的 实例变量 servlet里的实例变量，是被所有线程共享的,所以不是线程安全的. servlet方法里的局部变量 因为每个线程都有它自己的堆栈空间,方法内局部变量存储在这个线程堆栈空间内, 且参数传入方法是按传值volue copy的方式 所以是线程安全的 Application对象 在container运行期间,被整个系统内所有用户共同使用,所以不是线程安全 的 ServletContext对象 ServletContext是可以多线程同时读/写属性的,线程是不安全的。 struts2 的ServletContext采用的是TreadLocal模式,是线程安全的 HttpServletRequest对象和HttpServletResponse对象 每一个请求，由一个工作线程来执行，都会创建有一对新的ServletRequest对象和ServletResponse,然后传入service()方法内 所以每个ServletRequest对象对应每个线程，而不是多线程共享，是线程安全的。所以不用担心request参数和属性的线程安全性 HttpSession Session对象在用户session期间存在，只能在属于同一个SessionID的请求的线程中被访问，因此Session对象的理论上是线程安全的。 (当用户打开多个同属于一个进程的浏览器窗口（常见的弹出窗口），在这些窗口的访问属于同一个Session，会出现多次请求，需要多个工作线程来处理请求,这时就有可能的出现线程安全问题) servlet 尽量用方法内变量,就一定线程安全么? 局部变量的数据也来自request对象或session对象啊,它们线程安全么? servletRequest 线程是安全的 因为:每个 request 都会创建一个新线程,每个新线程,容器又都会创建一对servletRequest和servletResponse对象(这是servlet基本原理) 所以servletRequest对象和servletResponse对象只在一个线程内被创建,存在,被访问 常见的线程安全的解决办法: 1.使用方法内局部变量 是因为各线程有自己堆栈空间,存储局部变量 方法参数传入,多采用传值（volue copy)传入方法内 2.对操作共享资源的语句,方法,对象, 使用同步 比如写入磁盘文件,采用同步锁，但建议尽量用同步代码块，不要用同步方法 3.使用同步的集合类 使用Vector代替ArrayList 使用Hashtable代替HashMap。 4.不要在 Servlet中再创建自己的线程来完成某个功能。 Servlet本身就是多线程的，在Servlet中再创建线程，将导致执行情况复杂化</summary></entry></feed>