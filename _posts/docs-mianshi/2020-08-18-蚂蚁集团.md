---
title: 蚂蚁集团面试题
permalink: /mianshi/0818/01
tags: 面试题
key: mianshi-2020-08-18-01
---

## 1 Dubbo

 1.1 服务调用超时问题怎么解决？
 1.2 Dubbo支持哪些序列化方式？
 1.3 Dubbo和SpringCloud的关系？
 1.4 Dubbo的架构设计？一共划分了哪些层？
 1.5 Dubbo的默认集群容错方案？
 1.6 Dubbo使用的是什么通信框架?
 1.7 Dubbo的主要应用场景？
 1.8 Dubbo服务注册与发现的流程？流程说明。
 1.9 Dubbo的集群容错方案有哪些？
 1.10 Dubbo的四大组件
 1.11 Dubbo在安全机制方面是如何解决的
 1.12 Dubbo和SpringCloud的区别？
 1.13 Dubbo支持哪些协议，每种协议的应用场景，优缺点？
 1.14 Dubbo的核心功能有哪些？
 1.15 Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？
 1.16 Dubbo集群的负载均衡有哪些策略
 1.17 为什么需要服务治理？
 1.18 Dubbo超时时间怎样设置？

## 2 ElasticSearch

 2.1 你们公司的ES集群，一个node一般会分配几个分片？
 2.2 Elasticsearch是如何实现Master选举的？
 2.3 你是如何做写入调优的？
 2.4 如何避免脑裂？
 2.5 Elasticsearch对于大数据量（上亿量级）的聚合如何实现？
 2.6 ES主分片数量可以在后期更改吗？为什么？
 2.7 如何监控集群状态？
 2.8 ElasticSearch中的副本是什么？
 2.9 ES更新数据的执行流程？
 2.10 shard里面是什么组成的？
 2.11 ElasticSearch中的分析器是什么？
 2.12 什么是脑裂？
 2.13 客户端在和集群连接时，如何选择特定的节点执行请求的？
 2.14 Elasticsearch中的倒排索引是什么？
 2.15 什么是索引？索引（名词） 一个索引(index)
 2.16 详细描述一下Elasticsearch更新和删除文档的过程
## 3 JVM

 #### 3.1 JVM参数主要有⼏种分类

IBM 微软的 hotpot

 ####  3.2 Java中会存在内存泄漏吗，简述一下。

会出现内存泄漏，当垃圾回收器清理内存后，现有内存使用量+申请新增内存>最大使用内存时，会出现内存泄漏

主要场景包括以下两种

1. 机器内存不够用
2. 内存分配不合理



####  3.3 Java虚拟机是如何判定两个Java类是相同的？

在新建对象的过程中，需要新通过类加载，而在类加载中通过 __双亲委派机制__ 来判断两个类是否相同

当某个加载器需要加载某个.class 文件时，他首先把这个任务委托过他的上一级加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

下面是类加载的过程

__用于自定义类加载器 --> 系统类加载器 --> 扩展类加载 --> 启动类加载__

 

 #### 3.4 Java 中都有哪些引用类型

1. __强引用（strongreference）__就是指在程序代码之中普遍存在的,类似“Object obj=new Object()” 这类的引用,只要强引用还存在,垃圾收集器永远不会回收掉被引用的对象实例。
2. __软引用（softreference）__是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象, 在系统将要发生内存溢出异常之前,将会把这些对象实例列进回收范围之中进行 第二次回收。如果这次回收还没有足够的内存,才会抛出内存溢出异常。在 JDK 1.2 之后,提供了 SoftReference 类来实现软引用。
3. __弱引用（weakreference）__也是用来描述非必需对象的,但是它的强度比软引用更弱一些,被弱 引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时, 无论当前内存是否足够,都会回收掉只被弱引用关联的对象实例。在 JDK 1.2 之 后,提供了 WeakReference 类来实现弱引用。
4. __虚引用（phantomreference）__也称为幽灵引用或者幻影引用,它是最弱的一种引用关系。一个对象 实例是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用 来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象 实例被收集器回收时收到一个系统通知。在 JDK 1.2 之后,提供了 PhantomReference 类来实现虚引用

 #### 3.5 在 Java 中，对象什么时候可以被垃圾回收？

当对象被判定已经“死去”时，对象可以被垃圾回收，判断对象是否存活可通过以下算法

1. __引用计数算法：__通过引用计数器，当被引用+1，当失去引用-1，计数为零的引用被清理
2. __可达性分析算法：__ 通过跟对象作为起始点，从这个节点开始向下搜索，搜索过程所走的路径称为“引用链”，如果某个对象的到 __GC Roots __间没有连接，则说明该对象不能再被引用

#### 3.6 StackOverflow异常有没有遇到过？一般你猜测会在什么情况下被触发？

栈内存溢出。栈内存保存的信息包括：函数地址、函数参数、局部变量等

出现__栈内存溢出的常见原因有2个__：

1. 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈
2. 局部静态变量体积太大

__解决办法大致说来也有两种__：

1. 增加栈内存的数目
2. 使用堆内存增加栈内存方法

#### 3.7 堆空间分哪些部分？以及如何设置各个部分？

新生代，老年代，永久代

8:1:1 的比例进行分割



#### 3.8 什么是栈帧？栈帧存储了什么？

栈帧保存了 对象索引，局部变量，方法

 3.9 如何设置参数生成GC日志？
 3.10 GC 是什么？为什么要有 GC？
 3.12 使用过哪些jdk命令，并说明各个的作用是什么
 3.13 JVM运行时数据区区域分为哪⼏部分？
 3.14 是否了解类加载器双亲委派模型机制和破坏双亲委派模型？
 3.15 逃逸分析有几种类型？
 3.16 -Xms这些参数的含义是什么？
 3.17 你知道哪几种垃圾收集器,各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。
 3.18 JVM的内存结构，Eden和Survivor比例是多少？

## 4 多线程/高并发

 4.1 负载平衡的意义什么？
 4.2 请说出同步线程及线程调度相关的方法？
 4.3 关于epoll和select的区别，哪些说法 是正确的？（多选）
A. epoll 和 select 都是 I/O 多路复用的技术，都可以实现同时监听 多个I/O事件的状态。
B. epoll 相比 select 效率更高，主要是基于其操作系统支持的 I/O 事件通知机制，而select是基于轮询机制。
C. epoll支持水平触发和边沿触发两种模式。
D. select能并行支持I/O比较小，且无法修改。
 4.4 启动一个线程是调用run()方法还是start()方法？
 4.5 如何确保N个线程可以访问N个资源同时又不导致死锁？
 4.6 编写多线程程序的几种实现方式（换个问法：创建多线程的方式）？
 4.7 线程和进程的区别？
 4.8 什么是线程池，有哪些常用线程池？
 4.9 什么是死锁？
 4.10 怎么保证缓存和数据库数据的一致性？
## 5 消息中间件

 5.1 消费者获取消息有几种模式？
 5.2 RocketMQ的特点有哪些？
 5.3 kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka将如何处理？
 5.4 为何需要Kafka集群
 5.5 Kafka 数据存储设计
 5.6 Kafka如何判断一个节点是否存活？
 5.7 kafka消息发送的可靠性机制有几种
 5.8 请详细说一下推送模式和拉取模式。
 5.9 Kafka 与传统消息系统之间有三个关键区别
 5.10 RocketMQ 由哪些角色组成？
 5.12 Kafka的消费者如何消费数据
 5.13 Kafka的优点
 5.14 Kafka 的设计是什么样的呢？
 5.15 说说你对Consumer的了解？
 5.16 Kafka新建的分区会在哪个目录下创建
 5.17 说一下Kafka消费者消费过程
 5.18 介绍下Kafka
 5.19 什么情况会导致Kafka运行变慢？
