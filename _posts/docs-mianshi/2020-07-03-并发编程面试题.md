---
title: 并发面试题
permalink: /mianshi/juc/01
tags: 面试题
key: mianshi-2020-07-03-05
---



#### 1、在 java 中守护线程和本地线程区别？

- 守护线程：任何线程可通过Thread.setDaemon(bool on) 设置为守护线程 ，GC是守护线程
- 本地线程：也是普通线程，

#### 2、线程与进程的区别？

- 一个程序至少有一个进程，一个进程至少有一个线程
- 线程的划分尺度小于进程，使得多线程程序的并发性高
- 进程在执行的过程中有独立的内存单元，而多线程共享内存，从而极大的提高了程序的效率
- 线程依托于应用程序，由应用程序提高多线程的执行控制
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。**这就是进程和线程的重要区别。**

- 现在有自己的堆栈和局部变量，进程之间有单独的地址空间
- 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。

#### 3、什么是多线程中的上下文切换？

多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：__当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。__

上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，__上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作__



#### 4、死锁与活锁的区别，死锁与饥饿的区别？

__1.死锁__：通俗地说，死锁是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间都相互等待对方释放资源，产生了无限制等待的现象，死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重的影响

__产生死锁的必要条件__：

1. 互斥条件：所谓互斥就是进程在某一时间内独占资源。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

__降低死锁的方法：__

1. 尽可能减小锁的作用范围，比如使用同步代码块而不使用同步方法
2. 尽量不编写在通时刻获取多个锁的代码，因为在一个线程持有多个资源的时候很容易发生死锁
3. 根据情况将过大范围的锁进行切分，让每个锁的作用范围减小，从而降低死锁发生的概率。这以原则的典型应用是ConcurrentHashMap的锁分段技术，具体可以参看这篇文章。



__2.饥饿：__  指的线程无法访问到它需要的资源而不能继续执行时，引发饥饿最常见资源就是CPU时钟周期。虽然在Thread API中由指定线程优先级的机制，但是只能作为操作系统进行线程调度的一个参考，换句话说就是操作系统在进行线程调度是平台无关的，会尽可能提供公平的、活跃性良好的调度，那么即使在程序中指定了线程的优先级，也有可能在操作系统进行调度的时候映射到了同一个优先级。

__产生饥饿的可能情况：__

1. 引发饥饿最常见资源就是CPU时钟周期
2. 不要区修改线程的优先级，一旦修改程序的行为就会与平台相关，并且会导致饥饿问题的产生
3. 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。
4. 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。

__解决饥饿的方法：__

1. 在程序中使用的Thread.yield或者Thread.sleep表明该程序试图客服优先级调整问题，让优先级更低的线程拥有被CPU调度的机会。

__3.活锁__  指的是线程不断重复执行相同的操作，但每次操作的结果都是失败的。尽管这个问题不会阻塞线程，但是程序也无法继续执行。__活锁通常发生在处理事务消息的应用程序中__，如果不能成功处理这个事务那么事务将回滚整个操作。解决活锁的办法是在每次重复执行的时候引入随机机制，这样由于出现的可能性不同使得程序可以继续执行其他的任务。


#### 5、Java 中用到的线程调度算法是什么？

__抢占式__。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

操作系统中可能会出现某条线程常常获取到VPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。

#### 6、什么是线程组，为什么在 Java 中不推荐使用？

- 1.线程组ThreadGroup对象中比较有用的方法是stop、resume、suspend等方法，由于这几个方法会导致线程的安全问题（主要是死锁问题），已经被官方废弃掉了，所以线程组本身的应用价值就大打折扣了。
- 2.线程组ThreadGroup不是线程安全的，这在使用过程中获取的信息并不全是及时有效的，这就降低了它的统计使用价值。

虽然线程组现在已经不被推荐使用了，但是它在线程的异常处理方面还是做出了一定的贡献。当线程运行过程中出现异常情况时，在某些情况下JVM会把线程的控制权交到线程关联的线程组对象上来进行处理。所以对线程组的了解还是有一定必要的。

#### 7、为什么使用 Executor 框架？(其实问的是线程池)

- 每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。
- 调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。
- 接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。


#### 8、在 Java 中 Executor 和 Executors 的区别？

- Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。
- Executor 接口对象能执行我们的线程任务。
- ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。
- 使用ThreadPoolExecutor 可以创建自定义线程池。
- Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。__Future 可异步执行任务，但是Future.get() 方法是阻塞的__

#### 9、如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长？

（1）获取项目的pid，jps或者ps -ef  \| grep java		

（2）top -H -p pid，顺序不能改变

#### 10、什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？

原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。 	
处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。
在Java中可以通过锁和循环CAS的方式来实现原子操作。 CAS操作——Compare & Set，或是 Compare & Swap，现在几乎所有的CPU指令都支持CAS的原子操作。

原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。
int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。
为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。

java.util.concurrent这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。

原子类：
AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference
原子数组：
AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray
原子属性更新器：
AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater
解决ABA问题的原子类：
AtomicMarkableReference（通过引入一个boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个int来累加来反映中间有没有变过）

#### 11、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？

Lock 与 synchronized __相同的功能是都能对多线程对静态资源的修改做同步(互斥)控制__：但Lock有优势的地方在于：

1. __操作方面(锁控制)：__ Lock 是可以手动控制加锁与释放锁操作的。而synchronized自动释放锁。
2. __性能方面：__ 使用到 Lock 接口 的实现类 ReadWriteLock 子类 ReentrantReadWriteLock 的 对象rwl,在多线程同时对静态资源进行修改时，可以使用 rwl.readLock().lock() 或者 rwl.writeLock().lock() 对静态资源做并发修改控制。读写锁可以实现读写互斥，但是读读不互斥，这个是synchroized实现不了的，synchroized对读读也互斥。
3. __线程通信方面：__ Lock对应的实现类对象lock 通过 lock.newCondition() 可以实例化Condition对象condition，condition 通过 condition.await() 实现synchronized + t.wait() 的效果,t代表线程，通过condition.signal()或者 condition.signalAll()实现线程唤醒，且lock 可以为读写线程创建两种不同操作(read or write)类型的Condition对象，使得线程间通信要比传统的wait(),notifiy()进行线程通信的效率要高很多。使得加锁，释放锁的操作更具选择性，精准性。

#### 12、什么是 Executors 框架？

Executors框架其内部采用了线程池机制，他在java.util.cocurrent包下，通过该框架来控制线程的启动、执行、关闭，可以简化并发编程的操作。因此，通过Executors来启动线程比使用Thread的start方法更好，而且更容易管理，效率更好，还有关键的一点：有助于避免this溢出。

Executors框架包括：线程池、Executor，Executors，ExecutorService、CompletionServince，Future、Callable。



#### 13、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？

阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。

这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。

阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

JDK7提供了7个阻塞队列。分别是：
- ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。 	
- LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 	
- PriorityBlockingQueue ：一个支持优先级排序的***阻塞队列。 	
- DelayQueue：一个使用优先级队列实现的***阻塞队列。 	
- SynchronousQueue：一个不存储元素的阻塞队列。 	
- LinkedTransferQueue：一个由链表结构组成的***阻塞队列。 	
- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

Java 5之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized这些关键字。而在java 5之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。
BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。

阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。



#### 14、什么是 Callable 和 Future?

Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。
可以认为是带有回调的Runnable。

Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。



#### 15、什么是 FutureTask?使用 ExecutorService 启动任务。

在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行



#### 16、什么是并发容器的实现？

__何为同步容器：__ 可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。
可以通过查看Vector，Hashtable等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字synchronized。

__并发容器__ 使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。

#### 17、多线程同步和互斥有几种实现方法，都是什么？

##### 同步和互斥

当有多个线程的时候，经常需要去同步这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。

所谓同步，是指在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。

所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

##### 多线程同步和互斥有几种实现方法

线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。

用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。

内核模式下的方法有：事件，信号量，互斥量。

1. 临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
2. 互斥量:为协调共同对一个共享资源的单独访问而设计的。
3. 信号量:为控制一个具有有限数量用户资源而设计。
4. 事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

#### 18、什么是竞争条件？你怎样发现和解决竞争？

- 当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。

#### 19、你将如何使用 thread dump？你将如何分析 Thread dump？165

**新建状态（New）** 

用 new 语句创建的线程处于新建状态，此时它和其他 Java 对象一样，仅仅在堆区

中被分配了内存。

**就绪状态（Runnable）** 

当一个线程对象创建后，其他线程调用它的 start()方法，该线程就进入就绪状态，

Java 虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运

行池中，等待获得 CPU 的使用权。

**运行状态（Running）** 

处于这个状态的线程占用 CPU，执行程序代码。只有处于就绪状态的线程才有机

会转到运行状态。

**阻塞状态（Blocked）** 

阻塞状态是指线程因为某些原因放弃 CPU，暂时停止运行。当线程处于阻塞状态

时，Java 虚拟机不会给线程分配 CPU。直到线程重新进入就绪状态，它才有机会

转到运行状态。

**阻塞状态可分为以下 3 种：** 

**位于对象等待池中的阻塞状态（Blocked in object’s wait pool）**：

当线程处于运行状态时，如果执行了某个对象的 wait()方法，Java 虚拟机就会把

线程放到这个对象的等待池中，这涉及到“线程通信”的内容。

**位于对象锁池中的阻塞状态（Blocked in object’s lock pool）**：

当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已

经被其他线程占用，Java 虚拟机就会把这个线程放到这个对象的锁池中，这涉及

到“线程同步”的内容。

**其他阻塞状态（Otherwise Blocked）**：

当前线程执行了 sleep()方法，或者调用了其他线程的 join()方法，或者发出了 I/O

请求时，就会进入这个状态。

死亡状态（Dead）

当线程退出 run()方法时，就进入死亡状态，该线程结束生命周期。



#### 20、为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？

- start() 方法会新建一个线程，并启动，启动方法使用的是run方法
- run方法会启动当前线程

#### 21、进程和线程的优缺点

- 线程执行开销小，但不利于资源的管理和保护，而进程相反

#### 22、java Future 接口介绍

- Future是JAVA并发框架Executor中的一个类，Executor就是Runnable和Callable的调度容器，Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作，用get()可以获得执行结果；

- 如果在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态

#### 23、Java中你怎样唤醒一个阻塞的线程

在Java发展史上曾经使用suspend()、resume()方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。 
解决方案可以使用以对象为目标的阻塞，即__利用Object类的wait()和notify()方法实现线程阻塞__。 
首先，wait、notify方法是针对对象的，调用任意对象的wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；其次，wait、notify方法必须在synchronized块或方法中被调用，并且要保证同步块或方法的锁对象与调用wait、notify方法的对象是同一个，如此一来在调用wait之前当前线程就已经成功获取某对象的锁，执行wait阻塞后当前线程就将之前获取的对象锁释放。

#### 24、Java中用到的线程调度算法是什么

计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权.

有两种调度模型：分时调度模型和抢占式调度模型。 
__分时调度模型__是指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片这个也比较好理解。

__java虚拟机采用抢占式调度模型__，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。

#### 25、Java中有几种方法可以实现一个线程

继承 Thread 类
实现 Runnable 接口
实现 Callable 接口，需要实现的是 call() 方法

#### 26、如何停止一个正在运行的线程

使用共享变量的方式 
在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。

使用interrupt方法终止线程 
如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。__这里我们给出的建议是，不要使用stop()方法，而是使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。__



#### 27、notify()和notifyAll()有什么区别

当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。

如果没把握，建议notifyAll，防止notigy因为信号丢失而造成程序异常。

#### 28、什么是Daemon线程，它有什么意义

所谓后台(daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说， 
只要有任何非后台线程还在运行，程序就不会终止。必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。注意：后台进程在不执行finally子句的情况下就会终止其run()方法。

比如：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。

#### 29、Java如何实现多线程之间的通讯和协作

中断 和 共享变量





[Java中守护线程和本地线程区别，这特么太重要了！](https://blog.51cto.com/14820287/2507947)