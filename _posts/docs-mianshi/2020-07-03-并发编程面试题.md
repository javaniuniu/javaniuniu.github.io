---
title: 并发面试题
permalink: /mianshi/juc/01
tags: 面试题
key: mianshi-2020-07-03-05
---



#### 1、在 java 中守护线程和本地线程区别？

- 守护线程：任何线程可通过Thread.setDaemon(bool on) 设置为守护线程 ，GC是守护线程
- 本地线程：也是普通线程，

#### 2、线程与进程的区别？

- 一个程序至少有一个进程，一个进程至少有一个线程
- 线程的划分尺度小于进程，使得多线程程序的并发性高
- 进程在执行的过程中有独立的内存单元，而多线程共享内存，从而极大的提高了程序的效率
- 线程依托于应用程序，由应用程序提高多线程的执行控制
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。**这就是进程和线程的重要区别。**

- 现在有自己的堆栈和局部变量，进程之间有单独的地址空间
- 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。

#### 3、什么是多线程中的上下文切换？

多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：__当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。__

上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，__上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作__



#### 4、死锁与活锁的区别，死锁与饥饿的区别？

__1.死锁__：通俗地说，死锁是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间都相互等待对方释放资源，产生了无限制等待的现象，死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重的影响

__产生死锁的必要条件__： 

1. 互斥条件：所谓互斥就是进程在某一时间内独占资源。 
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
3. 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

__降低死锁的方法：__

1. 尽可能减小锁的作用范围，比如使用同步代码块而不使用同步方法
2. 尽量不编写在通时刻获取多个锁的代码，因为在一个线程持有多个资源的时候很容易发生死锁
3. 根据情况将过大范围的锁进行切分，让每个锁的作用范围减小，从而降低死锁发生的概率。这以原则的典型应用是ConcurrentHashMap的锁分段技术，具体可以参看这篇文章。



__2.饥饿：__  指的线程无法访问到它需要的资源而不能继续执行时，引发饥饿最常见资源就是CPU时钟周期。虽然在Thread API中由指定线程优先级的机制，但是只能作为操作系统进行线程调度的一个参考，换句话说就是操作系统在进行线程调度是平台无关的，会尽可能提供公平的、活跃性良好的调度，那么即使在程序中指定了线程的优先级，也有可能在操作系统进行调度的时候映射到了同一个优先级。

__产生饥饿的可能情况：__

1. 引发饥饿最常见资源就是CPU时钟周期
2. 不要区修改线程的优先级，一旦修改程序的行为就会与平台相关，并且会导致饥饿问题的产生
3. 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。 
4. 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。

__解决饥饿的方法：__

1. 在程序中使用的Thread.yield或者Thread.sleep表明该程序试图客服优先级调整问题，让优先级更低的线程拥有被CPU调度的机会。

__3.活锁__  指的是线程不断重复执行相同的操作，但每次操作的结果都是失败的。尽管这个问题不会阻塞线程，但是程序也无法继续执行。__活锁通常发生在处理事务消息的应用程序中__，如果不能成功处理这个事务那么事务将回滚整个操作。解决活锁的办法是在每次重复执行的时候引入随机机制，这样由于出现的可能性不同使得程序可以继续执行其他的任务。


#### 5、Java 中用到的线程调度算法是什么？

__抢占式__。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

操作系统中可能会出现某条线程常常获取到VPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。

#### 6、什么是线程组，为什么在 Java 中不推荐使用？

- 1.线程组ThreadGroup对象中比较有用的方法是stop、resume、suspend等方法，由于这几个方法会导致线程的安全问题（主要是死锁问题），已经被官方废弃掉了，所以线程组本身的应用价值就大打折扣了。
- 2.线程组ThreadGroup不是线程安全的，这在使用过程中获取的信息并不全是及时有效的，这就降低了它的统计使用价值。

虽然线程组现在已经不被推荐使用了，但是它在线程的异常处理方面还是做出了一定的贡献。当线程运行过程中出现异常情况时，在某些情况下JVM会把线程的控制权交到线程关联的线程组对象上来进行处理。所以对线程组的了解还是有一定必要的。

#### 7、为什么使用 Executor 框架？(其实问的是线程池)

- 每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。
- 调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。
- 接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。
  

#### 8、在 Java 中 Executor 和 Executors 的区别？

- Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 
- Executor 接口对象能执行我们的线程任务。 
- ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 
- 使用ThreadPoolExecutor 可以创建自定义线程池。 
- Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。__Future 可异步执行任务，但是Future.get() 方法是阻塞的__

9、如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长？

（1）获取项目的pid，jps或者ps -ef  \| grep java		

（2）top -H -p pid，顺序不能改变

10、什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？

原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。 	
处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。 
在Java中可以通过锁和循环CAS的方式来实现原子操作。 CAS操作——Compare & Set，或是 Compare & Swap，现在几乎所有的CPU指令都支持CAS的原子操作。	

原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。 
int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。 
为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。

java.util.concurrent这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。

原子类：
AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference 
原子数组：
AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray 
原子属性更新器：
AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater 
解决ABA问题的原子类：
AtomicMarkableReference（通过引入一个boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个int来累加来反映中间有没有变过）

11、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？

- ReccentLock 
- 优势
  - 执行效率
  - 可以获取锁状态
  - 可以指定锁的位置
  - 

12、什么是 Executors 框架？

13、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？

- BlockQueue 继承于Queue 遵循FIFO原则，在队列空的时候，做remove操作，需等待资源插入队列，承阻塞状态；同样在队列满了后，再需要插入，承阻塞状态

14、什么是 Callable 和 Future?

- Future 的 FutureTask 可用于包装 Callable

15、什么是 FutureTask?使用 ExecutorService 启动任务。

- 

16、什么是并发容器的实现？

- 并发

17、多线程同步和互斥有几种实现方法，都是什么？
18、什么是竞争条件？你怎样发现和解决竞争？

- 在多线程下，

19、你将如何使用 thread dump？你将如何分析 Thread dump？165

- 可通过工具查看线程执行情况，需要在jvm中配置

20、为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？

- start() 方法会新建一个线程，并启动，启动方法使用的是run方法
- run方法会启动当前线程

21、进程和线程的优缺点

- 线程执行开销小，但不利于资源的管理和保护，而进程相反

22、java Future 接口介绍

- Future是JAVA并发框架Executor中的一个类，Executor就是Runnable和Callable的调度容器，Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作，用get()可以获得执行结果；

- 如果在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态