---
title: 大厂面试题
permalink: /mianshi/0707/01
tags: 面试题
key: mianshi-2020-07-07-10
---

### **一面 （电话面试）**

1. #### 介绍自己比较熟悉的项目和项目中遇到的难点

2. #### Springbean生命周期

   __bean创建：__ new一个对象到容器-->属性注入-->是否实现了Aware类-->后置处理器，执行初始化前的方法-->初始化-->后置处理器，执行初始化完成后的方法-->完成bean创建

   __销毁：__ 执行@PostDestroy 注解的方法-->bean实现了DisposableBean，执行destroy方法-->执行配置文件中的destroy-method

3. #### 谈谈依赖注入和面向切面

   __依赖注入：__ 通过发射的方式，把创建bean的权限交由spring来统一管理，可以避免硬编码造成的代码耦合

   __面向切面：__ aop是面向切面编程的思想，spring通过代理的方式，将面向切面编程定义成一个规范，通过代理模式，将两个或多个有关联的业务，在代码层面实现节藕

4. #### HashMap原理和扩容机制

   hashmap的内部实现是数组和链表的结合，新建hashmap的时候会默认初始化数组长度为16，精准度为0.75；执行插入操作时，通过通过给key做hash处理，将得到的值和16求膜，将value插入与之对应的小标；当出现相同的下标，value将通过链表的形式链接起来，并且是将value插入到最顶端；

5. #### 常用并发包下的类

   __接口：__ Callback，Future ，FutureService ，Executor，BlockingQueue

   __类：__ ConcurrentHashMap，ConcurrentListMap，ConcurrentListSet，CopyOnWriteArrayList， CopyOnWriteArraySet，ArrayBlockingQueue，FutureTask，ListedBlockingQueue，Executors，ThreadPoolExecutor

6. #### Redis持久化方式，为什么这么快？

   __自己总结：__

   1. 内存数据库，一减少对磁盘读取的IO
   2. 非阻塞IO，IO多路复用
   3. 单线程模型，减少线程上下文切换和竞争

   __参考其他的总结：__

    一、 __Redis是纯内存数据库__，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。

      二、 再说一下IO，Redis使用的是__非阻塞IO，IO多路复用__，使用了__单线程来轮询描述符__，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切 换和竞争。

   三、 Redis采用了__单线程的模型__，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。

      四、另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储   ，再如，跳表，使用有序的数据结构加快读取的速度。

      五、还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。

7. #### **自己平时如何提升的，看书或者网站？**

### **二面**

1. #### Jvm类加载机制，分别每一步做了什么工作？

   加载-->校验-->解析-->准备-->解析-->初始化-->使用-->卸载

   __加载：__ 将Class类加载到内存，接着在JVM的方法区创建一个对应的Class对象

   __校验：__ JVM代码规范娇艳，代码逻辑校验

   __准备：__ 分配内存并初始化，这里需要注意两个关键点，内存分配的对象以及初始化的类型。初始化的是static 修饰的类变量

   __解析：__  JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析

   __初始化：__ JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化

   __使用：__  JVM 开始从入口方法开始执行用户的程序代码

   __卸载：__  JVM 开始销毁创建的 Class 对象

2. #### Jvm内存模型，垃圾回收机制，如何确定被清除的对象？

   __共享内存区：__ 堆，方法区	

   __私有内存区：__ 栈，计数器，本地方法区	

   __堆：__ 存放对象和数组，也是GC处理的区域	

   __方法区：__ 用于存放常量，静态变量，Class	

   __栈：__ 保存栈帧，__栈帧中包括：局部变量表(方法参数，也可以是方法的局部变量)、操作数栈、动态链接、方法出口__ 	

   __计数器：__ 当线程数大于CPU核数，线程之间就要根据时间片轮询抢夺CPU时间资源，计数器会记录线程的状态及上下文	

   __本地方法区：__ 调用扩展方法，通常是通过 JNI 调用 C或C++	

   __垃圾回收机制:__ 引用计数算法 可达性分析算法 分代收集算法

   __触发轻GC的条件：__  

   当新对象生成，并且在Eden申请空间失败时，就会触发，通常就是 Eden 空间满的时候触发

   __触发重GC的条件：__ 

   a) 年老代（Tenured）被写满；	

   b) 持久代（Perm）被写满；	

   c) System.gc()被显示调用；	

   d) 上一次GC之后Heap的各域分配策略动态变化；	

3. #### 了解哪些垃圾回收器和区别？

4. #### 多线程相关，线程池的参数列表和拒绝策略

5. #### Jvm如何分析出哪个对象上锁？

6. #### Mysql索引类型和区别，事务的隔离级别和事务原理

7. #### Spring scope 和设计模式

8. #### Sql优化

### **三面**

1. #### fullgc的时候会导致接口的响应速度特别慢，该如何排查和解决？

2. #### 项目内存或者CPU占用率过高如何排查？

3. #### ConcurrentHashmap原理

4. #### 数据库分库分表

5. #### MQ相关，为什么kafka这么快，什么是零拷贝？

6. #### 小算法题

7. #### http和https协议区别，具体原理

### **四面（Leader）**

1. #### 手画自己项目的架构图，并且针对架构和中间件提问

2. #### **印象最深的一本技术书籍是什么？**
