I"<h4 id="redis中opsforvalue方法的使用介绍">Redis中opsForValue()方法的使用介绍：</h4>

<h5 id="1setk-key-v-value">1、set(K key, V value)</h5>
<p>新增一个字符串类型的值，key是键，value是值。</p>

<p>redisTemplate.opsForValue().set(“stringValue”,”bbb”);</p>
<h5 id="2getobject-key">2、get(Object key)</h5>
<p>获取key键对应的值。</p>

<p>String stringValue = redisTemplate.opsForValue().get(“key”)</p>
<h5 id="3appendk-key-string-value">3、append(K key, String value)</h5>
<p>在原有的值基础上新增字符串到末尾。</p>

<p>redisTemplate.opsForValue().append(“key”, “appendValue”);
String stringValueAppend = redisTemplate.opsForValue().get(“key”);
System.out.println(“通过append(K key, String value)方法修改后的字符串:”+stringValueAppend);</p>
<h5 id="4getk-key-long-start-long-end">4、get(K key, long start, long end)</h5>
<p>截取key键对应值得字符串，从开始下标位置开始到结束下标的位置(包含结束下标)的字符串。</p>

<p>String cutString = redisTemplate.opsForValue().get(“key”, 0, 3);<br />
System.out.println(“通过get(K key, long start, long end)方法获取截取的字符串:”+cutString);</p>
<h5 id="5getandsetk-key-v-value">5、getAndSet(K key, V value)</h5>
<p>获取原来key键对应的值并重新赋新值。</p>

<p>String oldAndNewStringValue = redisTemplate.opsForValue().getAndSet(“key”, “ccc”);<br />
System.out.print(“通过getAndSet(K key, V value)方法获取原来的值：” + oldAndNewStringValue );<br />
String newStringValue = redisTemplate.opsForValue().get(“key”);<br />
System.out.println(“修改过后的值:”+newStringValue);</p>
<h5 id="6setbitk-key-long-offset-boolean-value">6、setBit(K key, long offset, boolean value)</h5>
<p>key键对应的值value对应的ascii码,在offset的位置(从左向右数)变为value。</p>

<p>redisTemplate.opsForValue().setBit(“key”,1,false);<br />
newStringValue = redisTemplate.opsForValue().get(“key”)+””;<br />
System.out.println(“通过setBit(K key,long offset,boolean value)方法修改过后的值:”+newStringValue);</p>
<h5 id="7getbitk-key-long-offset">7、getBit(K key, long offset)</h5>
<p>判断指定的位置ASCII码的bit位是否为1。</p>

<p>boolean bitBoolean = redisTemplate.opsForValue().getBit(“key”,1);<br />
System.out.println(“通过getBit(K key,long offset)方法判断指定bit位的值是:” + bitBoolean);</p>
<h5 id="8sizek-key">8、size(K key)</h5>
<p>获取指定字符串的长度</p>

<p>Long stringValueLength = redisTemplate.opsForValue().size(“key”);<br />
System.out.println(“通过size(K key)方法获取字符串的长度:”+stringValueLength);</p>
<h5 id="9incrementk-key-double-delta">9、increment(K key, double delta)</h5>
<p>以增量的方式将double值存储在变量中。</p>

<p>double stringValueDouble = redisTemplate.opsForValue().increment(“doubleKey”,5); <br />
System.out.println(“通过increment(K key, double delta)方法以增量方式存储double值:” + stringValueDouble);</p>
<h5 id="10incrementk-key-long-delta">10、increment(K key, long delta)</h5>
<p>以增量的方式将long值存储在变量中。</p>

<p>double stringValueLong = redisTemplate.opsForValue().increment(“longKey”,6); <br />
System.out.println(“通过increment(K key, long delta)方法以增量方式存储long值:” + stringValueLong);</p>
<h5 id="11setifabsentk-key-v-value">11、setIfAbsent(K key, V value)</h5>
<p>如果键不存在则新增,存在则不改变已经有的值。</p>

<p>boolean absentBoolean = redisTemplate.opsForValue().setIfAbsent(“absentKey”,”fff”);<br />
System.out.println(“通过setIfAbsent(K key, V value)方法判断变量值absentValue是否存在:” + absentBoolean);<br />
if(absentBoolean){<br />
    String absentValue = redisTemplate.opsForValue().get(“absentKey”)+””;<br />
    System.out.print(“,不存在，则新增后的值是:”+absentValue);<br />
    boolean existBoolean = redisTemplate.opsForValue().setIfAbsent(“absentKey”,”eee”);<br />
    System.out.print(“,再次调用setIfAbsent(K key, V value)判断absentValue是否存在并重新赋值:” + existBoolean);<br />
    if(!existBoolean){<br />
        absentValue = redisTemplate.opsForValue().get(“absentKey”)+””;<br />
        System.out.print(“如果存在,则重新赋值后的absentValue变量的值是:” + absentValue);</p>
<h5 id="12setk-key-v-value-long-timeout-timeunit-unit">12、set(K key, V value, long timeout, TimeUnit unit)</h5>
<p>设置变量值的过期时间。</p>

<p>redisTemplate.opsForValue().set(“timeOutKey”, “timeOut”, 5, TimeUnit.SECONDS);<br />
String timeOutValue = redisTemplate.opsForValue().get(“timeOutKey”)+””;<br />
System.out.println(“通过set(K key, V value, long timeout, TimeUnit unit)方法设置过期时间，过期之前获取的数据:”+timeOutValue);<br />
Thread.sleep(5*1000);<br />
timeOutValue = redisTemplate.opsForValue().get(“timeOutKey”)+””;<br />
System.out.print(“,等待10s过后，获取的值:”+timeOutValue);</p>
<h5 id="13setk-key-v-value-long-offset">13、set(K key, V value, long offset)</h5>
<p>覆盖从指定位置开始的值。</p>

<p>redisTemplate.opsForValue().set(“absentKey”,”dd”,1);<br />
String overrideString = redisTemplate.opsForValue().get(“absentKey”);<br />
System.out.println(“通过set(K key, V value, long offset)方法覆盖部分的值:”+overrideString);</p>
<h5 id="14multisetmap-extends-k-extends-v-map">14、multiSet(Map&lt;? extends K,? extends V&gt; map)</h5>
<p>设置map集合到redis。</p>

<p>Map valueMap = new HashMap();<br />
valueMap.put(“valueMap1”,”map1”);<br />
valueMap.put(“valueMap2”,”map2”);<br />
valueMap.put(“valueMap3”,”map3”);<br />
redisTemplate.opsForValue().multiSet(valueMap);</p>
<h5 id="15multigetcollection-keys">15、multiGet(Collection<K> keys)</K></h5>
<p>根据集合取出对应的value值。</p>

<p>//根据List集合取出对应的value值<br />
List paraList = new ArrayList();<br />
paraList.add(“valueMap1”);<br />
paraList.add(“valueMap2”);<br />
paraList.add(“valueMap3”);<br />
List<String> valueList = redisTemplate.opsForValue().multiGet(paraList);  
for (String value : valueList){  
    System.out.println("通过multiGet(Collection<K> keys)方法获取map值:" + value);  
}</K></String></p>
<h5 id="16multisetifabsentmap-extends-k-extends-v-map">16、multiSetIfAbsent(Map&lt;? extends K,? extends V&gt; map)</h5>
<p>如果对应的map集合名称不存在，则添加；如果存在则不做修改。</p>

<p>Map valueMap = new HashMap();<br />
valueMap.put(“valueMap1”,”map1”);<br />
valueMap.put(“valueMap2”,”map2”);<br />
valueMap.put(“valueMap3”,”map3”);<br />
redisTemplate.opsForValue().multiSetIfAbsent(valueMap);</p>
:ET