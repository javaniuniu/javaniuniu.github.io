I"d<p>自定义解析器需要实现 <em>HandlerMethodArgumentResolver</em> 接口， <em>HandlerMethodArgumentResolver</em> 接口包含两个接口函数：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HandlerMethodArgumentResolver</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">supportsParameter</span><span class="o">(</span><span class="nc">MethodParameter</span> <span class="n">var1</span><span class="o">);</span>

    <span class="nd">@Nullable</span>
    <span class="nc">Object</span> <span class="nf">resolveArgument</span><span class="o">(</span><span class="nc">MethodParameter</span> <span class="n">var1</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">ModelAndViewContainer</span> <span class="n">var2</span><span class="o">,</span> <span class="nc">NativeWebRequest</span> <span class="n">var3</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">WebDataBinderFactory</span> <span class="n">var4</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>自定义一个解析器CurrentUserMethodArgumentResolver</p>

<p>我们在解析器中返回一个固定的UserBeannew UserBean(1L,”admin”)，实际情况是从Session、数据库或者缓存中查。</p>

<p>import org.springframework.core.MethodParameter;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.ModelAndViewContainer;</p>

<p>/**</p>
<ul>
  <li>用于绑定@CurrentUser的方法参数解析器
 *</li>
  <li>
    <p>@author lism
 */
public class CurrentUserMethodArgumentResolver implements HandlerMethodArgumentResolver {</p>

    <p>public CurrentUserMethodArgumentResolver() {
 }</p>

    <p>@Override
 public boolean supportsParameter(MethodParameter parameter) {
     if (parameter.getParameterType().isAssignableFrom(UserBean.class) &amp;&amp; parameter.hasParameterAnnotation(CurrentUser.class)) {
         return true;
     }
     return false;
 }</p>

    <p>@Override
 public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
     CurrentUser currentUserAnnotation = parameter.getParameterAnnotation(CurrentUser.class);
     //从Session 获取用户
     Object object = webRequest.getAttribute(currentUserAnnotation.value(), NativeWebRequest.SCOPE_SESSION);
//从  accessToken获得用户信息
    if (object == null) {
         String token = webRequest.getHeader(“Authorization”);
         if (token == null) {
             token = webRequest.getParameter(“accessToken”);
         }
         //为了测试先写死用户名
         //TODO: 取真实用户
         return new UserBean(1L,”admin”);
     }
     return object;
 }
}</p>
  </li>
</ul>

<p>自定义注解@CurrentUser</p>

<p>import java.lang.annotation.*;</p>

<p>/**</p>
<ul>
  <li>
    <p>绑定当前登录的用户</p>
  </li>
  <li>
    <p>不同于@ModelAttribute</p>
    <p>*</p>
  </li>
  <li>
    <p>@author lism
 */
@Target({ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface CurrentUser {</p>

    <p>/**</p>
    <ul>
      <li>当前用户在request中的名字
  *</li>
      <li>@return
  */
 String value() default “user”;</li>
    </ul>
  </li>
</ul>

<p>}
在控制器中使用@CurrentUser</p>

<p>在控制器方法上加入@CurrentUser UserBean userBean即可自动注入userBean的值</p>

<p>@RestController
@RequestMapping(value = “/test”)
public class TestController  {</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * 根据name查询
 *
 * @param request
 * @return
 */
@RequestMapping(value = "/testCurrentUser", method = RequestMethod.POST, produces = "application/json", consumes = "application/json")
@ResponseBody
public void test(@CurrentUser UserBean userBean, @RequestBody SubjectRequest request) {
    String createdBy = userBean.getUsername();
    log.info(createdBy);
} } User实体UserBean
</code></pre></div></div>

<p>import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;</p>

<p>import java.io.Serializable;</p>

<p>@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserBean implements Serializable {
    private Long id;
    private String username;
}
总结</p>

<p>我们可以通过实现HandlerMethodArgumentResolver接口来实现对自定义的参数进行解析。
比如可以解析自定义的时间格式、自定义解析Map对象等这些spring原本不支持的对象格式。</p>

<p>作者：LI木水
链接：https://www.jianshu.com/p/40606baf49b8
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
:ET