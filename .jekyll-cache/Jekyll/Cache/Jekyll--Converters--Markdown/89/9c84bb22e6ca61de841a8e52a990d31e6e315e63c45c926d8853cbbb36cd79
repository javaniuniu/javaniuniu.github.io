I"(Q<p>偶然在力扣（LeetCode）参加了一个活动，每天一题，坚持60天   <br />
今天是2020-03-17 <strong>第一天</strong></p>

<h2 id="模版">模版</h2>

<h2 id="题目-多数元素">题目 <a href="https://leetcode-cn.com/problems/majority-element/">多数元素</a></h2>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>

<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>

<h2 id="示例">示例</h2>
<h3 id="示例-1">示例 1:</h3>

<p>输入: [3,2,3]
输出: 3</p>
<h3 id="示例-2">示例 2:</h3>

<p>输入: [2,2,1,1,1,2,2]
输出: 2</p>

<h2 id="自己的思路">自己的思路</h2>
<ul>
  <li>哈希表</li>
</ul>

<h2 id="自己的代码">自己的代码</h2>
<h3 id="python">python</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">majorityElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="s">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dic</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dic</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">di</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">di</span>
</code></pre></div></div>

<h3 id="java">java</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">majorityElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cmap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span><span class="n">nums</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cmap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
               <span class="kt">int</span> <span class="n">v</span><span class="o">=</span>  <span class="n">cmap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)+</span><span class="mi">1</span><span class="o">;</span>
               <span class="n">cmap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">v</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">cmap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="nl">entry:</span><span class="n">cmap</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">()&gt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">){</span>
                <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="用时">用时</h3>
<p>30分钟</p>

<h2 id="官方解题思路">官方解题思路</h2>
<h3 id="方法二排序">方法二：排序</h3>
<h4 id="思路">思路</h4>

<p>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 <em>n/2</em> 的元素（下标从 0 开始）一定是众数。</p>

<h4 id="算法">算法</h4>

<p>对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 nn 为奇数的情况，第二个例子是 nn 为偶数的情况。</p>

<p><img src="/assets/images/leetcode/0321/a70cb9316157ecd7eeffe7900d3ca83849079824964e8a0aaefbcffd4040f175-image.png" alt="pic1" /></p>

<p>对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，数组下面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为 <em>n/2</em>  的地方有重叠。因此，无论众数是多少，返回 <em>n/2</em> 下标对应的值都是正确的。</p>
<h4 id="官方代码">官方代码</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">majorityElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="复杂度分析">复杂度分析</h4>
<ul>
  <li>时间复杂度：O(n\log n)。将数组排序的时间复杂度为 O(n\log n)。</li>
  <li>空间复杂度：O(\log n)。如果使用语言自带的排序算法，需要使用 O(\log n) 的栈空间。如果自己编写堆排序，则只需要使用 O(1) 的额外空间。</li>
</ul>

<h3 id="方法三随机化">方法三：随机化</h3>
<h3 id="思路-1">思路</h3>

<p>因为超过 <em>n/2</em> 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p>

<h3 id="算法-1">算法</h3>

<p>由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它是否是众数，如果是就返回，否则继续随机挑选。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">randRange</span><span class="o">(</span><span class="nc">Random</span> <span class="n">rand</span><span class="o">,</span> <span class="kt">int</span> <span class="n">min</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">max</span> <span class="o">-</span> <span class="n">min</span><span class="o">)</span> <span class="o">+</span> <span class="n">min</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">countOccurences</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">majorityElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">majorityCount</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">randRange</span><span class="o">(</span><span class="n">rand</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countOccurences</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">candidate</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">majorityCount</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">candidate</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="方法五boyer-moore-投票算法">方法五：Boyer-Moore 投票算法</h3>

<h4 id="思路-2">思路</h4>

<p>如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p>

<h4 id="算法-2">算法</h4>

<p>Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：</p>

<ul>
  <li>
    <p>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</p>
  </li>
  <li>
    <p>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p>

    <ul>
      <li>
        <p>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</p>
      </li>
      <li>
        <p>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>在遍历完成后，candidate 即为整个数组的众数。</p>
  </li>
</ul>

<p>我们举一个具体的例子，例如下面的这个数组：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>在遍历到数组中的第一个元素以及每个在</td>
      <td>之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。</td>
    </tr>
  </tbody>
</table>

<p>Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：</p>

<p>首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。</p>

<p>那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
</code></pre></div></div>
<p>作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
</code></pre></div></div>

<p>我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
</code></pre></div></div>
<p>有没有发现什么？我们将 count 和 value 放在一起：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
</code></pre></div></div>
<p>发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！</p>

<p>为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。</p>

<p>这样以来，由于：</p>

<ul>
  <li>
    <p>我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；</p>
  </li>
  <li>
    <p>由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；</p>
  </li>
</ul>

<p>在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">majorityElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">Integer</span> <span class="n">candidate</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">candidate</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">candidate</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="复杂度分析-1">复杂度分析</h4>
<ul>
  <li>时间复杂度：O(n)O(n)。Boyer-Moore 算法只对数组进行了一次遍历。</li>
  <li>空间复杂度：O(1)O(1)。Boyer-Moore 算法只需要常数级别的额外空间。</li>
</ul>
:ET